[
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/1. Learning/01. Implement min heap.cpp",
    "section": "09. Heaps",
    "subsection": "1. Learning",
    "file_name": "01. Implement min heap.cpp",
    "problem_title": " Implement Min Heap",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/1. Learning/02. Check if array is heap.cpp",
    "section": "09. Heaps",
    "subsection": "1. Learning",
    "file_name": "02. Check if array is heap.cpp",
    "problem_title": " Check If Array Is Heap",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/1. Learning/03. Convert min heap to max heap.cpp",
    "section": "09. Heaps",
    "subsection": "1. Learning",
    "file_name": "03. Convert min heap to max heap.cpp",
    "problem_title": " Convert Min Heap To Max Heap",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/3. Hard Problems/06. Top K frequent elements.cpp",
    "section": "09. Heaps",
    "subsection": "3. Hard Problems",
    "file_name": "06. Top K frequent elements.cpp",
    "problem_title": " Top K Frequent Elements",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/3. Hard Problems/01. Design Twitter.cpp",
    "section": "09. Heaps",
    "subsection": "3. Hard Problems",
    "file_name": "01. Design Twitter.cpp",
    "problem_title": " Design Twitter",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/3. Hard Problems/03. Kth largest element in stream.cpp",
    "section": "09. Heaps",
    "subsection": "3. Hard Problems",
    "file_name": "03. Kth largest element in stream.cpp",
    "problem_title": " Kth Largest Element In Stream",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/3. Hard Problems/05. Median in a stream.cpp",
    "section": "09. Heaps",
    "subsection": "3. Hard Problems",
    "file_name": "05. Median in a stream.cpp",
    "problem_title": " Median In A Stream",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/3. Hard Problems/02. Minimum Cost to join n ropes.cpp",
    "section": "09. Heaps",
    "subsection": "3. Hard Problems",
    "file_name": "02. Minimum Cost to join n ropes.cpp",
    "problem_title": " Minimum Cost To Join N Ropes",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/3. Hard Problems/04. Maximum K sum combinations.cpp",
    "section": "09. Heaps",
    "subsection": "3. Hard Problems",
    "file_name": "04. Maximum K sum combinations.cpp",
    "problem_title": " Maximum K Sum Combinations",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/2. Medium Problems/02. Kth smallest element.cpp",
    "section": "09. Heaps",
    "subsection": "2. Medium Problems",
    "file_name": "02. Kth smallest element.cpp",
    "problem_title": " Kth Smallest Element",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/2. Medium Problems/01. Kth largest element.cpp",
    "section": "09. Heaps",
    "subsection": "2. Medium Problems",
    "file_name": "01. Kth largest element.cpp",
    "problem_title": " Kth Largest Element",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/2. Medium Problems/07. Divide array into sets of K consecutive number.cpp",
    "section": "09. Heaps",
    "subsection": "2. Medium Problems",
    "file_name": "07. Divide array into sets of K consecutive number.cpp",
    "problem_title": " Divide Array Into Sets Of K Consecutive Number",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/2. Medium Problems/06. Task Scheduler.cpp",
    "section": "09. Heaps",
    "subsection": "2. Medium Problems",
    "file_name": "06. Task Scheduler.cpp",
    "problem_title": " Task Scheduler",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/2. Medium Problems/05. Arrange by rank.cpp",
    "section": "09. Heaps",
    "subsection": "2. Medium Problems",
    "file_name": "05. Arrange by rank.cpp",
    "problem_title": " Arrange By Rank",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/2. Medium Problems/03. Merge K sorted arrays.cpp",
    "section": "09. Heaps",
    "subsection": "2. Medium Problems",
    "file_name": "03. Merge K sorted arrays.cpp",
    "problem_title": " Merge K Sorted Arrays",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/09. Heaps/2. Medium Problems/04. Merge K sorted Lists.cpp",
    "section": "09. Heaps",
    "subsection": "2. Medium Problems",
    "file_name": "04. Merge K sorted Lists.cpp",
    "problem_title": " Merge K Sorted Lists",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/16. Strings (Hard)/Hard/01. Minimum number of insertions to make parenthesis valid.cpp",
    "section": "16. Strings (Hard)",
    "subsection": "Hard",
    "file_name": "01. Minimum number of insertions to make parenthesis valid.cpp",
    "problem_title": " Minimum Number Of Insertions To Make Parenthesis Valid",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/16. Strings (Hard)/Hard/04. Longest Happy Prefix.cpp",
    "section": "16. Strings (Hard)",
    "subsection": "Hard",
    "file_name": "04. Longest Happy Prefix.cpp",
    "problem_title": " Longest Happy Prefix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/16. Strings (Hard)/Hard/03. KMP or Z string matching algo.cpp",
    "section": "16. Strings (Hard)",
    "subsection": "Hard",
    "file_name": "03. KMP or Z string matching algo.cpp",
    "problem_title": " Kmp Or Z String Matching Algo",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/16. Strings (Hard)/Hard/02. Count and Say.cpp",
    "section": "16. Strings (Hard)",
    "subsection": "Hard",
    "file_name": "02. Count and Say.cpp",
    "problem_title": " Count And Say",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/16. Strings (Hard)/Hard/05. Shortest Palindrome.cpp",
    "section": "16. Strings (Hard)",
    "subsection": "Hard",
    "file_name": "05. Shortest Palindrome.cpp",
    "problem_title": " Shortest Palindrome",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/15. Tries/1. Theory/01. Implement Trie (Prefix Tree).cpp",
    "section": "15. Tries",
    "subsection": "1. Theory",
    "file_name": "01. Implement Trie (Prefix Tree).cpp",
    "problem_title": " Implement Trie (Prefix Tree)",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/15. Tries/2. Problems/01. Implement Trie 2.cpp",
    "section": "15. Tries",
    "subsection": "2. Problems",
    "file_name": "01. Implement Trie 2.cpp",
    "problem_title": " Implement Trie 2",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/15. Tries/2. Problems/04. Bitwise basic operations.cpp",
    "section": "15. Tries",
    "subsection": "2. Problems",
    "file_name": "04. Bitwise basic operations.cpp",
    "problem_title": " Bitwise Basic Operations",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/15. Tries/2. Problems/05. Maximum XOR of two numbers.cpp",
    "section": "15. Tries",
    "subsection": "2. Problems",
    "file_name": "05. Maximum XOR of two numbers.cpp",
    "problem_title": " Maximum Xor Of Two Numbers",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/15. Tries/2. Problems/03. Count distinct subsitrings.cpp",
    "section": "15. Tries",
    "subsection": "2. Problems",
    "file_name": "03. Count distinct subsitrings.cpp",
    "problem_title": " Count Distinct Subsitrings",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/15. Tries/2. Problems/02. Complete String.cpp",
    "section": "15. Tries",
    "subsection": "2. Problems",
    "file_name": "02. Complete String.cpp",
    "problem_title": " Complete String",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/1. Traversals/06. Level Order Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "1. Traversals",
    "file_name": "06. Level Order Traversal.cpp",
    "problem_title": " Level Order Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/1. Traversals/01. Introduction to trees.cpp",
    "section": "11. Binary Trees",
    "subsection": "1. Traversals",
    "file_name": "01. Introduction to trees.cpp",
    "problem_title": " Introduction To Trees",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/1. Traversals/10. All in one traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "1. Traversals",
    "file_name": "10. All in one traversal.cpp",
    "problem_title": " All In One Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/1. Traversals/05. Postorder Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "1. Traversals",
    "file_name": "05. Postorder Traversal.cpp",
    "problem_title": " Postorder Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/1. Traversals/07. Iterative Preorder Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "1. Traversals",
    "file_name": "07. Iterative Preorder Traversal.cpp",
    "problem_title": " Iterative Preorder Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/1. Traversals/02. Binary Tree representation.cpp",
    "section": "11. Binary Trees",
    "subsection": "1. Traversals",
    "file_name": "02. Binary Tree representation.cpp",
    "problem_title": " Binary Tree Representation",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/1. Traversals/03. Preorder Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "1. Traversals",
    "file_name": "03. Preorder Traversal.cpp",
    "problem_title": " Preorder Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/1. Traversals/09. Iterative Postorder.cpp",
    "section": "11. Binary Trees",
    "subsection": "1. Traversals",
    "file_name": "09. Iterative Postorder.cpp",
    "problem_title": " Iterative Postorder",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/1. Traversals/08. Iterative Inorder Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "1. Traversals",
    "file_name": "08. Iterative Inorder Traversal.cpp",
    "problem_title": " Iterative Inorder Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/1. Traversals/04. Inorder Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "1. Traversals",
    "file_name": "04. Inorder Traversal.cpp",
    "problem_title": " Inorder Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/10. Bottom View.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "10. Bottom View.cpp",
    "problem_title": " Bottom View",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/06. Zig-Zag Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "06. Zig-Zag Traversal.cpp",
    "problem_title": " Zig-Zag Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/04. Maximum Path Sum.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "04. Maximum Path Sum.cpp",
    "problem_title": " Maximum Path Sum",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/03. Diameter of Binary Tree.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "03. Diameter of Binary Tree.cpp",
    "problem_title": " Diameter Of Binary Tree",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/01. Height of binary tree.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "01. Height of binary tree.cpp",
    "problem_title": " Height Of Binary Tree",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/08. Vertical Order Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "08. Vertical Order Traversal.cpp",
    "problem_title": " Vertical Order Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/02. Balanced Binary Tree.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "02. Balanced Binary Tree.cpp",
    "problem_title": " Balanced Binary Tree",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/07. Boundary Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "07. Boundary Traversal.cpp",
    "problem_title": " Boundary Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/12. Symmetric Tree.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "12. Symmetric Tree.cpp",
    "problem_title": " Symmetric Tree",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/11. Left or Right View.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "11. Left or Right View.cpp",
    "problem_title": " Left Or Right View",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/05. Same Tree.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "05. Same Tree.cpp",
    "problem_title": " Same Tree",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/2. Medium Problems/09. Top View.cpp",
    "section": "11. Binary Trees",
    "subsection": "2. Medium Problems",
    "file_name": "09. Top View.cpp",
    "problem_title": " Top View",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/05. All nodes at distance K.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "05. All nodes at distance K.cpp",
    "problem_title": " All Nodes At Distance K",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/12. Morris Inorder Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "12. Morris Inorder Traversal.cpp",
    "problem_title": " Morris Inorder Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/11. Morris Preorder Traversal.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "11. Morris Preorder Traversal.cpp",
    "problem_title": " Morris Preorder Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/06. Min time to burn binary tree.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "06. Min time to burn binary tree.cpp",
    "problem_title": " Min Time To Burn Binary Tree",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/13. Flatten Binary Tree.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "13. Flatten Binary Tree.cpp",
    "problem_title": " Flatten Binary Tree",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/07. Count nodes in complete binary tree.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "07. Count nodes in complete binary tree.cpp",
    "problem_title": " Count Nodes In Complete Binary Tree",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/01. All root to leaf paths.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "01. All root to leaf paths.cpp",
    "problem_title": " All Root To Leaf Paths",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/08. Construct BT from inorder and preorder.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "08. Construct BT from inorder and preorder.cpp",
    "problem_title": " Construct Bt From Inorder And Preorder",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/02. Lowest Common Ancestor.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "02. Lowest Common Ancestor.cpp",
    "problem_title": " Lowest Common Ancestor",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/09. Construct BT from inorder and postorder.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "09. Construct BT from inorder and postorder.cpp",
    "problem_title": " Construct Bt From Inorder And Postorder",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/04. Check children sum property.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "04. Check children sum property.cpp",
    "problem_title": " Check Children Sum Property",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/03. Max width of binary tree.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "03. Max width of binary tree.cpp",
    "problem_title": " Max Width Of Binary Tree",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/11. Binary Trees/3. Hard/14. Serialize and Deserialize.cpp",
    "section": "11. Binary Trees",
    "subsection": "3. Hard",
    "file_name": "14. Serialize and Deserialize.cpp",
    "problem_title": " Serialize And Deserialize",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/03.Majority_element.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "03.Majority_element.cpp",
    "problem_title": "Majority Element",
    "question": "Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.\n\nExample 1:\n\nInput: nums = [3,2,3]\nOutput: 3\n\nExample 2:\n\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2",
    "approach": null,
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/05.Number_of_subarray_sum_equal_k.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "05.Number_of_subarray_sum_equal_k.cpp",
    "problem_title": "Number Of Subarray Sum Equal K",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/01.2_sum_problem.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "01.2_sum_problem.cpp",
    "problem_title": "2 Sum Problem",
    "question": null,
    "approach": null,
    "time_complexity": "O(N)",
    "space_complexity": "O(N)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/09.Leaders_in_array.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "09.Leaders_in_array.cpp",
    "problem_title": "Leaders In Array",
    "question": "Given an array A of positive integers. Your task is to find the leaders in the array. An element of the array is a leader if it is greater than or equal to all the elements to its right side. The rightmost element is always a leader.\n\nExample 1:\nInput:\nn = 6\nA[] = {16,17,4,3,5,2}\nOutput: 17 5 2\nExplanation: The first leader is 17 as it is greater than all the elements to its right. Similarly, the next leader is 5. The rightmost element is always a leader, so it is also included.",
    "approach": "To find the leaders in the array, we can follow these steps:\n\n1. Initialize a variable `maxRight` with the rightmost element of the array.\n2. Iterate the array from right to left:\n   - If the current element is greater than or equal to `maxRight`, it is a leader. Print the current element and update `maxRight` to the current element.\n3. Finally, print `maxRight` as it is always a leader.",
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/02.Sort_0_1_2.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "02.Sort_0_1_2.cpp",
    "problem_title": "Sort 0 1 2",
    "question": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\n\nExample 1:\n\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\nExample 2:\n\nInput: nums = [2,0,1]\nOutput: [0,1,2]",
    "approach": "-> Initialize three pointers: low at the beginning of the array, mid at the beginning of the array, and high at the end of the array.\n-> Iterate through the array while the mid pointer is less than or equal to the high pointer:\n1. If the current element at the mid pointer is 0 (red), we swap it with the element at the low pointer and increment both low and mid pointers. This ensures that red elements are moved to the left side of the array.\n2. If the current element at the mid pointer is 1 (white), we simply increment the mid pointer. This keeps white elements in the middle of the array.\n3. If the current element at the mid pointer is 2 (blue), we swap it with the element at the high pointer and decrement the high pointer. This ensures that blue elements are moved to the right side of the array.\n\nRepeat step 2 until the mid pointer crosses the high pointer.\nAt the end of the algorithm, the array will be sorted in the desired order.",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/04.Kadane's_algorithm.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "04.Kadane's_algorithm.cpp",
    "problem_title": "Kadane'S Algorithm",
    "question": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.",
    "approach": "-> Initialize two variables: maxSum and currentSum. Set both variables to the first element of the array.\n-> Iterate through the array starting from the second element:\n    Update currentSum by adding the current element to it.\n    If currentSum becomes negative, reset it to 0. This step ensures that we consider only the subarrays with positive sums.\n    Update maxSum by taking the maximum value between maxSum and currentSum. This keeps track of the maximum subarray sum encountered so far.\n-> After the iteration, the maxSum variable will hold the largest sum of any subarray.\n-> Return the maxSum as the result.",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/06.Stock_buy_sell.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "06.Stock_buy_sell.cpp",
    "problem_title": "Stock Buy Sell",
    "question": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.",
    "approach": "Initialize two variables: min_price and max_profit.\n\n-> min_price = minimum price in the array.\n-> max_profit = 0.\n\nIterate through the array, and for each price:\n\n-> Update min_price to the minimum price seen so far.\n-> Update max_profit to the maximum profit seen so far, or the current price minus min_price, whichever is greater.\n\nReturn max_profit.",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/07.Rearange_elements_by_sign.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "07.Rearange_elements_by_sign.cpp",
    "problem_title": "Rearange Elements By Sign",
    "question": "You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.\nYou should rearrange the elements of nums such that the modified array follows the given conditions:\nEvery consecutive pair of integers have opposite signs.\nFor all integers with the same sign, the order in which they were present in nums is preserved.\nThe rearranged array begins with a positive integer.\nReturn the modified array after rearranging the elements to satisfy the aforementioned conditions.\n\n\nExample 1:\n\nInput: nums = [3,1,-2,-5,2,-4]\nOutput: [3,-2,1,-5,2,-4]\nExplanation:\nThe positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].\nThe only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].\nOther ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.",
    "approach": "Initialize two pointers, pos_ptr and neg_ptr. pos_ptr will point to the first positive integer in the array, and neg_ptr will point to the first negative integer in the array.\nIterate over the array.\nIf the current integer is positive, swap it with the element at neg_ptr.\nIncrement pos_ptr by 1.\nIncrement neg_ptr by 1.\nRepeat steps 3-5 until the end of the array is reached.\nThe array will now be rearranged such that every consecutive pair of integers have opposite signs.",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/11.Set_matrix_0's.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "11.Set_matrix_0's.cpp",
    "problem_title": "Set Matrix 0'S",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/12.Rotate_matrix.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "12.Rotate_matrix.cpp",
    "problem_title": "Rotate Matrix",
    "question": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nExample 1:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nExample 2:\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
    "approach": "To rotate the image by 90 degrees clockwise in-place, we can follow these steps:\n\n1. Transpose the matrix: Iterate over the matrix and swap each element (i, j) with its corresponding element (j, i). This step transforms rows into columns.\n\n2. Reverse each row: Iterate over each row in the transposed matrix and reverse the elements. This step ensures the rotation in a clockwise direction.",
    "time_complexity": "O(N^2), where N is the size of the matrix.",
    "space_complexity": "O(1)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/13.Spiral_traversal.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "13.Spiral_traversal.cpp",
    "problem_title": "Spiral Traversal",
    "question": "Given an m x n matrix, return all elements of the matrix in spiral order.\n\nExample 1:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nExample 2:\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]",
    "approach": "To traverse the matrix in a spiral order, we can use the following steps:\n\n1. Initialize four variables: top, bottom, left, and right to keep track of the boundaries of the current spiral.\n2. Create an empty vector called 'ans' to store the elements in spiral order.\n3. While the top boundary is less than or equal to the bottom boundary and the left boundary is less than or equal to the right boundary:\n   - Traverse the top row from left to right and add each element to 'ans'.\n   - Increment the top boundary.\n   - Traverse the right column from top to bottom and add each element to 'ans'.\n   - Decrement the right boundary.\n   - Check if the top boundary is still less than or equal to the bottom boundary:\n     - Traverse the bottom row from right to left and add each element to 'ans'.\n     - Decrement the bottom boundary.\n   - Check if the left boundary is still less than or equal to the right boundary:\n     - Traverse the left column from bottom to top and add each element to 'ans'.\n     - Increment the left boundary.\n4. Return the 'ans' vector containing all the elements in spiral order.",
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/10.Longest_consecutive_subsequence.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "10.Longest_consecutive_subsequence.cpp",
    "problem_title": "Longest Consecutive Subsequence",
    "question": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nExample 1:\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n\nExample 2:\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9",
    "approach": "To find the length of the longest consecutive elements sequence, we can follow these steps:\n\n1. Create a set to store all the elements of the array.\n2. Iterate through the array and insert each element into the set.\n3. For each element, check if its previous consecutive element (num-1) exists in the set. If it does not exist, it means the current element is the starting element of a sequence.\n4. For each starting element, keep incrementing the current element (num+1) and checking if it exists in the set. This will help find the consecutive elements in the sequence.\n5. Keep track of the maximum length of consecutive elements encountered.\n6. Return the maximum length as the result.",
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/2.Medium/08.Next_permutation.cpp",
    "section": "01.Arrays",
    "subsection": "2.Medium",
    "file_name": "08.Next_permutation.cpp",
    "problem_title": "Next Permutation",
    "question": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\nFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\nFor example, the next permutation of arr = [1,2,3] is [1,3,2].\nSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\nWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place and use only constant extra memory.\n\nExample 1:\nInput: nums = [1,2,3]\nOutput: [1,3,2]",
    "approach": "To find the next permutation of an array, we can follow these steps:\n\n1. Find the first index `i` from the right such that `nums[i] < nums[i+1]`. This is the first element that needs to be swapped.\n2. Find the first index `j` from the right such that `nums[j] > nums[i]`. This is the element that will replace `nums[i]`.\n3. Swap `nums[i]` and `nums[j]`.\n4. Reverse the subarray starting from `i+1` till the end of the array.\n5. If step 1 does not find any index `i`, it means the array is in descending order. In that case, reverse the entire array to get the lowest possible order.",
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/01.Pascal_triangle.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "01.Pascal_triangle.cpp",
    "problem_title": "Pascal Triangle",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/09.Repeating_and_missing_numbers.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "09.Repeating_and_missing_numbers.cpp",
    "problem_title": "Repeating And Missing Numbers",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/05.Largest_subarray_with_0sum.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "05.Largest_subarray_with_0sum.cpp",
    "problem_title": "Largest Subarray With 0Sum",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/13.Longest_subarray_with_sum_k_containg_+ves_and_-ves.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "13.Longest_subarray_with_sum_k_containg_+ves_and_-ves.cpp",
    "problem_title": "Longest Subarray With Sum K Containg +Ves And -Ves",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/11.Reverse_pairs.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "11.Reverse_pairs.cpp",
    "problem_title": "Reverse Pairs",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/03.3_sum.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "03.3_sum.cpp",
    "problem_title": "3 Sum",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/07.Merge_overlapping_subinterval.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "07.Merge_overlapping_subinterval.cpp",
    "problem_title": "Merge Overlapping Subinterval",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/04.4_sum.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "04.4_sum.cpp",
    "problem_title": "4 Sum",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/12.Maximum_product_subarray.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "12.Maximum_product_subarray.cpp",
    "problem_title": "Maximum Product Subarray",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/08.Merge_2_sorted_array_without_space.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "08.Merge_2_sorted_array_without_space.cpp",
    "problem_title": "Merge 2 Sorted Array Without Space",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/06.Subarrays_with_xor_k.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "06.Subarrays_with_xor_k.cpp",
    "problem_title": "Subarrays With Xor K",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/10.Count_inversions.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "10.Count_inversions.cpp",
    "problem_title": "Count Inversions",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/3.Hard/02.Majority_element_2.cpp",
    "section": "01.Arrays",
    "subsection": "3.Hard",
    "file_name": "02.Majority_element_2.cpp",
    "problem_title": "Majority Element 2",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/12.Longest_subarray_with_given_sum.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "12.Longest_subarray_with_given_sum.cpp",
    "problem_title": "Longest Subarray With Given Sum",
    "question": "You are given an array 'A' of size 'N' and an integer 'K'. You need to print the length of the longest subarray of array 'A' whose sum = 'K'.\nExample:\nInput: 'N' = 7 'K' = 3\n'A' = [1, 2, 3, 1, 1, 1, 1]\nOutput: 3\nExplanation: Subarrays whose sum = '3' are:\n[1, 2], [3], [1, 1, 1], [1, 1, 1]\nHere, the length of the longest subarray is 3, which is our final answer.",
    "approach": "-> Use sliding window approach using two pointers start and end\n-> Run a loop to traverse the entire array add from end and subtract from start when sum>k\n-> If sum==k then, update the ans now, window size = end-start+1",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/01.Largest_element_in_array.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "01.Largest_element_in_array.cpp",
    "problem_title": "Largest Element In Array",
    "question": "Given an array A[] of size n. The task is to find the largest element in it.\n\nExample:\n\nInput:\nn = 5\nA[] = {1, 8, 7, 56, 90}\nOutput:\n90\nExplanation:\nThe largest element of given array is 90",
    "approach": "-> Intialize the ans with starting element\n-> Traverse the entire array and update the ans if the element is greater then ans\n-> Finally, return the ans",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/05.Rotate_array_left_by_1place.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "05.Rotate_array_left_by_1place.cpp",
    "problem_title": "Rotate Array Left By 1Place",
    "question": "Given an array \"ARR' containing 'N' elements, rotate this array Left by once means to shift all elements by one place to the left and move the first element to the last position in the array.\n\nExample:\nInput: 'N' 5, 'ARR' = [1, 2, 3, 4, 5]\nOutput: [2, 3, 4, 5, 1]\n\nExplanation:\nWe moved the 2nd element to the 1st position and 3rd element to the 2nd position and 4th element to the 3rd position and 5th element to the 4th position and move oth element to the 5th position.",
    "approach": "-> By observing we can the ans is the arr where arr[i] = arr[i+1] and at last place we will have arr[0]\n-> Before traversing store the arr[0] in temp and then traverse the array and make arr[i] = arr[i+1]\n-> Make arr[n-1] = arr[0], where n is the size of the array",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/02.Second_largest_element_in_array.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "02.Second_largest_element_in_array.cpp",
    "problem_title": "Second Largest Element In Array",
    "question": "Given an array Arr of size N, print second largest distinct element from an array.\n\nExample:\n\nInput:\nN = 6\nArr[] = {12, 35, 1, 10, 34, 1}\nOutput: 34\nExplanation: The largest element of the\narray is 35 and the second largest element\nis 34.",
    "approach": null,
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/11.Max_consecutive_1's.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "11.Max_consecutive_1's.cpp",
    "problem_title": "Max Consecutive 1'S",
    "question": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\n\nExample 1:\n\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\nExample 2:\n\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.",
    "approach": "-> Traverse the entire array and within it run a loop while element's are equal to 1 and store the count\n-> Update the ans as max(ans,cnt)",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/13.Find_element_present_only_once.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "13.Find_element_present_only_once.cpp",
    "problem_title": "Find Element Present Only Once",
    "question": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n\nExample 1:\nInput: nums = [2,2,1]\nOutput: 1\n\nExample 2:\nInput: nums = [4,1,2,1,2]\nOutput: 4",
    "approach": "-> We can use XOR operation as we know xor cancles out the same elements\n-> Intial xr=0 then traverse the entire array and xor each element with xr\n-> Since only one element is present once and all other are present twice so the remaining element would be the\n    one which is present only once cause all other gets cancels out",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/03.Check_if_array_is_sorted_and_rotated.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "03.Check_if_array_is_sorted_and_rotated.cpp",
    "problem_title": "Check If Array Is Sorted And Rotated",
    "question": "Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.\nThere may be duplicates in the original array.\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: true\nExplanation: [1,2,3,4,5] is the original sorted array.\nYou can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].\nExample 2:\n\nInput: nums = [2,1,3,4]\nOutput: false\nExplanation: There is no sorted array once rotated that can make nums.",
    "approach": "Compare all neignbour elements (a,b) in A,\nthe case of a > b can happen at most once.\n\nNote that the first element and the last element are also connected.\n\nIf all a <= b, A is already sorted so answer is true.\nIf all a <= b but only one a > b, and the first element is greater than equal to last element\nwe can rotate and make b the first element so answer is true.\nOther case, return false.",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/08.Linear_search.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "08.Linear_search.cpp",
    "problem_title": "Linear Search",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/04.Remove_duplicates_from_sorted_array.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "04.Remove_duplicates_from_sorted_array.cpp",
    "problem_title": "Remove Duplicates From Sorted Array",
    "question": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
    "approach": "-> The idea, is to use keep a pointer k which signifies that upto here the array is sorted\n-> Now travese the entire array and if arr[k]!=arr[j] that is arr[j] is a unique value hence it should be included\n   so increment the k and swap arr[k] with arr[j]\n-> Return k+1, +1 is because of 0 based indexing",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/09.Union_of_2_sorted_arrays.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "09.Union_of_2_sorted_arrays.cpp",
    "problem_title": "Union Of 2 Sorted Arrays",
    "question": "Union of two arrays can be defined as the common and distinct elements in the two arrays.\nGiven two sorted arrays of size n and m respectively, find their union.\n\n\nExample 1:\n\nInput:\nn = 5, arr1[] = {1, 2, 3, 4, 5}\nm = 3, arr2 [] = {1, 2, 3}\nOutput: 1 2 3 4 5\nExplanation: Distinct elements including\nboth the arrays are: 1 2 3 4 5.\n\n\nExample 2:\n\nInput:\nn = 5, arr1[] = {2, 2, 3, 4, 5}\nm = 5, arr2[] = {1, 1, 2, 3, 4}\nOutput: 1 2 3 4 5\nExplanation: Distinct elements including\nboth the arrays are: 1 2 3 4 5.",
    "approach": "-> Take two pointer i and j where i is for arr1 and j is for arr2 and traverse\n-> While travsersing 3 cases arises\n    -> arr1[ i ] == arr2[ j ]\n        Here we found a common element, so insert only one element in the union.\n        Let\u2019s insert arr[i] in union and whenever we insert element we increment pointer while pointer is not equal to the inserted element\n    -> arr1[i]<arr2[j]\n        Here insert arr[i]\n    -> arr1[i]>arr2[j]\n        Here insert arr2[j]\n-> Now check if elements of any array is left to traverse then traverse that array",
    "time_complexity": "O(N+M)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/10.Missing_number.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "10.Missing_number.cpp",
    "problem_title": "Missing Number",
    "question": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\n\nExample 1:\n\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\nExample 2:\n\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.",
    "approach": "-> Calculate the optimum sum i.e. sum when all elements were present\n-> Calculate the actual array's sum\n-> Return the optimum sum - actual sum",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/07.Move_0's_to_end.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "07.Move_0's_to_end.cpp",
    "problem_title": "Move 0'S To End",
    "question": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.\n\nExample 1:\n\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\n\nInput: nums = [0]\nOutput: [0]",
    "approach": "-> The idea is while traversing the array if we found any zero then we have to swap it with next non-zero",
    "time_complexity": "O(N) (as we moving j throught the array only once)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/01.Arrays/1.Easy/06.Rotate_array_left&right_by_k_places.cpp",
    "section": "01.Arrays",
    "subsection": "1.Easy",
    "file_name": "06.Rotate_array_left&right_by_k_places.cpp",
    "problem_title": "Rotate Array Left&Right By K Places",
    "question": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation:\nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]",
    "approach": "To rotate the array k places to right follow below steps\n-> Reverse first n-k elements\n-> Reverse last k elements\n-> Reverse the entire array\n\nTo rotate the array k places to left follow below steps\n-> Reverse first k elements\n-> Reverse last n-k elements\n-> Reverse the entire array",
    "time_complexity": "O(N)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/2.Subsequences Pattern/10.Letter combinations of phone.cpp",
    "section": "05.Recursion",
    "subsection": "2.Subsequences Pattern",
    "file_name": "10.Letter combinations of phone.cpp",
    "problem_title": "Letter Combinations Of Phone",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/2.Subsequences Pattern/01.Genereate all valid parenthesis.cpp",
    "section": "05.Recursion",
    "subsection": "2.Subsequences Pattern",
    "file_name": "01.Genereate all valid parenthesis.cpp",
    "problem_title": "Genereate All Valid Parenthesis",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/2.Subsequences Pattern/05.Subset 1.cpp",
    "section": "05.Recursion",
    "subsection": "2.Subsequences Pattern",
    "file_name": "05.Subset 1.cpp",
    "problem_title": "Subset 1",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/2.Subsequences Pattern/07.Combination Sum 1.cpp",
    "section": "05.Recursion",
    "subsection": "2.Subsequences Pattern",
    "file_name": "07.Combination Sum 1.cpp",
    "problem_title": "Combination Sum 1",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/2.Subsequences Pattern/03.Count distinct substrings.cpp",
    "section": "05.Recursion",
    "subsection": "2.Subsequences Pattern",
    "file_name": "03.Count distinct substrings.cpp",
    "problem_title": "Count Distinct Substrings",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/2.Subsequences Pattern/08.Combination Sum 2.cpp",
    "section": "05.Recursion",
    "subsection": "2.Subsequences Pattern",
    "file_name": "08.Combination Sum 2.cpp",
    "problem_title": "Combination Sum 2",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/2.Subsequences Pattern/09.Combination Sum 3.cpp",
    "section": "05.Recursion",
    "subsection": "2.Subsequences Pattern",
    "file_name": "09.Combination Sum 3.cpp",
    "problem_title": "Combination Sum 3",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/2.Subsequences Pattern/06.Subset 2.cpp",
    "section": "05.Recursion",
    "subsection": "2.Subsequences Pattern",
    "file_name": "06.Subset 2.cpp",
    "problem_title": "Subset 2",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/2.Subsequences Pattern/04.Count subsets with sum equal to k.cpp",
    "section": "05.Recursion",
    "subsection": "2.Subsequences Pattern",
    "file_name": "04.Count subsets with sum equal to k.cpp",
    "problem_title": "Count Subsets With Sum Equal To K",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/2.Subsequences Pattern/02.Power set.cpp",
    "section": "05.Recursion",
    "subsection": "2.Subsequences Pattern",
    "file_name": "02.Power set.cpp",
    "problem_title": "Power Set",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/1.Get Strong Hold/01.Implement_atoi_via_recursion.cpp",
    "section": "05.Recursion",
    "subsection": "1.Get Strong Hold",
    "file_name": "01.Implement_atoi_via_recursion.cpp",
    "problem_title": "Implement Atoi Via Recursion",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/1.Get Strong Hold/03.Reverse_stack_using_recursion.cpp",
    "section": "05.Recursion",
    "subsection": "1.Get Strong Hold",
    "file_name": "03.Reverse_stack_using_recursion.cpp",
    "problem_title": "Reverse Stack Using Recursion",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/1.Get Strong Hold/02.Count_good_numbers.cpp",
    "section": "05.Recursion",
    "subsection": "1.Get Strong Hold",
    "file_name": "02.Count_good_numbers.cpp",
    "problem_title": "Count Good Numbers",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/1.Get Strong Hold/04.Sort_stack_using_recursion.cpp",
    "section": "05.Recursion",
    "subsection": "1.Get Strong Hold",
    "file_name": "04.Sort_stack_using_recursion.cpp",
    "problem_title": "Sort Stack Using Recursion",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/3.Try Out All Combos/05.N queens.cpp",
    "section": "05.Recursion",
    "subsection": "3.Try Out All Combos",
    "file_name": "05.N queens.cpp",
    "problem_title": "N Queens",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/3.Try Out All Combos/02.Word search in grid.cpp",
    "section": "05.Recursion",
    "subsection": "3.Try Out All Combos",
    "file_name": "02.Word search in grid.cpp",
    "problem_title": "Word Search In Grid",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/3.Try Out All Combos/06.Word Break.cpp",
    "section": "05.Recursion",
    "subsection": "3.Try Out All Combos",
    "file_name": "06.Word Break.cpp",
    "problem_title": "Word Break",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/3.Try Out All Combos/03.Rat in maze.cpp",
    "section": "05.Recursion",
    "subsection": "3.Try Out All Combos",
    "file_name": "03.Rat in maze.cpp",
    "problem_title": "Rat In Maze",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/3.Try Out All Combos/04.M coloring problem.cpp",
    "section": "05.Recursion",
    "subsection": "3.Try Out All Combos",
    "file_name": "04.M coloring problem.cpp",
    "problem_title": "M Coloring Problem",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/3.Try Out All Combos/07.Sudoku solver.cpp",
    "section": "05.Recursion",
    "subsection": "3.Try Out All Combos",
    "file_name": "07.Sudoku solver.cpp",
    "problem_title": "Sudoku Solver",
    "question": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy all of the following rules:\n- Each of the digits 1-9 must occur exactly once in each row.\n- Each of the digits 1-9 must occur exactly once in each column.\n- Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n- The '.' character indicates empty cells.\n\nExample:\nInput:\n[\n  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\n\nOutput:\n[\n  [\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],\n  [\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],\n  [\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n  [\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n  [\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n  [\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],\n  [\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n  [\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n  [\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]\n]\n\nApproach:\nWe can solve the Sudoku puzzle using a backtracking approach.\n1. Iterate over each cell in the board.\n2. If the cell is empty (denoted by '.'), try placing a digit from 1 to 9.\n3. Check if the placement is valid by verifying that the digit does not already exist in the same row, column, or 3x3 sub-box.\n4. If the placement is valid, update the cell with the digit and move to the next cell recursively.\n5. If the placement is not valid or we have reached the end of the board, backtrack by undoing the placement and trying the next digit.\n6. Repeat this process until we have filled all the cells or found a valid solution.\n\nTime Complexity: The time complexity of the backtracking algorithm for solving a Sudoku puzzle is O(9^(m*n)), where m and n are the number of rows and columns in the board. In the worst case, we have to try all possible combinations.\nSpace Complexity: The space complexity is O(1) as we are using a constant amount of space for the board and temporary variables.\n\nCODE:-",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/05.Recursion/3.Try Out All Combos/01.Palindrome partioning.cpp",
    "section": "05.Recursion",
    "subsection": "3.Try Out All Combos",
    "file_name": "01.Palindrome partioning.cpp",
    "problem_title": "Palindrome Partioning",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/10. Distinct Islands.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "10. Distinct Islands.cpp",
    "problem_title": " Distinct Islands",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/12. Detect Cycle in Directed Graph.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "12. Detect Cycle in Directed Graph.cpp",
    "problem_title": " Detect Cycle In Directed Graph",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/05. 01 Matrix.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "05. 01 Matrix.cpp",
    "problem_title": " 01 Matrix",
    "question": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\n\nThe distance between two adjacent cells is 1.\n\nAPPROACH:\n- We can use a Breadth-First Search (BFS) traversal to find the distance of the nearest 0 for each cell.\n- First, we initialize the distance matrix with -1 for all cells.\n- Then, we iterate through the matrix and find all cells with the value 0. For each 0 cell found, we add it to the queue and set its distance to 0 in the distance matrix.\n- Next, we perform a BFS starting from the cells with 0. During the BFS, we update the distance of each cell from the nearest 0 cell and continue the BFS until all cells are visited.\n- Finally, we return the distance matrix.\n\nCOMPLEXITY ANALYSIS:\n- Time Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. In the worst case, we may need to visit all the cells of the matrix.\n- Space Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. We use additional space for the distance matrix and the queue during BFS.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/06. Surrounded Regions.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "06. Surrounded Regions.cpp",
    "problem_title": " Surrounded Regions",
    "question": "Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\n\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\n\nAPPROACH:\n- We can use Depth-First Search (DFS) to find all regions that are surrounded by 'X'.\n- First, we initialize a copy of the board called 'vis' to store the visited status of each cell.\n- Then, we perform a DFS starting from all border cells that have 'O's. During the DFS, we mark all connected 'O's as visited by changing them to a special character, such as '#', in the 'vis' matrix.\n- After performing DFS from border cells, all remaining '#'s in the 'vis' matrix represent regions that are not surrounded by 'X'.\n- Finally, we update the original board by flipping all remaining 'O's to 'X'.\n\nCOMPLEXITY ANALYSIS:\n- Time Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. In the worst case, we may need to visit all the cells of the matrix during DFS.\n- Space Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. We use additional space for the 'vis' matrix.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/08. Word Ladder.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "08. Word Ladder.cpp",
    "problem_title": " Word Ladder",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/03. Flood-Fill Algorithm.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "03. Flood-Fill Algorithm.cpp",
    "problem_title": " Flood-Fill Algorithm",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/04. Detect Cycle in Undirected Graph.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "04. Detect Cycle in Undirected Graph.cpp",
    "problem_title": " Detect Cycle In Undirected Graph",
    "question": "Given an undirected graph with V vertices and E edges, check whether it contains any cycle or not. Graph is in the form of adjacency list where adj[i] contains all the nodes ith node is having an edge with.\n\nAPPROACH:\n- To check whether the graph contains a cycle or not, we can perform a Depth-First Search (DFS) traversal on the graph and keep track of the visited nodes.\n- During the DFS traversal, if we encounter a node that is already visited and is not the parent of the current node (indicating a back edge), then there is a cycle in the graph. We need to check this condition for every node in the graph.\n\nCOMPLEXITY ANALYSIS:\n- Time Complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph. In the worst case, we may need to visit all the vertices and edges of the graph.\n- Space Complexity: O(V), where V is the number of vertices. We use an additional array to keep track of visited nodes.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/11. Bipartite Graph.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "11. Bipartite Graph.cpp",
    "problem_title": " Bipartite Graph",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/02. Rotten Oranges.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "02. Rotten Oranges.cpp",
    "problem_title": " Rotten Oranges",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/01. Count the number of provinces.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "01. Count the number of provinces.cpp",
    "problem_title": " Count The Number Of Provinces",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/2. Traversal Problems/07. Number of Enclaves.cpp",
    "section": "13. Graphs",
    "subsection": "2. Traversal Problems",
    "file_name": "07. Number of Enclaves.cpp",
    "problem_title": " Number Of Enclaves",
    "question": "You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.\n\nA move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.\n\nReturn the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.\n\nAPPROACH:\n- We can use Depth-First Search (DFS) to mark all land cells connected to the boundary of the grid as uncountable (i.e., cells that we can walk off the boundary).\n- First, we initialize a copy of the grid called 'vis' to store the visited status of each cell.\n- Then, we perform DFS from all land cells located at the boundary of the grid. During the DFS, we mark all connected land cells as visited by changing their value to -1 in the 'vis' matrix.\n- After performing DFS from boundary cells, all remaining land cells in the 'vis' matrix represent cells that we cannot walk off the boundary of the grid.\n- Finally, we count the number of land cells in the 'vis' matrix and return the count as the result.\n\nCOMPLEXITY ANALYSIS:\n- Time Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. In the worst case, we may need to visit all the cells of the matrix during DFS.\n- Space Complexity: O(m * n), where m is the number of rows and n is the number of columns in the matrix. We use additional space for the 'vis' matrix.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/3. Topo Sort Problems/02. Kahn's Algorithm.cpp",
    "section": "13. Graphs",
    "subsection": "3. Topo Sort Problems",
    "file_name": "02. Kahn's Algorithm.cpp",
    "problem_title": " Kahn'S Algorithm",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/3. Topo Sort Problems/06. Alien Dictonary.cpp",
    "section": "13. Graphs",
    "subsection": "3. Topo Sort Problems",
    "file_name": "06. Alien Dictonary.cpp",
    "problem_title": " Alien Dictonary",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/3. Topo Sort Problems/03. Course Scheduler 1.cpp",
    "section": "13. Graphs",
    "subsection": "3. Topo Sort Problems",
    "file_name": "03. Course Scheduler 1.cpp",
    "problem_title": " Course Scheduler 1",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/3. Topo Sort Problems/04. Course Scheduler 2.cpp",
    "section": "13. Graphs",
    "subsection": "3. Topo Sort Problems",
    "file_name": "04. Course Scheduler 2.cpp",
    "problem_title": " Course Scheduler 2",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/3. Topo Sort Problems/01. Topological Sorting.cpp",
    "section": "13. Graphs",
    "subsection": "3. Topo Sort Problems",
    "file_name": "01. Topological Sorting.cpp",
    "problem_title": " Topological Sorting",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/3. Topo Sort Problems/05. Find Eventual Safe State.cpp",
    "section": "13. Graphs",
    "subsection": "3. Topo Sort Problems",
    "file_name": "05. Find Eventual Safe State.cpp",
    "problem_title": " Find Eventual Safe State",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/1. Learning/03. BFS.cpp",
    "section": "13. Graphs",
    "subsection": "1. Learning",
    "file_name": "03. BFS.cpp",
    "problem_title": " Bfs",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/1. Learning/02. Graph Representation.cpp",
    "section": "13. Graphs",
    "subsection": "1. Learning",
    "file_name": "02. Graph Representation.cpp",
    "problem_title": " Graph Representation",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/1. Learning/01. Count the number of graphs.cpp",
    "section": "13. Graphs",
    "subsection": "1. Learning",
    "file_name": "01. Count the number of graphs.cpp",
    "problem_title": " Count The Number Of Graphs",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/1. Learning/04. DFS.cpp",
    "section": "13. Graphs",
    "subsection": "1. Learning",
    "file_name": "04. DFS.cpp",
    "problem_title": " Dfs",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/6. Other Algorithms/01. Bridges in graph.cpp",
    "section": "13. Graphs",
    "subsection": "6. Other Algorithms",
    "file_name": "01. Bridges in graph.cpp",
    "problem_title": " Bridges In Graph",
    "question": "There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.\nA critical connection is a connection that, if removed, will make some servers unable to reach some other server.\nReturn all critical connections in the network in any order.\n\nApproach:\n1. We can use Tarjan's algorithm to find the critical connections in the network.\n2. Tarjan's algorithm is used to find bridges in an undirected graph, which are exactly the critical connections.\n3. We perform a depth-first search (DFS) on the graph and keep track of the timestamp (time) when each node is visited.\n4. We also maintain two arrays, tin and low, to store the timestamp of each node and the lowest timestamp reachable from the node using a back edge or a cross edge, respectively.\n5. During the DFS, if we encounter an edge (u, v) such that low[v] > tin[u], it means the edge (u, v) is a critical connection (bridge).\n6. We add all such critical connections to the result.\n\nComplexity Analysis:\n- Let n be the number of servers and m be the number of connections in the network.\n- The time complexity of this approach is O(n + m) since we perform a single DFS on the graph.\n- The space complexity is O(n + m) to store the graph adjacency list and O(n) for the auxiliary arrays.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/6. Other Algorithms/02. Strongly Connected Components.cpp",
    "section": "13. Graphs",
    "subsection": "6. Other Algorithms",
    "file_name": "02. Strongly Connected Components.cpp",
    "problem_title": " Strongly Connected Components",
    "question": "Given a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, Find the number of strongly connected components in the graph.\n\nApproach:\n1. We can use Kosaraju's algorithm to find the number of strongly connected components (SCCs) in a directed graph.\n2. Kosaraju's algorithm performs two DFS traversal on the graph to find SCCs.\n3. In the first DFS traversal, we find the order of vertices in which they finish their DFS traversal (topological ordering).\n4. In the second DFS traversal, we visit the vertices in reverse order of their finish times (based on the first DFS traversal) and mark the SCCs.\n5. The number of SCCs will be the number of times we perform the second DFS traversal and find a new SCC.\n\nComplexity Analysis:\n- Let V be the number of vertices and E be the number of edges in the directed graph.\n- The time complexity of Kosaraju's algorithm is O(V + E) as we perform two DFS traversals.\n- The space complexity is O(V + E) to store the adjacency list and O(V) for the auxiliary arrays.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/5. MST Problems/07. Making Large Island.cpp",
    "section": "13. Graphs",
    "subsection": "5. MST Problems",
    "file_name": "07. Making Large Island.cpp",
    "problem_title": " Making Large Island",
    "question": "You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\nReturn the size of the largest island in grid after applying this operation.\nAn island is a 4-directionally connected group of 1s.\n\nApproach:\n1. Create a disjoint set to represent islands and initialize it with all cells.\n2. For each 1 cell, union it with its 4-directionally connected 1 cells in the disjoint set.\n3. Then, traverse the grid to find each 0 cell and count the size of connected islands that can be formed by changing this 0 to 1.\n4. Update the answer with the maximum island size found so far.\n5. Return the maximum island size.\n\nComplexity Analysis:\n- The time complexity of creating the disjoint set is O(n^2) as we need to initialize it with all cells.\n- The time complexity of the first pass (connecting 1 cells) is also O(n^2) as we traverse the entire grid once.\n- The time complexity of the second pass (counting island size for 0 cells) is O(n^2) as we again traverse the entire grid.\n- The time complexity of finding the maximum island size using the disjoint set is O(n^2) as we iterate through all cells.\n- Overall, the time complexity of the solution is O(n^2).\n- The space complexity is O(n^2) due to the disjoint set data structure.\n\nCODE:-",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/5. MST Problems/05. Account Merge.cpp",
    "section": "13. Graphs",
    "subsection": "5. MST Problems",
    "file_name": "05. Account Merge.cpp",
    "problem_title": " Account Merge",
    "question": "Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\n\nApproach:\n1. We use a disjoint-set data structure to group accounts that belong to the same person based on their common emails.\n2. Create a disjoint-set and an unordered map to store email to account index mapping.\n3. Iterate through the list of accounts, for each account, iterate through its emails, and add them to the unordered map with the corresponding account index as the value.\n4. Iterate through the unordered map and union accounts that share common emails using the disjoint-set.\n5. Create a set for each group of accounts and add the emails of each account to the corresponding set.\n6. Iterate through the disjoint-set and create the final merged accounts list by grouping emails for each account based on their root in the disjoint-set.\n\nComplexity Analysis:\n- Let n be the number of accounts and m be the average number of emails per account.\n- The time complexity of this approach is O(n*m*\u03b1(n)), where \u03b1(n) is the inverse Ackermann function, which grows very slowly and is nearly constant.\n- The space complexity is O(n*m) to store the emails and their corresponding account indices in the unordered map, and O(n*m) to store the merged accounts in the final result.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/5. MST Problems/01. Prim's Algorithm.cpp",
    "section": "13. Graphs",
    "subsection": "5. MST Problems",
    "file_name": "01. Prim's Algorithm.cpp",
    "problem_title": " Prim'S Algorithm",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/5. MST Problems/06. Number of islands 2.cpp",
    "section": "13. Graphs",
    "subsection": "5. MST Problems",
    "file_name": "06. Number of islands 2.cpp",
    "problem_title": " Number Of Islands 2",
    "question": "You are given an n x m 2D matrix, and an array of size k denoting the number of operations. The matrix elements are 0 if there is water or 1 if there is land. Originally, the 2D matrix is all 0, which means there is no land in the matrix. The array has k operator(s) and each operator has two integers A[i][0], A[i][1], which means that you can change the cell matrix[A[i][0]][A[i][1]] from sea to an island. Return how many islands are there in the matrix after each operation. You need to return an array of size k.\nNote: An island means a group of 1s such that they share a common side.\n\nExample 1:\nInput: n = 4, m = 5, k = 4, A = {{1,1},{0,1},{3,3},{3,4}}\nOutput: 1 1 2 2\nExplanation:\n0.  00000\n    00000\n    00000\n    00000\n1.  00000\n    01000\n    00000\n    00000\n2.  01000\n    01000\n    00000\n    00000\n3.  01000\n    01000\n    00000\n    00010\n4.  01000\n    01000\n    00000\n    00011",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/5. MST Problems/08. Swim in rising water.cpp",
    "section": "13. Graphs",
    "subsection": "5. MST Problems",
    "file_name": "08. Swim in rising water.cpp",
    "problem_title": " Swim In Rising Water",
    "question": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\nThe rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\nReturn the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\n\nApproach:\n1. We use a priority queue (min heap) to keep track of the cells in increasing order of their elevations.\n2. Start from the top left cell (0, 0) and add it to the priority queue with its elevation as the key.\n3. Mark this cell as visited.\n4. While the priority queue is not empty, pop the cell with the minimum elevation.\n5. Update the answer with the maximum of the current elevation and the answer so far.\n6. Check the 4-directionally adjacent cells of the current cell.\n7. If the adjacent cell is within the boundaries and not visited, add it to the priority queue with its elevation as the key.\n8. Mark the adjacent cell as visited.\n9. Continue the process until we reach the bottom right cell (n-1, n-1).\n10. The answer at this point will be the least time until we can reach the bottom right cell.\n\nComplexity Analysis:\n- We need to visit all cells of the grid, so the time complexity of the solution is O(n^2).\n- We use a priority queue to store at most n^2 cells, so the space complexity is also O(n^2).\n\nCODE:-",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/5. MST Problems/03. Number of Operations to make Network.cpp",
    "section": "13. Graphs",
    "subsection": "5. MST Problems",
    "file_name": "03. Number of Operations to make Network.cpp",
    "problem_title": " Number Of Operations To Make Network",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/5. MST Problems/02. Kruskal's Algorithm.cpp",
    "section": "13. Graphs",
    "subsection": "5. MST Problems",
    "file_name": "02. Kruskal's Algorithm.cpp",
    "problem_title": " Kruskal'S Algorithm",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/5. MST Problems/04. Most stones removed.cpp",
    "section": "13. Graphs",
    "subsection": "5. MST Problems",
    "file_name": "04. Most stones removed.cpp",
    "problem_title": " Most Stones Removed",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/10. Find city with smallest number of neighbours.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "10. Find city with smallest number of neighbours.cpp",
    "problem_title": " Find City With Smallest Number Of Neighbours",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/11. Number of ways to arrive the destination with minimum distance.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "11. Number of ways to arrive the destination with minimum distance.cpp",
    "problem_title": " Number Of Ways To Arrive The Destination With Minimum Distance",
    "question": "You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection, and that there is at most one road between any two intersections.\n\nYou are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time.\n\nReturn the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 10^9 + 7.\n\nApproach:\n1. We can use Dijkstra's algorithm to find the shortest path from intersection 0 to intersection n-1 and also keep track of the number of ways to reach each intersection in the shortest time.\n2. We start with intersection 0 and keep track of the minimum time required to reach each intersection.\n3. During the process, we also keep track of the number of ways to reach each intersection in the shortest time.\n4. If we find a shorter path to a particular intersection, we update its minimum time and reset the number of ways to reach that intersection to the number of ways to reach the previous intersection.\n5. If we find an equal time path to a particular intersection, we add the number of ways to reach the previous intersection to the number of ways to reach the current intersection.\n\nComplexity Analysis:\n- Let n be the number of intersections and E be the number of roads in the input.\n- Dijkstra's algorithm has a time complexity of O((n+E)log(n)) using a priority queue.\n- The space complexity is O(n) to store the distance and ways arrays.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/06. Cheapest Flights with K stops.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "06. Cheapest Flights with K stops.cpp",
    "problem_title": " Cheapest Flights With K Stops",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/08. Bellman Ford Algorithm.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "08. Bellman Ford Algorithm.cpp",
    "problem_title": " Bellman Ford Algorithm",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/07. Network Delay Time.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "07. Network Delay Time.cpp",
    "problem_title": " Network Delay Time",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/01. Shortest path in Undirected Graph having unit distance.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "01. Shortest path in Undirected Graph having unit distance.cpp",
    "problem_title": " Shortest Path In Undirected Graph Having Unit Distance",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/05. Path with minimum effort.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "05. Path with minimum effort.cpp",
    "problem_title": " Path With Minimum Effort",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/02. Shortest path in DAG.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "02. Shortest path in DAG.cpp",
    "problem_title": " Shortest Path In Dag",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/09. Floyd Warshall Algorithm.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "09. Floyd Warshall Algorithm.cpp",
    "problem_title": " Floyd Warshall Algorithm",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/04. Shortest Path in binary matrix.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "04. Shortest Path in binary matrix.cpp",
    "problem_title": " Shortest Path In Binary Matrix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/13. Graphs/4. Shortest Path Problems/03. Dijkstra's Algorithm.cpp",
    "section": "13. Graphs",
    "subsection": "4. Shortest Path Problems",
    "file_name": "03. Dijkstra's Algorithm.cpp",
    "problem_title": " Dijkstra'S Algorithm",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/2D Arrays/3.Search_in_rowwise_sorted_matrix.cpp",
    "section": "02.Binary Search",
    "subsection": "2D Arrays",
    "file_name": "3.Search_in_rowwise_sorted_matrix.cpp",
    "problem_title": "Search In Rowwise Sorted Matrix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/2D Arrays/5.Matrix_median.cpp",
    "section": "02.Binary Search",
    "subsection": "2D Arrays",
    "file_name": "5.Matrix_median.cpp",
    "problem_title": "Matrix Median",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/2D Arrays/2.Search_in_sorted_matrix.cpp",
    "section": "02.Binary Search",
    "subsection": "2D Arrays",
    "file_name": "2.Search_in_sorted_matrix.cpp",
    "problem_title": "Search In Sorted Matrix",
    "question": "You are given an m x n integer matrix matrix with the following two properties:\n\nEach row is sorted in non-decreasing order.\nThe first integer of each row is greater than the last integer of the previous row.\nGiven an integer target, return true if target is in matrix or false otherwise.\n\nYou must write a solution in O(log(m * n)) time complexity.\n\n\n\nExample 1:\nInput:  matrix = [[1,3,5,7]\n                [10,11,16,20]\n                [23,30,34,60]]\n        target = 3\nOutput: true",
    "approach": "-> Since the array is sorted we can use binary search low = 0 and high = n*m-1 i.e. total number of elements\n-> Value at mid position could be accessed by matrix[mid/m][mid%m]\n-> Then, follow the traditional binary search",
    "time_complexity": "O(log(M * N))",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/2D Arrays/1.Row_with_maximum_number_of_1's.cpp",
    "section": "02.Binary Search",
    "subsection": "2D Arrays",
    "file_name": "1.Row_with_maximum_number_of_1's.cpp",
    "problem_title": "Row With Maximum Number Of 1'S",
    "question": "Given a boolean 2D array of n x m dimensions where each row is sorted. Find the 0-based index of the first row that has the maximum number of 1's.\n\nExample 1:\n\nInput:\nN = 4 , M = 4\nArr[][] = {{0, 1, 1, 1},\n           {0, 0, 1, 1},\n           {1, 1, 1, 1},\n           {0, 0, 0, 0}}\nOutput: 2\nExplanation: Row 2 contains 4 1's (0-based indexing).",
    "approach": "-> We can use two pointer i and j which indicates current row and col\n-> As we know the matrix is row-wise sorted we can intilaize j=m-1 i.e. last col and i=0 i.e. first row\n-> Now, the idea is we will keep moving left j while we occur 1 and if 0 is found we will check in next row\n-> The last row where we encountered 1 will be our ans\n\n                {*0, *1, *1, *1}\n                {*0,  0,  1,  1}\nout of matrix  *{*1,  1,  1,  1} ---> ans\n                {0,  0,  0,  0}",
    "time_complexity": "O(N+M)",
    "space_complexity": "O(0)"
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/2D Arrays/4.Peak_element_in_matrix.cpp",
    "section": "02.Binary Search",
    "subsection": "2D Arrays",
    "file_name": "4.Peak_element_in_matrix.cpp",
    "problem_title": "Peak Element In Matrix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/08.Find_peak_element.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "08.Find_peak_element.cpp",
    "problem_title": "Find Peak Element",
    "question": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\n\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in O(log n) time.\n\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\n\nExample 2:\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.",
    "approach": "We can use the binary search approach to find the peak element.\n1. Initialize low = 0 and high = n-1, where n is the size of the array.\n2. While low < high, calculate mid = low + (high - low) / 2.\n3. If nums[mid] < nums[mid+1], it means a peak element exists on the right side of mid, so update low = mid+1.\n4. Otherwise, a peak element exists on the left side of mid or mid itself is a peak, so update high = mid.\n5. After the loop ends, low will be pointing to the peak element index.\n6. Return low as the result.\n\nCODE:-",
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/02.Implement_lower_bound.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "02.Implement_lower_bound.cpp",
    "problem_title": "Implement Lower Bound",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/07.Number_of_occurences.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "07.Number_of_occurences.cpp",
    "problem_title": "Number Of Occurences",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/11.Find_the_minimum_element_in_sorted_rotated_array.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "11.Find_the_minimum_element_in_sorted_rotated_array.cpp",
    "problem_title": "Find The Minimum Element In Sorted Rotated Array",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/05.Check_If_array_is_sorted.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "05.Check_If_array_is_sorted.cpp",
    "problem_title": "Check If Array Is Sorted",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/12.Find_single_element_in_sorted_array.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "12.Find_single_element_in_sorted_array.cpp",
    "problem_title": "Find Single Element In Sorted Array",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/13.Find_how_many_times_array_is_rotated.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "13.Find_how_many_times_array_is_rotated.cpp",
    "problem_title": "Find How Many Times Array Is Rotated",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/06.First_and_last_position.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "06.First_and_last_position.cpp",
    "problem_title": "First And Last Position",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/01.Find_x_in_sorted_array.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "01.Find_x_in_sorted_array.cpp",
    "problem_title": "Find X In Sorted Array",
    "question": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nExample 1:\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: The target value 9 exists in the nums array, and its index is 4.\n\nExample 2:\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: The target value 2 does not exist in the nums array, so return -1.",
    "approach": "1. Initialize low as 0 and high as the last index of the array.\n2. Iterate using a while loop until low is less than or equal to high.\n3. Calculate the middle index using the formula mid = low + (high - low) / 2.\n4. Compare the target value with the element at the middle index:\n   - If they are equal, return the middle index.\n   - If the target is less than the element, update high to mid - 1 and continue the search in the left half.\n   - If the target is greater than the element, update low to mid + 1 and continue the search in the right half.\n5. If the target is not found, return -1.",
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/04.Search_insert_position.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "04.Search_insert_position.cpp",
    "problem_title": "Search Insert Position",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/03.Implement_lower_upper_bound.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "03.Implement_lower_upper_bound.cpp",
    "problem_title": "Implement Lower Upper Bound",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/10.Search_in_rotated_sorted_array_with_duplicates.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "10.Search_in_rotated_sorted_array_with_duplicates.cpp",
    "problem_title": "Search In Rotated Sorted Array With Duplicates",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/1D Arrays/09.Search_in_rotated_sorted_array.cpp",
    "section": "02.Binary Search",
    "subsection": "1D Arrays",
    "file_name": "09.Search_in_rotated_sorted_array.cpp",
    "problem_title": "Search In Rotated Sorted Array",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/05.Find_smallest_integer.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "05.Find_smallest_integer.cpp",
    "problem_title": "Find Smallest Integer",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/01.Square_root_of_number.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "01.Square_root_of_number.cpp",
    "problem_title": "Square Root Of Number",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/09.Book_allocation.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "09.Book_allocation.cpp",
    "problem_title": "Book Allocation",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/10.Split_array_largest.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "10.Split_array_largest.cpp",
    "problem_title": "Split Array Largest",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/02.Nth_root_of_integer.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "02.Nth_root_of_integer.cpp",
    "problem_title": "Nth Root Of Integer",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/11.Kth_missing_number.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "11.Kth_missing_number.cpp",
    "problem_title": "Kth Missing Number",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/03.Koko_eating_banana.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "03.Koko_eating_banana.cpp",
    "problem_title": "Koko Eating Banana",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/13.Median_of_two_sorted_arrays.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "13.Median_of_two_sorted_arrays.cpp",
    "problem_title": "Median Of Two Sorted Arrays",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/06.Capacity_to_ship_packages.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "06.Capacity_to_ship_packages.cpp",
    "problem_title": "Capacity To Ship Packages",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/04.Minimum_days_to_make_boquets.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "04.Minimum_days_to_make_boquets.cpp",
    "problem_title": "Minimum Days To Make Boquets",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/08.Aggresive_cows.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "08.Aggresive_cows.cpp",
    "problem_title": "Aggresive Cows",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/14.Kth_element_of_two_sorted_arrays.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "14.Kth_element_of_two_sorted_arrays.cpp",
    "problem_title": "Kth Element Of Two Sorted Arrays",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/02.Binary Search/In Search Space/12.Gas_station.cpp",
    "section": "02.Binary Search",
    "subsection": "In Search Space",
    "file_name": "12.Gas_station.cpp",
    "problem_title": "Gas Station",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/2.Medium/05.Count_the_number_of_substrings_with_k_unique_characters.cpp",
    "section": "03.Strings",
    "subsection": "2.Medium",
    "file_name": "05.Count_the_number_of_substrings_with_k_unique_characters.cpp",
    "problem_title": "Count The Number Of Substrings With K Unique Characters",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/2.Medium/03.Roman_to_Integer.cpp",
    "section": "03.Strings",
    "subsection": "2.Medium",
    "file_name": "03.Roman_to_Integer.cpp",
    "problem_title": "Roman To Integer",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/2.Medium/06.Longest_palindromic_substring.cpp",
    "section": "03.Strings",
    "subsection": "2.Medium",
    "file_name": "06.Longest_palindromic_substring.cpp",
    "problem_title": "Longest Palindromic Substring",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/2.Medium/01.Sort_characters_by_frequency.cpp",
    "section": "03.Strings",
    "subsection": "2.Medium",
    "file_name": "01.Sort_characters_by_frequency.cpp",
    "problem_title": "Sort Characters By Frequency",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/2.Medium/07.Sum_of_beauty_of_all_substrings.cpp",
    "section": "03.Strings",
    "subsection": "2.Medium",
    "file_name": "07.Sum_of_beauty_of_all_substrings.cpp",
    "problem_title": "Sum Of Beauty Of All Substrings",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/2.Medium/02.Max_nesting_depth_of_parenthesis.cpp",
    "section": "03.Strings",
    "subsection": "2.Medium",
    "file_name": "02.Max_nesting_depth_of_parenthesis.cpp",
    "problem_title": "Max Nesting Depth Of Parenthesis",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/2.Medium/04.Implement_atoi.cpp",
    "section": "03.Strings",
    "subsection": "2.Medium",
    "file_name": "04.Implement_atoi.cpp",
    "problem_title": "Implement Atoi",
    "question": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n\nThe algorithm for myAtoi(string s) is as follows:\n\nRead in and ignore any leading whitespace.\nCheck if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\nRead in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\nConvert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\nIf the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\nReturn the integer as the final result.\nNote:\n\nOnly the space character ' ' is considered a whitespace character.\nDo not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n \n\nExample 1:\n\nInput: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-231, 231 - 1], the final result is 42.\nExample 2:\n\nInput: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-231, 231 - 1], the final result is -42.\n\nApproach:\n1. Initialize an index `i` to track the current position in the string.\n2. Skip any leading whitespace by incrementing `i` until a non-whitespace character is encountered.\n3. Check if the next character (if not at the end of the string) is `'-'` or `'+'`. Set a `sign` flag accordingly to determine the final result's sign.\n4. Read the consecutive digits until a non-digit character is encountered or the end of the input is reached. Convert these digits into an integer.\n5. Apply the sign to the integer obtained from the digits.\n6. If the integer is out of the 32-bit signed integer range, clamp it to the range [-231, 231 - 1].\n7. Return the final integer.\n\nCode:",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/1.Easy/03.Largest_odd_number_in_string.cpp",
    "section": "03.Strings",
    "subsection": "1.Easy",
    "file_name": "03.Largest_odd_number_in_string.cpp",
    "problem_title": "Largest Odd Number In String",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/1.Easy/06.Check_for_rotated_string.cpp",
    "section": "03.Strings",
    "subsection": "1.Easy",
    "file_name": "06.Check_for_rotated_string.cpp",
    "problem_title": "Check For Rotated String",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/1.Easy/04.Longest_common_prefix.cpp",
    "section": "03.Strings",
    "subsection": "1.Easy",
    "file_name": "04.Longest_common_prefix.cpp",
    "problem_title": "Longest Common Prefix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/1.Easy/01.Remove_outer_parenthesis.cpp",
    "section": "03.Strings",
    "subsection": "1.Easy",
    "file_name": "01.Remove_outer_parenthesis.cpp",
    "problem_title": "Remove Outer Parenthesis",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/1.Easy/05.Isomorphic_string.cpp",
    "section": "03.Strings",
    "subsection": "1.Easy",
    "file_name": "05.Isomorphic_string.cpp",
    "problem_title": "Isomorphic String",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/1.Easy/02.Reverse_words_in_string.cpp",
    "section": "03.Strings",
    "subsection": "1.Easy",
    "file_name": "02.Reverse_words_in_string.cpp",
    "problem_title": "Reverse Words In String",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/03.Strings/1.Easy/07.Valid_anagram.cpp",
    "section": "03.Strings",
    "subsection": "1.Easy",
    "file_name": "07.Valid_anagram.cpp",
    "problem_title": "Valid Anagram",
    "question": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nExample 1:\n\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\nExample 2:\n\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nProblem: Valid Anagram\n\nApproach:\n1. Create an unordered map to store the count of each character in string `s`.\n2. Iterate over each character in `s` and increment its count in the map.\n3. Iterate over each character in `t`.\n   - If the character is not present in the map or its count is zero, return false.\n   - Decrement the count of the character in the map.\n   - If the count becomes zero, remove the character from the map.\n4. After iterating through all characters in `t`, if the map is empty, return true; otherwise, return false.\n\nCode:",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/1. Single Linked List/02.Inserting_node_to_linked_list.cpp",
    "section": "04.Linked List",
    "subsection": "1. Single Linked List",
    "file_name": "02.Inserting_node_to_linked_list.cpp",
    "problem_title": "Inserting Node To Linked List",
    "question": "Create a link list of size N according to the given input literals. Each integer input is accompanied by an indicator which can either be 0 or 1. If it is 0, insert the integer in the beginning of the link list. If it is 1, insert the integer at the end of the link list. \nHint: When inserting at the end, make sure that you handle NULL explicitly.\n\nExample 1:\n\nInput:\nLinkedList: 9->0->5->1->6->1->2->0->5->0\nOutput: 5 2 9 5 6\nExplanation:\nLength of Link List = N = 5\n9 0 indicated that 9 should be\ninserted in the beginning. Modified\nLink List = 9.\n5 1 indicated that 5 should be\ninserted in the end. Modified Link\nList = 9,5.\n6 1 indicated that 6 should be\ninserted in the end. Modified Link\nList = 9,5,6.\n2 0 indicated that 2 should be\ninserted in the beginning. Modified\nLink List = 2,9,5,6.\n5 0 indicated that 5 should be\ninserted in the beginning. Modified\nLink List = 5,2,9,5,6. \nFinal linked list = 5, 2, 9, 5, 6.\n\nExample 2:\n\nInput:\nLinkedList: 5->1->6->1->9->1\nOutput: 5 6 9\n\nThe approach to solving this problem is as follows:\n\n1. Initialize an empty linked list by setting the `head` pointer to `NULL`.\n2. Iterate through the given input literals.\n3. If the indicator is 0, insert the integer at the beginning of the linked list by calling the `insertAtBeginning` function. This function creates a new node with the given integer value and inserts it at the beginning of the linked list.\n4. If the indicator is 1, insert the integer at the end of the linked list by calling the `insertAtEnd` function. This function creates a new node with the given integer value and inserts it at the end of the linked list.\n5. After iterating through all the input literals, the resulting linked list will be the desired output.\n\nTime complexity of this approach is O(N), where N is the number of input literals, as we need to iterate through all the literals to construct the linked list.\nSpace complexity is O(1) as we are not using any extra space that grows with the input size. We only need a constant amount of space to store the pointers and temporary variables.\n\nCODE:-",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/1. Single Linked List/03.Deleting_node_in_linked_list.cpp",
    "section": "04.Linked List",
    "subsection": "1. Single Linked List",
    "file_name": "03.Deleting_node_in_linked_list.cpp",
    "problem_title": "Deleting Node In Linked List",
    "question": "Given a singly linked list and an integer x.Delete xth node from the singly linked list.\n\nExample 1:\n\nInput: 1 -> 3 -> 4 \n       x = 3\nOutput: 1 -> 3\nExplanation:\nAfter deleting the node at 3rd\nposition (1-base indexing), the\nlinked list is as 1 -> 3. \nExample 2:\n\nInput: 1 -> 5 -> 2 -> 9 \nx = 2\nOutput: 1 -> 2 -> 9\nExplanation: \nAfter deleting the node at 2nd\nposition (1-based indexing), the\nlinked list is as 1 -> 2 -> 9.\n\nAPPROACH:- \n1. If the given position is 1, it means the node to be deleted is the first node. In this case, we simply update the head pointer to the next node and return the new head.\n2. Initialize a counter `cnt` to 1 and a pointer `curr` to the head of the linked list.\n3. Traverse the linked list by moving the `curr` pointer to the next node until the counter `cnt` reaches the position just before the node to be deleted.\n4. Once we reach the position just before the node to be deleted, we update the `next` pointer of the current node to skip the next node and point to the node after it.\n5. Return the head pointer of the modified linked list.\n\n\n\nTime complexity of this approach is O(N), where N is the number of nodes in the linked list. We may need to traverse the linked list until we reach the desired position.\nSpace complexity is O(1) as we are not using any extra space that grows with the input size. We only need a constant amount of space to store the counter variable and the temporary pointer.\n\nCODE:-",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/1. Single Linked List/01.Intro_to_linked_list.cpp",
    "section": "04.Linked List",
    "subsection": "1. Single Linked List",
    "file_name": "01.Intro_to_linked_list.cpp",
    "problem_title": "Intro To Linked List",
    "question": "Construct the linked list from arr and return the head of the linked list.\n\nExample 1:\n\nInput:\nn = 5\narr = [1,2,3,4,5]\nOutput:\n1 2 3 4 5\nExplanation: Linked list for the given array will be 1->2->3->4->5.\nExample 2:\n\nInput:\nn = 2\narr = [2,4]\nOutput:\n2 4\nExplanation: Linked list for the given array will be 2->4.\n\nAPPROACH:- \nThe approach to construct a linked list from an array is as follows:\n\n1. Create the head node of the linked list using the first element of the array.\n2. Initialize a current pointer to the head node.\n3. Traverse the array starting from the second element.\n4. For each element in the array, create a new node and assign the element as its data.\n5. Set the `next` pointer of the current node to the newly created node.\n6. Update the current pointer to the newly created node.\n7. Repeat steps 4-6 until all elements in the array are processed.\n8. Return the head node of the constructed linked list.\n\nCODE:-",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/1. Single Linked List/05.Search_element_in_linked_list.cpp",
    "section": "04.Linked List",
    "subsection": "1. Single Linked List",
    "file_name": "05.Search_element_in_linked_list.cpp",
    "problem_title": "Search Element In Linked List",
    "question": "Given a linked list of n nodes and a key , the task is to check if the key is present in the linked list or not.\n\nExample:\n\nInput:\nn = 4\n1->2->3->4\nKey = 3\nOutput:\nTrue\nExplanation:\n3 is present in Linked List, so the function returns true.\n\nAPPROCACH:-\nJust traverse the entire Linked List and if node's data matches with the target return true else return false.\n\nTIME COMPLEXITY:- O(N)\nSPACE COMPLEXITY:- O(1)\n\nCODE:-",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/1. Single Linked List/04.Count_the_number_of_nodes_linked_list.cpp",
    "section": "04.Linked List",
    "subsection": "1. Single Linked List",
    "file_name": "04.Count_the_number_of_nodes_linked_list.cpp",
    "problem_title": "Count The Number Of Nodes Linked List",
    "question": "Given a singly linked list. The task is to find the length of the linked list, where length is defined as the number of nodes in the linked list.\n\nExample 1:\n\nInput:\nLinkedList: 1->2->3->4->5\nOutput: 5\nExplanation: Count of nodes in the \nlinked list is 5, which is its length.\nExample 2:\n\nInput:\nLinkedList: 2->4->6->7->5->1->0\nOutput: 7\nExplanation: Count of nodes in the\nlinked list is 7. Hence, the output\nis 7.\n\nAPPROACH:-\n\n1. Initialize a variable `cnt` to 0 to keep track of the count.\n2. Start with the `curr` pointer pointing to the head of the linked list.\n3. Iterate through the linked list by moving the `curr` pointer to the next node in each iteration.\n4. Increment the count `cnt` by 1 for each node encountered.\n5. Continue the iteration until the `curr` pointer becomes NULL, indicating the end of the linked list.\n6. Return the final count `cnt` as the result.\n\nTime complexity of this approach is O(N), where N is the number of nodes in the linked list. We need to visit each node once to count them.\nSpace complexity is O(1) as we are not using any extra space that grows with the input size. We only need a constant amount of space to store the count variable and the temporary pointer.\n\nCODE:-",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/4.Medium Problems of DLL/03.Remove_duplicates_from_dll.cpp",
    "section": "04.Linked List",
    "subsection": "4.Medium Problems of DLL",
    "file_name": "03.Remove_duplicates_from_dll.cpp",
    "problem_title": "Remove Duplicates From Dll",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/4.Medium Problems of DLL/01.Delete_nodes_from_dll.cpp",
    "section": "04.Linked List",
    "subsection": "4.Medium Problems of DLL",
    "file_name": "01.Delete_nodes_from_dll.cpp",
    "problem_title": "Delete Nodes From Dll",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/4.Medium Problems of DLL/02.Pair_sum_in_dll.cpp",
    "section": "04.Linked List",
    "subsection": "4.Medium Problems of DLL",
    "file_name": "02.Pair_sum_in_dll.cpp",
    "problem_title": "Pair Sum In Dll",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/5.Hard Promblems of LL/01.Reverse_k_node_in_groups.cpp",
    "section": "04.Linked List",
    "subsection": "5.Hard Promblems of LL",
    "file_name": "01.Reverse_k_node_in_groups.cpp",
    "problem_title": "Reverse K Node In Groups",
    "question": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n\nAPPROACH:\nThe idea is to reverse the nodes of the linked list in groups of size k.\nFirst, we need to check if there are at least k nodes remaining in the linked list. If not, we return the head as it is.\nNext, we reverse the first k nodes of the linked list. To do this, we maintain three pointers: prev, curr, and frwd.\nWe iterate through the first k nodes and at each step, we reverse the links between the nodes.\nAfter reversing the first k nodes, prev becomes the new head, and curr becomes the new tail of the reversed group.\nWe recursively call the function on the remaining linked list starting from frwd (which points to the (k+1)-th node).\nFinally, we update the next pointer of the original head to point to the reversed group obtained from the recursive call.\n\nTIME COMPLEXITY: O(N), where N is the number of nodes in the linked list.\nSPACE COMPLEXITY: O(1).",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/5.Hard Promblems of LL/02.Rotate_LL_k_times.cpp",
    "section": "04.Linked List",
    "subsection": "5.Hard Promblems of LL",
    "file_name": "02.Rotate_LL_k_times.cpp",
    "problem_title": "Rotate Ll K Times",
    "question": "Given the head of a linked list, rotate the list to the right by k places.\n\nAPPROACH:\nTo rotate the linked list to the right by k places, we need to perform the following steps:\n1. Find the length of the linked list and connect the last node to the head to form a circular linked list.\n2. Calculate the actual number of rotations by taking the modulus of k with the length of the linked list.\n3. Traverse to the (length - k - 1)th node, which will be the new tail of the rotated list.\n4. Set the new head as the next node of the (length - k - 1)th node and disconnect it from the rest of the list.\n5. Return the new head.\n\nTIME COMPLEXITY: O(N), where N is the number of nodes in the linked list.\nSPACE COMPLEXITY: O(1).",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/5.Hard Promblems of LL/03.Copy_LL_with_random_pointers.cpp",
    "section": "04.Linked List",
    "subsection": "5.Hard Promblems of LL",
    "file_name": "03.Copy_LL_with_random_pointers.cpp",
    "problem_title": "Copy Ll With Random Pointers",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/5.Hard Promblems of LL/04.Flatten_LL.cpp",
    "section": "04.Linked List",
    "subsection": "5.Hard Promblems of LL",
    "file_name": "04.Flatten_LL.cpp",
    "problem_title": "Flatten Ll",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/04.Start_of_cycle_in_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "04.Start_of_cycle_in_LL.cpp",
    "problem_title": "Start Of Cycle In Ll",
    "question": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\n\nDo not modify the linked list.\n\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/11.Sort_0_1_2_in_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "11.Sort_0_1_2_in_LL.cpp",
    "problem_title": "Sort 0 1 2 In Ll",
    "question": "Given a linked list of N nodes where nodes can contain values 0s, 1s, and 2s only. \nThe task is to segregate 0s, 1s, and 2s in the linked list such that all zeros segregate to the head side, 2s at the end of the linked list, and 1s in the middle of 0s and 2s.\n\nExample:\nInput:\nN = 8\nvalue[] = {1,2,2,1,2,0,2,2}\nOutput: 0 1 1 2 2 2 2 2\nExplanation: All the 0s are segregated to the left end of the linked list, 2s to the right end of the list, and 1s in between.\n\nAPPROACH:\nCount the number of 0s, 1s, and 2s in the linked list.\nTraverse the linked list and overwrite the nodes with 0s, 1s, and 2s based on their counts.\n\nTIME COMPLEXITY: O(N)\nSPACE COMPLEXITY: O(1)",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/06.Check_for_palindrome_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "06.Check_for_palindrome_LL.cpp",
    "problem_title": "Check For Palindrome Ll",
    "question": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.\n\nExample 1:\nInput: head = [1,2,2,1]\nOutput: true\n\nExample 2:\nInput: head = [1,2]\nOutput: false",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/09.Delete_mid_of_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "09.Delete_mid_of_LL.cpp",
    "problem_title": "Delete Mid Of Ll",
    "question": "You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\n\nExample:\nInput: head = [1,3,4,7,1,2,6]\nOutput: [1,3,4,1,2,6]\nExplanation:\nThe above figure represents the given linked list. The indices of the nodes are written below.\nSince n = 7, node 3 with value 7 is the middle node, which is marked in red.\nWe return the new list after removing this node.\n\nAPPROACH:\nTo delete the middle node of a linked list, we can use the slow and fast pointer technique.\n1. Initialize three pointers: slow, fast, and prev.\n2. Move the slow pointer one step at a time and the fast pointer two steps at a time.\n3. Keep track of the previous node using the prev pointer.\n4. When the fast pointer reaches the end of the linked list, the slow pointer will be at the middle node.\n5. Update the next pointer of the previous node to skip the middle node.\n6. Return the head of the modified linked list.\n\nTIME COMPLEXITY: O(N)\nSPACE COMPLEXITY: O(1)",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/07.Odd_even_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "07.Odd_even_LL.cpp",
    "problem_title": "Odd Even Ll",
    "question": "Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\n\nExample 1:\nInput: head = [1,2,3,4,5]\nOutput: [1,3,5,2,4]\n\nExample 2:\nInput: head = [2,1,3,5,6,4,7]\nOutput: [2,3,6,7,1,5,4]",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/12.Add_1_to_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "12.Add_1_to_LL.cpp",
    "problem_title": "Add 1 To Ll",
    "question": "A number N is represented in a linked list such that each digit corresponds to a node in the linked list. \nYou need to add 1 to the number represented by the linked list.\n\nAPPROACH:\nTo add 1 to the number represented by the linked list, we can reverse the linked list, perform the addition, and then reverse it back.\nFirst, reverse the linked list.\nTraverse the reversed linked list while keeping track of the carry.\nAdd 1 to the least significant digit (head) and update the carry if necessary.\nContinue traversing the linked list, adding the carry to each digit and updating the carry.\nIf there is still a remaining carry after traversing the linked list, create a new node with the carry as its value and append it to the end of the linked list.\nReverse the linked list again to restore its original order.\n\nTIME COMPLEXITY: O(N), where N is the length of the linked list.\nSPACE COMPLEXITY: O(1)",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/13.Add_two_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "13.Add_two_LL.cpp",
    "problem_title": "Add Two Ll",
    "question": "You are given two non-empty linked lists representing two non-negative integers. \nThe digits are stored in reverse order, and each of their nodes contains a single digit. \nAdd the two numbers and return the sum as a linked list.\n\nAPPROACH:\nTraverse both linked lists simultaneously, starting from the heads.\nAt each step, add the corresponding digits from both linked lists along with the carry (initialized as 0).\nCreate a new node with the sum%10 and update the carry as sum/10.\nMove to the next nodes in both linked lists.\nContinue this process until both linked lists are traversed completely and there is no carry left.\nIf one linked list is shorter than the other, consider its remaining digits as 0.\nIf there is still a remaining carry, create a new node with the carry and append it to the result linked list.\nReturn the head of the result linked list.\n\nTIME COMPLEXITY: O(max(N, M)), where N and M are the lengths of the two input linked lists.\nSPACE COMPLEXITY: O(max(N, M)), as the length of the result linked list can be at most max(N, M)+1.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/08.Delete_nth_node_from_back.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "08.Delete_nth_node_from_back.cpp",
    "problem_title": "Delete Nth Node From Back",
    "question": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\nExample 1:\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\nInput: head = [1,2], n = 1\nOutput: [1]",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/01.Find_mid_of_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "01.Find_mid_of_LL.cpp",
    "problem_title": "Find Mid Of Ll",
    "question": "Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.\n\nExample 1:\nInput: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.\n\nExample 2:\nInput: head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/02.Reverse_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "02.Reverse_LL.cpp",
    "problem_title": "Reverse Ll",
    "question": "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\nExample 1:\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n\nExample 2:\nInput: head = [1,2]\nOutput: [2,1]",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/05.Count_nodes_in_loop.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "05.Count_nodes_in_loop.cpp",
    "problem_title": "Count Nodes In Loop",
    "question": "Given a linked list of size N. The task is to complete the function countNodesinLoop() that checks whether a given Linked List contains a loop or not and if the loop is present then return the count of nodes in a loop or else return 0. C is the position of the node to which the last node is connected. If it is 0 then no loop.\n\nExample 1:\nInput: N = 10\nvalue[]={25,14,19,33,10,21,39,90,58,45}\nC = 4\nOutput: 7\nExplanation: The loop is 45->33. So\nlength of loop is 33->10->21->39->\n90->58->45 = 7. The number 33 is\nconnected to the last node to form the\nloop because according to the input the\n4th node from the beginning(1 based\nindex) will be connected to the last\nnode for the loop.\n\nExample 2:\nInput: N = 2\nvalue[] = {1,0}\nC = 1\nOutput: 2\nExplanation: The length of the loop\nis 2.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/03.Detect_loop_in_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "03.Detect_loop_in_LL.cpp",
    "problem_title": "Detect Loop In Ll",
    "question": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.\n\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/3.Medium Problems of LL/10.Sort_LL.cpp",
    "section": "04.Linked List",
    "subsection": "3.Medium Problems of LL",
    "file_name": "10.Sort_LL.cpp",
    "problem_title": "Sort Ll",
    "question": "Given the head of a linked list, return the list after sorting it in ascending order.\n\nExample:\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\nAPPROACH:\nTo sort a linked list, we can use the merge sort algorithm.\n1. Implement a function to merge two sorted linked lists.\n2. Implement a function to recursively divide the linked list into two halves.\n3. Apply merge sort on each half.\n4. Merge the sorted halves using the merge function.\n5. Return the head of the sorted linked list.\n\nTIME COMPLEXITY: O(NlogN)\nSPACE COMPLEXITY: O(logN) - Recursive stack space",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/2.Doubly Linked List/03.Delete_node_in_DLL.cpp",
    "section": "04.Linked List",
    "subsection": "2.Doubly Linked List",
    "file_name": "03.Delete_node_in_DLL.cpp",
    "problem_title": "Delete Node In Dll",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/2.Doubly Linked List/04.Reverse_DLL.cpp",
    "section": "04.Linked List",
    "subsection": "2.Doubly Linked List",
    "file_name": "04.Reverse_DLL.cpp",
    "problem_title": "Reverse Dll",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/2.Doubly Linked List/01.Introduction_to_Double_LL.cpp",
    "section": "04.Linked List",
    "subsection": "2.Doubly Linked List",
    "file_name": "01.Introduction_to_Double_LL.cpp",
    "problem_title": "Introduction To Double Ll",
    "question": "Given a doubly linked list of n elements. The task is to reverse the doubly linked list.\n\nExample 1:\n\nInput:\nLinkedList: 3 <--> 4 <--> 5\nOutput: 5 4 3\nExample 2:\n\nInput:\nLinkedList: 75 <--> 122 <--> 59 <--> 196\nOutput: 196 59 122 75\n\nAPPROACH:-\n1. Initialize two pointers `curr` and `nxt` to traverse the linked list. Set `curr` to the head of the linked list.\n2. In each iteration, store the next node in the `nxt` pointer to avoid losing the reference to the next node.\n3. Swap the `next` and `prev` pointers of the current node (`curr`).\n4. Check if the `prev` pointer of the current node (`curr->prev`) is `NULL`, which indicates that `curr` is the last node of the original linked list. If so, update the `ans` pointer to point to `curr` (the new head of the reversed linked list).\n5. Move the `curr` pointer to the previous node (`curr = curr->prev`) using the stored `nxt` pointer.\n6. Repeat steps 2-5 until `curr` becomes `NULL`, indicating that we have reached the end of the original linked list.\n7. Return the `ans` pointer, which now points to the head of the reversed linked list.\n\nTime complexity of this approach is O(N), where N is the number of nodes in the doubly linked list. We need to traverse the entire list once to reverse the links.\nSpace complexity is O(1) as we are using a constant amount of extra space to store temporary pointers during the reversal process.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/04.Linked List/2.Doubly Linked List/02.Insert_node_in_DLL.cpp",
    "section": "04.Linked List",
    "subsection": "2.Doubly Linked List",
    "file_name": "02.Insert_node_in_DLL.cpp",
    "problem_title": "Insert Node In Dll",
    "question": "Given a doubly-linked list, a position p, and an integer x. The task is to add a new node with value x at the position just after pth node in the doubly linked list.\n\nExample 1:\n\nInput:\nLinkedList: 2<->4<->5\np = 2, x = 6 \nOutput: 2 4 5 6\nExplanation: p = 2, and x = 6. So, 6 is\ninserted after p, i.e, at position 3\n(0-based indexing).\nExample 2:\n\nInput:\nLinkedList: 1<->2<->3<->4\np = 0, x = 44\nOutput: 1 44 2 3 4\nExplanation: p = 0, and x = 44 . So, 44\nis inserted after p, i.e, at position 1\n(0-based indexing).\n\nAPPROACH:-\nThe approach to adding a node at a specific position in a doubly linked list is as follows:\n\n1. Initialize a counter `cnt` to 0 and a pointer `curr` to the head of the linked list.\n2. Traverse the linked list using the `curr` pointer until the `cnt` is less than the specified position.\n3. Increment the `cnt` by 1 and move the `curr` pointer to the next node in each iteration.\n4. Once the `cnt` reaches the desired position, create a new node with the given data.\n5. Set the `next` pointer of the new node to the next node of the current node (`curr->next`) and the `prev` pointer of the new node to the current node (`curr`).\n6. Update the `next` pointer of the current node (`curr->next`) to point to the new node.\n7. If the new node is inserted in the middle of the list, update the `prev` pointer of the next node (`nxt`) to point to the new node.\n8. The new node is successfully inserted into the linked list.\n\nTime complexity of this approach is O(N), where N is the number of nodes in the doubly linked list. In the worst case, we may need to traverse the entire list to reach the desired position.\nSpace complexity is O(1) as we are using a constant amount of extra space to store temporary pointers during the insertion process.\n\nCODE:-",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/2. Hard Problems/02. Count the number of substrings with exactly K unique characters.cpp",
    "section": "08. Sliding Window",
    "subsection": "2. Hard Problems",
    "file_name": "02. Count the number of substrings with exactly K unique characters.cpp",
    "problem_title": " Count The Number Of Substrings With Exactly K Unique Characters",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/2. Hard Problems/03. Minimum Window Substring.cpp",
    "section": "08. Sliding Window",
    "subsection": "2. Hard Problems",
    "file_name": "03. Minimum Window Substring.cpp",
    "problem_title": " Minimum Window Substring",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/2. Hard Problems/01. Longest Substring with at most K unique characters.cpp",
    "section": "08. Sliding Window",
    "subsection": "2. Hard Problems",
    "file_name": "01. Longest Substring with at most K unique characters.cpp",
    "problem_title": " Longest Substring With At Most K Unique Characters",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/1. Medium Problems/07. Number of Substrings Containing all 3 characters.cpp",
    "section": "08. Sliding Window",
    "subsection": "1. Medium Problems",
    "file_name": "07. Number of Substrings Containing all 3 characters.cpp",
    "problem_title": " Number Of Substrings Containing All 3 Characters",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/1. Medium Problems/03. Fruit into Baskets.cpp",
    "section": "08. Sliding Window",
    "subsection": "1. Medium Problems",
    "file_name": "03. Fruit into Baskets.cpp",
    "problem_title": " Fruit Into Baskets",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/1. Medium Problems/04. Longest Repeating Character.cpp",
    "section": "08. Sliding Window",
    "subsection": "1. Medium Problems",
    "file_name": "04. Longest Repeating Character.cpp",
    "problem_title": " Longest Repeating Character",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/1. Medium Problems/08. Maximum Points you can obtaln form the card.cpp",
    "section": "08. Sliding Window",
    "subsection": "1. Medium Problems",
    "file_name": "08. Maximum Points you can obtaln form the card.cpp",
    "problem_title": " Maximum Points You Can Obtaln Form The Card",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/1. Medium Problems/02. Max Consecutive 1's.cpp",
    "section": "08. Sliding Window",
    "subsection": "1. Medium Problems",
    "file_name": "02. Max Consecutive 1's.cpp",
    "problem_title": " Max Consecutive 1'S",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/1. Medium Problems/06. Count the number of nice subarrays.cpp",
    "section": "08. Sliding Window",
    "subsection": "1. Medium Problems",
    "file_name": "06. Count the number of nice subarrays.cpp",
    "problem_title": " Count The Number Of Nice Subarrays",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/1. Medium Problems/05. Binary Subarrays with Sum.cpp",
    "section": "08. Sliding Window",
    "subsection": "1. Medium Problems",
    "file_name": "05. Binary Subarrays with Sum.cpp",
    "problem_title": " Binary Subarrays With Sum",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/08. Sliding Window/1. Medium Problems/01. Longest Substring Without Repeating Characters.cpp",
    "section": "08. Sliding Window",
    "subsection": "1. Medium Problems",
    "file_name": "01. Longest Substring Without Repeating Characters.cpp",
    "problem_title": " Longest Substring Without Repeating Characters",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/4. Implementation/02. Stock span problem.cpp",
    "section": "07.Stack and Queues",
    "subsection": "4. Implementation",
    "file_name": "02. Stock span problem.cpp",
    "problem_title": " Stock Span Problem",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/4. Implementation/03. Celebrity Problem.cpp",
    "section": "07.Stack and Queues",
    "subsection": "4. Implementation",
    "file_name": "03. Celebrity Problem.cpp",
    "problem_title": " Celebrity Problem",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/4. Implementation/01. Sliding window maximum.cpp",
    "section": "07.Stack and Queues",
    "subsection": "4. Implementation",
    "file_name": "01. Sliding window maximum.cpp",
    "problem_title": " Sliding Window Maximum",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/4. Implementation/04. LRU Cache.cpp",
    "section": "07.Stack and Queues",
    "subsection": "4. Implementation",
    "file_name": "04. LRU Cache.cpp",
    "problem_title": " Lru Cache",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/1. Learning/06. Valid Parenthesis.cpp",
    "section": "07.Stack and Queues",
    "subsection": "1. Learning",
    "file_name": "06. Valid Parenthesis.cpp",
    "problem_title": " Valid Parenthesis",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/1. Learning/07. Implement min stack.cpp",
    "section": "07.Stack and Queues",
    "subsection": "1. Learning",
    "file_name": "07. Implement min stack.cpp",
    "problem_title": " Implement Min Stack",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/1. Learning/04. Implement queue using stacks.cpp",
    "section": "07.Stack and Queues",
    "subsection": "1. Learning",
    "file_name": "04. Implement queue using stacks.cpp",
    "problem_title": " Implement Queue Using Stacks",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/1. Learning/03. Implement stack using queue.cpp",
    "section": "07.Stack and Queues",
    "subsection": "1. Learning",
    "file_name": "03. Implement stack using queue.cpp",
    "problem_title": " Implement Stack Using Queue",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/1. Learning/05. Implement stack using linked list.cpp",
    "section": "07.Stack and Queues",
    "subsection": "1. Learning",
    "file_name": "05. Implement stack using linked list.cpp",
    "problem_title": " Implement Stack Using Linked List",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/1. Learning/01. Implement stack using array.cpp",
    "section": "07.Stack and Queues",
    "subsection": "1. Learning",
    "file_name": "01. Implement stack using array.cpp",
    "problem_title": " Implement Stack Using Array",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/1. Learning/02. Implement queue using array.cpp",
    "section": "07.Stack and Queues",
    "subsection": "1. Learning",
    "file_name": "02. Implement queue using array.cpp",
    "problem_title": " Implement Queue Using Array",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/2. Infix, Postfix, and Prefix/04. Prefix to postfix.cpp",
    "section": "07.Stack and Queues",
    "subsection": "2. Infix, Postfix, and Prefix",
    "file_name": "04. Prefix to postfix.cpp",
    "problem_title": " Prefix To Postfix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/2. Infix, Postfix, and Prefix/05. Postfix to infix.cpp",
    "section": "07.Stack and Queues",
    "subsection": "2. Infix, Postfix, and Prefix",
    "file_name": "05. Postfix to infix.cpp",
    "problem_title": " Postfix To Infix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/2. Infix, Postfix, and Prefix/01. Infix to postfix.cpp",
    "section": "07.Stack and Queues",
    "subsection": "2. Infix, Postfix, and Prefix",
    "file_name": "01. Infix to postfix.cpp",
    "problem_title": " Infix To Postfix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/2. Infix, Postfix, and Prefix/06. Postfix to prefix.cpp",
    "section": "07.Stack and Queues",
    "subsection": "2. Infix, Postfix, and Prefix",
    "file_name": "06. Postfix to prefix.cpp",
    "problem_title": " Postfix To Prefix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/2. Infix, Postfix, and Prefix/03. Prefix to infix.cpp",
    "section": "07.Stack and Queues",
    "subsection": "2. Infix, Postfix, and Prefix",
    "file_name": "03. Prefix to infix.cpp",
    "problem_title": " Prefix To Infix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/2. Infix, Postfix, and Prefix/02. Infix to prefix.cpp",
    "section": "07.Stack and Queues",
    "subsection": "2. Infix, Postfix, and Prefix",
    "file_name": "02. Infix to prefix.cpp",
    "problem_title": " Infix To Prefix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/3. Monotonic Stack and Queue/06. Sum of range of all subarray.cpp",
    "section": "07.Stack and Queues",
    "subsection": "3. Monotonic Stack and Queue",
    "file_name": "06. Sum of range of all subarray.cpp",
    "problem_title": " Sum Of Range Of All Subarray",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/3. Monotonic Stack and Queue/04. Trapping Rainwater.cpp",
    "section": "07.Stack and Queues",
    "subsection": "3. Monotonic Stack and Queue",
    "file_name": "04. Trapping Rainwater.cpp",
    "problem_title": " Trapping Rainwater",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/3. Monotonic Stack and Queue/09. Maximal Rectangle in binary matrix.cpp",
    "section": "07.Stack and Queues",
    "subsection": "3. Monotonic Stack and Queue",
    "file_name": "09. Maximal Rectangle in binary matrix.cpp",
    "problem_title": " Maximal Rectangle In Binary Matrix",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/3. Monotonic Stack and Queue/10. Asteroids Collision.cpp",
    "section": "07.Stack and Queues",
    "subsection": "3. Monotonic Stack and Queue",
    "file_name": "10. Asteroids Collision.cpp",
    "problem_title": " Asteroids Collision",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/3. Monotonic Stack and Queue/02. Next Greater Element 2.cpp",
    "section": "07.Stack and Queues",
    "subsection": "3. Monotonic Stack and Queue",
    "file_name": "02. Next Greater Element 2.cpp",
    "problem_title": " Next Greater Element 2",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/3. Monotonic Stack and Queue/08. Largest Rectangle in Histogram.cpp",
    "section": "07.Stack and Queues",
    "subsection": "3. Monotonic Stack and Queue",
    "file_name": "08. Largest Rectangle in Histogram.cpp",
    "problem_title": " Largest Rectangle In Histogram",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/3. Monotonic Stack and Queue/07. Remove K elements.cpp",
    "section": "07.Stack and Queues",
    "subsection": "3. Monotonic Stack and Queue",
    "file_name": "07. Remove K elements.cpp",
    "problem_title": " Remove K Elements",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/3. Monotonic Stack and Queue/05. Sum of subarray minimum.cpp",
    "section": "07.Stack and Queues",
    "subsection": "3. Monotonic Stack and Queue",
    "file_name": "05. Sum of subarray minimum.cpp",
    "problem_title": " Sum Of Subarray Minimum",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/3. Monotonic Stack and Queue/01. Next Greater Element.cpp",
    "section": "07.Stack and Queues",
    "subsection": "3. Monotonic Stack and Queue",
    "file_name": "01. Next Greater Element.cpp",
    "problem_title": " Next Greater Element",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/07.Stack and Queues/3. Monotonic Stack and Queue/03. Previous Smaller Element.cpp",
    "section": "07.Stack and Queues",
    "subsection": "3. Monotonic Stack and Queue",
    "file_name": "03. Previous Smaller Element.cpp",
    "problem_title": " Previous Smaller Element",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/10. Two Sum in BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "10. Two Sum in BST.cpp",
    "problem_title": " Two Sum In Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/03. Insert into BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "03. Insert into BST.cpp",
    "problem_title": " Insert Into Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/11. Recover BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "11. Recover BST.cpp",
    "problem_title": " Recover Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/09. BST Iterator.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "09. BST Iterator.cpp",
    "problem_title": " Bst Iterator",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/06. Validate BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "06. Validate BST.cpp",
    "problem_title": " Validate Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/12. Largest BST in Binary Tree.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "12. Largest BST in Binary Tree.cpp",
    "problem_title": " Largest Bst In Binary Tree",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/08. Build BST from Preorder Traversal.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "08. Build BST from Preorder Traversal.cpp",
    "problem_title": " Build Bst From Preorder Traversal",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/07. LCA in BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "07. LCA in BST.cpp",
    "problem_title": " Lca In Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/02. Floor in BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "02. Floor in BST.cpp",
    "problem_title": " Floor In Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/05. Kth smallest element in BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "05. Kth smallest element in BST.cpp",
    "problem_title": " Kth Smallest Element In Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/04. Delete from BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "04. Delete from BST.cpp",
    "problem_title": " Delete From Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/2. Practice Problems/01. Ceil in BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "2. Practice Problems",
    "file_name": "01. Ceil in BST.cpp",
    "problem_title": " Ceil In Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/1. Concept/01. Intro to BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "1. Concept",
    "file_name": "01. Intro to BST.cpp",
    "problem_title": " Intro To Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/1. Concept/03. Minimum value in BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "1. Concept",
    "file_name": "03. Minimum value in BST.cpp",
    "problem_title": " Minimum Value In Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/12. Binary Search Trees/1. Concept/02. Search in BST.cpp",
    "section": "12. Binary Search Trees",
    "subsection": "1. Concept",
    "file_name": "02. Search in BST.cpp",
    "problem_title": " Search In Bst",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/1. Easy/01. Assign Cookies.cpp",
    "section": "10. Greedy Approach",
    "subsection": "1. Easy",
    "file_name": "01. Assign Cookies.cpp",
    "problem_title": " Assign Cookies",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/1. Easy/04. Valid Parenthesis String.cpp",
    "section": "10. Greedy Approach",
    "subsection": "1. Easy",
    "file_name": "04. Valid Parenthesis String.cpp",
    "problem_title": " Valid Parenthesis String",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/1. Easy/03. Lemonade Exchange.cpp",
    "section": "10. Greedy Approach",
    "subsection": "1. Easy",
    "file_name": "03. Lemonade Exchange.cpp",
    "problem_title": " Lemonade Exchange",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/1. Easy/02. Fractional Knapsack.cpp",
    "section": "10. Greedy Approach",
    "subsection": "1. Easy",
    "file_name": "02. Fractional Knapsack.cpp",
    "problem_title": " Fractional Knapsack",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/2. Medium/03. Jump Game 2.cpp",
    "section": "10. Greedy Approach",
    "subsection": "2. Medium",
    "file_name": "03. Jump Game 2.cpp",
    "problem_title": " Jump Game 2",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/2. Medium/07. Insert Interval.cpp",
    "section": "10. Greedy Approach",
    "subsection": "2. Medium",
    "file_name": "07. Insert Interval.cpp",
    "problem_title": " Insert Interval",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/2. Medium/05. Job Sequencing Problem.cpp",
    "section": "10. Greedy Approach",
    "subsection": "2. Medium",
    "file_name": "05. Job Sequencing Problem.cpp",
    "problem_title": " Job Sequencing Problem",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/2. Medium/02. Jump Game.cpp",
    "section": "10. Greedy Approach",
    "subsection": "2. Medium",
    "file_name": "02. Jump Game.cpp",
    "problem_title": " Jump Game",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/2. Medium/04. Minimum Platforms.cpp",
    "section": "10. Greedy Approach",
    "subsection": "2. Medium",
    "file_name": "04. Minimum Platforms.cpp",
    "problem_title": " Minimum Platforms",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/2. Medium/01. N Meetings in one room.cpp",
    "section": "10. Greedy Approach",
    "subsection": "2. Medium",
    "file_name": "01. N Meetings in one room.cpp",
    "problem_title": " N Meetings In One Room",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/2. Medium/08. Non Overlapping Intervals.cpp",
    "section": "10. Greedy Approach",
    "subsection": "2. Medium",
    "file_name": "08. Non Overlapping Intervals.cpp",
    "problem_title": " Non Overlapping Intervals",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/10. Greedy Approach/2. Medium/06. Candy.cpp",
    "section": "10. Greedy Approach",
    "subsection": "2. Medium",
    "file_name": "06. Candy.cpp",
    "problem_title": " Candy",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/3. 2D DP/02. Unique Paths.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "3. 2D DP",
    "file_name": "02. Unique Paths.cpp",
    "problem_title": " Unique Paths",
    "question": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\nExample 1:\nInput: m = 3, n = 7\nOutput: 28\n\nApproach:\n1. We can solve this problem using dynamic programming with memoization (top-down approach).\n2. We define a helper function fmemo(i, j, dp) that calculates the number of unique paths from the top-left corner (0, 0) to the cell (i, j) on the grid.\n3. The function checks if the number of unique paths for the cell (i, j) is already calculated and stored in the dp array. If yes, it returns the value from dp.\n4. Otherwise, it calculates the number of unique paths for the cell (i, j) by adding the number of unique paths from the cell above (i-1, j) and the cell to the left (i, j-1).\n5. The base case is when i or j is less than 0, in which case the function returns 0 as there are no paths to reach those cells.\n6. In the main function uniquePaths(m, n), we create a dp array of size m x n initialized with -1 and call the fmemo function for the bottom-right cell (m-1, n-1).\n7. Finally, we return the number of unique paths obtained for the bottom-right cell as the result.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(m x n) because we are calculating the number of unique paths for each cell only once and storing it in the dp array.\n- The space complexity is also O(m x n) to store the dp array.\n\nNote: The given test cases are generated such that the answer will be less than or equal to 2 x 10^9.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/3. 2D DP/05. Minimum Path in Triangle.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "3. 2D DP",
    "file_name": "05. Minimum Path in Triangle.cpp",
    "problem_title": " Minimum Path In Triangle",
    "question": "Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\nExample:\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\nApproach:\n1. We can solve this problem using dynamic programming with memoization (top-down approach).\n2. We define a helper function fmemo(i, j, n, tri, dp) that calculates the minimum path sum from the current cell (i, j) to the bottom of the triangle.\n3. The function checks if the minimum path sum for the current cell is already calculated and stored in the dp array. If yes, it returns the value from dp.\n4. If i is equal to n-1, it means we are at the last row of the triangle, so the minimum path sum is the value in the current cell (tri[i][j]).\n5. Otherwise, the function calculates the minimum path sum for the current cell by taking the minimum of the minimum path sums from the cells directly below (i+1, j) and (i+1, j+1), and then adding the value in the current cell (tri[i][j]).\n6. The result is stored in the dp array to avoid recomputation when the function is called with the same parameters again.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(n^2) because we are calculating the minimum path sum for each cell only once and storing it in the dp array.\n- The space complexity is also O(n^2) to store the dp array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/3. 2D DP/06. Minimum Falling Path Sum.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "3. 2D DP",
    "file_name": "06. Minimum Falling Path Sum.cpp",
    "problem_title": " Minimum Falling Path Sum",
    "question": "Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\n\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).\n\nExample:\nInput: matrix = [[2,1,3],[6,5,4],[7,8,9]]\nOutput: 13\nExplanation: There are two falling paths with a minimum sum as shown.\n\nApproach:\n1. We can solve this problem using dynamic programming with memoization (top-down approach).\n2. We define a helper function fmemo(i, j, mat, dp) that calculates the minimum sum of any falling path starting from cell (i, j).\n3. The function checks if the minimum sum for the current cell (i, j) is already calculated and stored in the dp array. If yes, it returns the value from dp.\n4. If i is 0, it means we are at the first row, so the minimum sum starting from this cell is the value in the current cell (mat[i][j]).\n5. Otherwise, the function calculates the minimum sum for the current cell by taking the minimum of the minimum sums of the cells above it (i-1, j-1), (i-1, j), and (i-1, j+1), and then adding the value in the current cell (mat[i][j]).\n6. The result is stored in the dp array to avoid recomputation when the function is called with the same parameters again.\n7. Finally, we find the minimum falling path sum for all cells in the first row and return the smallest value.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(n^2) since we are calculating the minimum sum for each cell only once and storing it in the dp array.\n- The space complexity is also O(n^2) to store the dp array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/3. 2D DP/03. Unique Paths 2.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "3. 2D DP",
    "file_name": "03. Unique Paths 2.cpp",
    "problem_title": " Unique Paths 2",
    "question": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\nExample:\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\nApproach:\n1. We can solve this problem using dynamic programming with memoization (top-down approach).\n2. We define a helper function fmemo(i, j, grid, dp) that calculates the number of unique paths from the top-left corner (0, 0) to the cell (i, j) on the grid.\n3. The function checks if the number of unique paths for the cell (i, j) is already calculated and stored in the dp array. If yes, it returns the value from dp.\n4. If the cell (i, j) contains an obstacle (i.e., grid[i][j] == 1), then there is no possible path through that cell, so the function returns 0.\n5. Otherwise, it calculates the number of unique paths for the cell (i, j) by adding the number of unique paths from the cell above (i-1, j) and the cell to the left (i, j-1).\n6. The base case is when i or j is less than 0, in which case the function returns 0 as there are no paths to reach those cells.\n7. In the main function uniquePathsWithObstacles(obstacleGrid), we create a dp array of size m x n initialized with -1 and call the fmemo function for the bottom-right cell (m-1, n-1).\n8. Finally, we return the number of unique paths obtained for the bottom-right cell as the result.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(m x n) because we are calculating the number of unique paths for each cell only once and storing it in the dp array.\n- The space complexity is also O(m x n) to store the dp array.\n\nNote: The given test cases are generated such that the answer will be less than or equal to 2 x 10^9.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/3. 2D DP/01. Ninja Training.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "3. 2D DP",
    "file_name": "01. Ninja Training.cpp",
    "problem_title": " Ninja Training",
    "question": "Geek is going for n days training program, he can perform any one of these three activities Running, Fighting, and Learning Practice. Each activity has some point on each day. As Geek wants to improve all his skills, he can't do the same activity on two consecutive days. Help Geek to maximize his merit points as we were given a 2D array of n*3 points corresponding to each day and activity.\n\nExample:\nInput:\nn = 3\npoints = [[1,2,5],[3,1,1],[3,3,3]]\nOutput:\n11\nExplanation:\nGeek will learn a new move and earn 5 points on the first day,\nthen on the second day, he will do running and earn 3 points,\nand on the third day, he will do fighting and earn 3 points.\nSo, the maximum points is 11.\n\nApproach:\n1. To maximize the merit points, we need to find the maximum sum of points such that the Geek can't perform the same activity on two consecutive days.\n2. We can solve this problem using dynamic programming with memoization (top-down approach).\n3. We define a helper function fmemo(n, prev, points, memo) that calculates the maximum points the Geek can earn from the nth day onwards, given that on the (n-1)th day, he performed the activity indexed by 'prev'.\n4. The function checks if the maximum points for the (n-1)th day and 'prev' activity is already calculated and stored in the memo array. If yes, it returns the value from memo.\n5. Otherwise, it calculates the maximum points for the nth day by considering all three activities except the one performed on the (n-1)th day. It then adds the points for the nth day and recursively calls the function for the (n-1)th day with the new activity and updates the maximum points.\n6. The base case is when n is less than 0, in which case the function returns 0 as there are no days to earn points.\n7. In the main function maximumPoints(points, n), we create a dp (memo) array of size n initialized with -1 and call the fmemo function for the nth day with the initial activity as -1 (since no activity is performed on the first day).\n8. Finally, we return the maximum points obtained for all three possible starting activities (running, fighting, learning practice) as the result.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(n) because we are calculating the maximum points for each day only once and storing it in the memo array.\n- The space complexity is also O(n) to store the memo array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/3. 2D DP/04. Minimum Path Sum.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "3. 2D DP",
    "file_name": "04. Minimum Path Sum.cpp",
    "problem_title": " Minimum Path Sum",
    "question": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\nExample 1:\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n\nApproach:\n1. We can solve this problem using dynamic programming with memoization (top-down approach).\n2. We define a helper function fmemo(i, j, grid, dp) that calculates the minimum sum path to reach the cell (i, j) on the grid.\n3. The function checks if the minimum sum path for the cell (i, j) is already calculated and stored in the dp array. If yes, it returns the value from dp.\n4. If i or j is less than 0 (out of bounds), the function returns a large value (e.g., 1e9) to represent an invalid path.\n5. The base case is when i and j are both 0, in which case the function returns the value in the cell (0, 0) as the minimum sum path.\n6. Otherwise, it calculates the minimum sum path for the cell (i, j) by taking the minimum of the minimum sum paths from the cell above (i-1, j) and the cell to the left (i, j-1), and then adding the value in the current cell (grid[i][j]).\n7. The result is stored in the dp array to avoid recomputation when the function is called with the same parameters again.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(m x n) because we are calculating the minimum sum path for each cell only once and storing it in the dp array.\n- The space complexity is also O(m x n) to store the dp array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/7. DP on LIS/01. Longest Increasing Subsequence.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "7. DP on LIS",
    "file_name": "01. Longest Increasing Subsequence.cpp",
    "problem_title": " Longest Increasing Subsequence",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/7. DP on LIS/02. Print LIS.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "7. DP on LIS",
    "file_name": "02. Print LIS.cpp",
    "problem_title": " Print Lis",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/7. DP on LIS/03. Largest Divisible Subset.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "7. DP on LIS",
    "file_name": "03. Largest Divisible Subset.cpp",
    "problem_title": " Largest Divisible Subset",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/7. DP on LIS/04. Longest Bitonic Subsequence.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "7. DP on LIS",
    "file_name": "04. Longest Bitonic Subsequence.cpp",
    "problem_title": " Longest Bitonic Subsequence",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/7. DP on LIS/05. Number of LIS.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "7. DP on LIS",
    "file_name": "05. Number of LIS.cpp",
    "problem_title": " Number Of Lis",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/6. DP on Stocks/02. Best time to buy and sell stock 2.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "6. DP on Stocks",
    "file_name": "02. Best time to buy and sell stock 2.cpp",
    "problem_title": " Best Time To Buy And Sell Stock 2",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/6. DP on Stocks/03. Best time to buy and sell stock upto 2 transaction.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "6. DP on Stocks",
    "file_name": "03. Best time to buy and sell stock upto 2 transaction.cpp",
    "problem_title": " Best Time To Buy And Sell Stock Upto 2 Transaction",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/6. DP on Stocks/01. Best time to buy and sell stocks.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "6. DP on Stocks",
    "file_name": "01. Best time to buy and sell stocks.cpp",
    "problem_title": " Best Time To Buy And Sell Stocks",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/6. DP on Stocks/05. Buy and sell stocks with cooldown.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "6. DP on Stocks",
    "file_name": "05. Buy and sell stocks with cooldown.cpp",
    "problem_title": " Buy And Sell Stocks With Cooldown",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/6. DP on Stocks/04. Best time to buy and sell stock uoto k transaction.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "6. DP on Stocks",
    "file_name": "04. Best time to buy and sell stock uoto k transaction.cpp",
    "problem_title": " Best Time To Buy And Sell Stock Uoto K Transaction",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/6. DP on Stocks/06. Buy and sell stocks with transaction fee.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "6. DP on Stocks",
    "file_name": "06. Buy and sell stocks with transaction fee.cpp",
    "problem_title": " Buy And Sell Stocks With Transaction Fee",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/05. Partition with given difference.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "05. Partition with given difference.cpp",
    "problem_title": " Partition With Given Difference",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/06. 01 Knapsack.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "06. 01 Knapsack.cpp",
    "problem_title": " 01 Knapsack",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/02. Partition array in two equal sum subsets.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "02. Partition array in two equal sum subsets.cpp",
    "problem_title": " Partition Array In Two Equal Sum Subsets",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/01. Subset sum equal to k.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "01. Subset sum equal to k.cpp",
    "problem_title": " Subset Sum Equal To K",
    "question": "Given an array of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum.\n\nExample:\nInput:\nN = 6\narr[] = {3, 34, 4, 12, 5, 2}\nsum = 9\nOutput: 1\nExplanation: Here there exists a subset with sum = 9, 4+3+2 = 9.\n\nApproach:\n1. We can solve this problem using dynamic programming with memoization (top-down approach).\n2. We define a helper function fmemo(i, sum, arr, dp) that checks if there is a subset of elements up to index i whose sum is equal to the given sum.\n3. The function checks if the target sum is 0. If yes, it means we have found a subset with the given sum and returns true.\n4. If i is 0, it means we are at the first element, so the function checks if the first element is equal to the target sum.\n5. If the dp value for the current index and sum is already calculated, it returns the stored value.\n6. If the current element (arr[i]) is less than or equal to the target sum, the function recursively checks for two cases: including the current element in the subset (by reducing the sum) or excluding it (by not changing the sum).\n7. If any of the above cases returns true, the dp value for the current index and sum is updated to true.\n8. Finally, we return the dp value for the last index and the given sum.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(n * sum), where n is the number of elements in the array and sum is the target sum. This is because the function calculates the result for each index and sum only once and stores it in the dp array.\n- The space complexity is also O(n * sum) to store the dp array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/10. Unbounded Knapsack.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "10. Unbounded Knapsack.cpp",
    "problem_title": " Unbounded Knapsack",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/08. Target Sum.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "08. Target Sum.cpp",
    "problem_title": " Target Sum",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/11. Rod Cutting Problem.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "11. Rod Cutting Problem.cpp",
    "problem_title": " Rod Cutting Problem",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/07. Coin Change.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "07. Coin Change.cpp",
    "problem_title": " Coin Change",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/03. Minimum Sum Partition.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "03. Minimum Sum Partition.cpp",
    "problem_title": " Minimum Sum Partition",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/04. Count number of subsets with sum K.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "04. Count number of subsets with sum K.cpp",
    "problem_title": " Count Number Of Subsets With Sum K",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/4. DP on Subsequences/09. Coin Change 2.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "4. DP on Subsequences",
    "file_name": "09. Coin Change 2.cpp",
    "problem_title": " Coin Change 2",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/5. DP on Strings/04. Longest Palindromic Subsequence.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "5. DP on Strings",
    "file_name": "04. Longest Palindromic Subsequence.cpp",
    "problem_title": " Longest Palindromic Subsequence",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/5. DP on Strings/06. Minimum steps to make other string.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "5. DP on Strings",
    "file_name": "06. Minimum steps to make other string.cpp",
    "problem_title": " Minimum Steps To Make Other String",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/5. DP on Strings/09. Wildcard Matching.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "5. DP on Strings",
    "file_name": "09. Wildcard Matching.cpp",
    "problem_title": " Wildcard Matching",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/5. DP on Strings/01. Longest Common Subsequence.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "5. DP on Strings",
    "file_name": "01. Longest Common Subsequence.cpp",
    "problem_title": " Longest Common Subsequence",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/5. DP on Strings/07. Shortest Common Supersequence.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "5. DP on Strings",
    "file_name": "07. Shortest Common Supersequence.cpp",
    "problem_title": " Shortest Common Supersequence",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/5. DP on Strings/02. Print the LCS.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "5. DP on Strings",
    "file_name": "02. Print the LCS.cpp",
    "problem_title": " Print The Lcs",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/5. DP on Strings/08. Distinct Subsequences.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "5. DP on Strings",
    "file_name": "08. Distinct Subsequences.cpp",
    "problem_title": " Distinct Subsequences",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/5. DP on Strings/03. Longest Common Substring.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "5. DP on Strings",
    "file_name": "03. Longest Common Substring.cpp",
    "problem_title": " Longest Common Substring",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/5. DP on Strings/05. Minimum steps to make string palindrome.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "5. DP on Strings",
    "file_name": "05. Minimum steps to make string palindrome.cpp",
    "problem_title": " Minimum Steps To Make String Palindrome",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/9. DP on Squares/02. Count square submatrices.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "9. DP on Squares",
    "file_name": "02. Count square submatrices.cpp",
    "problem_title": " Count Square Submatrices",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/9. DP on Squares/01. Maximal Square.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "9. DP on Squares",
    "file_name": "01. Maximal Square.cpp",
    "problem_title": " Maximal Square",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/8. DP on Partition/03. Burst Ballons.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "8. DP on Partition",
    "file_name": "03. Burst Ballons.cpp",
    "problem_title": " Burst Ballons",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/8. DP on Partition/06. Partition array for maximum sum.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "8. DP on Partition",
    "file_name": "06. Partition array for maximum sum.cpp",
    "problem_title": " Partition Array For Maximum Sum",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/8. DP on Partition/02. Minimum cost to cut stick.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "8. DP on Partition",
    "file_name": "02. Minimum cost to cut stick.cpp",
    "problem_title": " Minimum Cost To Cut Stick",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/8. DP on Partition/05. Palindorme Partionting 2.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "8. DP on Partition",
    "file_name": "05. Palindorme Partionting 2.cpp",
    "problem_title": " Palindorme Partionting 2",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/8. DP on Partition/01. MCM.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "8. DP on Partition",
    "file_name": "01. MCM.cpp",
    "problem_title": " Mcm",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/1. Intro to DP/01. Find the nth fibonacci number.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "1. Intro to DP",
    "file_name": "01. Find the nth fibonacci number.cpp",
    "problem_title": " Find The Nth Fibonacci Number",
    "question": "Find the nth fibonacci number.\n\nApproach:\n1. We can use dynamic programming to calculate the nth Fibonacci number.\n2. We define a helper function fibo(n, dp) that calculates the nth Fibonacci number using memoization.\n3. The function checks if the nth Fibonacci number is already calculated and stored in the dp array. If yes, it returns the value from dp.\n4. Otherwise, it calculates the nth Fibonacci number by recursively calling fibo(n-1, dp) and fibo(n-2, dp) and stores the result in dp.\n5. The base cases are when n is 0 or 1, in which case the function returns n.\n6. In the main function, we take the input for n and create a dp array of size n+1 initialized with -1.\n7. We then call the fibo function passing n and the dp array as arguments.\n8. Finally, we print the value of dp[n], which represents the nth Fibonacci number.\n\nComplexity Analysis:\n- The time complexity of the fibo function is O(n) because we are calculating and storing the Fibonacci numbers from 0 to n.\n- The space complexity is also O(n) to store the dp array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/2. 1D DP/03. Frog K Jumps.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "2. 1D DP",
    "file_name": "03. Frog K Jumps.cpp",
    "problem_title": " Frog K Jumps",
    "question": "Geek wants to climb from the 0th stair to the (n-1)th stair. At a time, the Geek can climb k steps.\nA height[N] array is also given. Whenever the geek jumps from stair i to stair j, the energy consumed in the jump is abs(height[i] - height[j]), where abs() means the absolute difference.\nReturn the minimum energy that can be used by the Geek to jump from stair 0 to stair N-1.\n\nExample:\nInput:\n4 2\n10 40 30 10\nOutput:\n40\n\nExplanation:\nFor 'n' = 4, 'k' = 2, height = {10, 40, 30, 10}\n\nInitially, we are present at stone 1 having height 10. We can reach stone 3 as 'k' is 2. So, the cost incurred is |10 - 30| = 20.\n\nNow, we are present at stone 3, we can reach stone 4 as 'k' is 2. So, the cost incurred is |30 - 10| = 20. So, the total cost is 40. We can show any other path will lead to greater cost.\n\nApproach:\n1. We can use dynamic programming with memoization to find the minimum energy required to jump from the 0th stair to the (n-1)th stair.\n2. We define a helper function fmemo(i, k, h, dp) that calculates the minimum energy required to jump from the 0th stair to the ith stair using memoization.\n3. The function checks if the minimum energy for the ith stair is already calculated and stored in the dp array. If yes, it returns the value from dp.\n4. Otherwise, it calculates the minimum energy by considering all possible jumps from i-j (where j varies from 1 to k) and stores the result in dp[i].\n5. The base case is when i is 0, in which case the function returns 0 as the Geek is already at the 0th stair.\n6. In the main function minimizeCost(n, k, height), we create a dp array of size n initialized with -1 and call the fmemo function passing n-1 (last stair), k, the height array, and the dp array as arguments.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(n*k) because we are calculating and storing the minimum energy for each stair and considering k possible jumps at each stair.\n- The space complexity is also O(n) to store the dp array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/2. 1D DP/01. Climbing Stairs.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "2. 1D DP",
    "file_name": "01. Climbing Stairs.cpp",
    "problem_title": " Climbing Stairs",
    "question": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nApproach:\n1. We can use dynamic programming with memoization to calculate the number of distinct ways to climb the staircase.\n2. We define a helper function fmemo(n, dp) that calculates the number of distinct ways to climb n steps using memoization.\n3. The function checks if the number of ways to climb n steps is already calculated and stored in the dp array. If yes, it returns the value from dp.\n4. Otherwise, it calculates the number of ways to climb n steps by recursively calling fmemo(n-1, dp) and fmemo(n-2, dp) and stores the result in dp.\n5. The base cases are when n is 1 or 2, in which case the function returns n.\n6. In the main function climbStairs(n), we check if n is 1 or 2. If yes, we directly return n as the number of distinct ways to climb.\n7. Otherwise, we create a dp array of size n+1 initialized with -1 and call the fmemo function passing n and the dp array as arguments.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(n) because we are calculating and storing the number of ways to climb n steps.\n- The space complexity is also O(n) to store the dp array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/2. 1D DP/02. Frog Jump.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "2. 1D DP",
    "file_name": "02. Frog Jump.cpp",
    "problem_title": " Frog Jump",
    "question": "Geek wants to climb from the 0th stair to the (n-1)th stair. At a time, the Geek can climb either one or two steps.\nA height[N] array is also given. Whenever the geek jumps from stair i to stair j, the energy consumed in the jump is abs(height[i] - height[j]), where abs() means the absolute difference.\nReturn the minimum energy that can be used by the Geek to jump from stair 0 to stair N-1.\n\nApproach:\n1. We can use dynamic programming with memoization to find the minimum energy required to jump from the 0th stair to the (n-1)th stair.\n2. We define a helper function fmemo(i, h, dp) that calculates the minimum energy required to jump from the 0th stair to the ith stair using memoization.\n3. The function checks if the minimum energy for the ith stair is already calculated and stored in the dp array. If yes, it returns the value from dp.\n4. Otherwise, it calculates the minimum energy by taking two possible jumps - either from (i-1)th stair or from (i-2)th stair - and stores the result in dp[i].\n5. The base case is when i is 0, in which case the function returns 0 as the Geek is already at the 0th stair.\n6. In the main function minimumEnergy(height, n), we create a dp array of size n initialized with -1 and call the fmemo function passing n-1 (last stair), the height array, and the dp array as arguments.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(n) because we are calculating and storing the minimum energy for each stair.\n- The space complexity is also O(n) to store the dp array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/2. 1D DP/04. House Robber.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "2. 1D DP",
    "file_name": "04. House Robber.cpp",
    "problem_title": " House Robber",
    "question": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\nApproach:\n1. We can use dynamic programming with memoization to solve this problem.\n2. We define a helper function fmemo(i, nums, dp) that calculates the maximum amount of money that can be robbed from the 0th to the ith house using memoization.\n3. The function checks if the maximum amount for the ith house is already calculated and stored in the dp array. If yes, it returns the value from dp.\n4. Otherwise, it calculates the maximum amount by considering two options:\n   a) Rob the current house and add the money with the maximum amount from the (i-2)th house (since adjacent houses cannot be robbed).\n   b) Skip the current house and take the maximum amount from the (i-1)th house.\n5. The base case is when i is less than 0, in which case the function returns 0 as there are no houses to rob.\n6. In the main function rob(nums), we create a dp array of size n initialized with -1 and call the fmemo function passing n-1 (last house), the nums array, and the dp array as arguments.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(n) because we are calculating the maximum amount for each house only once and storing it in the dp array.\n- The space complexity is also O(n) to store the dp array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/14. Dynamic Programming/2. 1D DP/05. House Robber 2.cpp",
    "section": "14. Dynamic Programming",
    "subsection": "2. 1D DP",
    "file_name": "05. House Robber 2.cpp",
    "problem_title": " House Robber 2",
    "question": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\nApproach:\n1. Since the houses are arranged in a circle, the robber cannot rob the first and last house together as they are adjacent.\n2. To solve this problem, we can divide it into two subproblems: one where the robber robs from the first house to the second-last house (excluding the last house), and another where the robber robs from the second house to the last house (excluding the first house).\n3. We can use dynamic programming with memoization to calculate the maximum amount of money that can be robbed in each subproblem.\n4. We define a helper function fmemo(e, i, nums, dp) that calculates the maximum amount of money that can be robbed from the e-th to the i-th house using memoization.\n5. The function checks if the maximum amount for the i-th house is already calculated and stored in the dp array. If yes, it returns the value from dp.\n6. Otherwise, it calculates the maximum amount by considering two options:\n   a) Rob the current house and add the money with the maximum amount from the (i-2)th house (since adjacent houses cannot be robbed).\n   b) Skip the current house and take the maximum amount from the (i-1)th house.\n7. The base case is when i is less than e, in which case the function returns 0 as there are no houses to rob.\n8. In the main function rob(nums), we first check if there is only one house. If yes, the robber can only rob that house, so we return the amount in that case.\n9. Otherwise, we create a dp array of size n initialized with -1 and call the fmemo function twice: one for robbing from the first to the second-last house and the other for robbing from the second to the last house.\n10. Finally, we return the maximum amount from the two subproblems, which gives the maximum amount the robber can rob without alerting the police.\n\nComplexity Analysis:\n- The time complexity of the fmemo function is O(n) because we are calculating the maximum amount for each house only once and storing it in the dp array.\n- The space complexity is also O(n) to store the dp array.",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/3. Advanced Maths/03. Sieve of Eratosthenes.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "3. Advanced Maths",
    "file_name": "03. Sieve of Eratosthenes.cpp",
    "problem_title": " Sieve Of Eratosthenes",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/3. Advanced Maths/02. All divisors of number.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "3. Advanced Maths",
    "file_name": "02. All divisors of number.cpp",
    "problem_title": " All Divisors Of Number",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/3. Advanced Maths/04. Prime factorization using Sieve.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "3. Advanced Maths",
    "file_name": "04. Prime factorization using Sieve.cpp",
    "problem_title": " Prime Factorization Using Sieve",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/3. Advanced Maths/05. Fast Power.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "3. Advanced Maths",
    "file_name": "05. Fast Power.cpp",
    "problem_title": " Fast Power",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/3. Advanced Maths/01. Prime factors of number.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "3. Advanced Maths",
    "file_name": "01. Prime factors of number.cpp",
    "problem_title": " Prime Factors Of Number",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/2. Interview Problems/02. Exceptionally odd.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "2. Interview Problems",
    "file_name": "02. Exceptionally odd.cpp",
    "problem_title": " Exceptionally Odd",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/2. Interview Problems/01. Minimum bit flips.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "2. Interview Problems",
    "file_name": "01. Minimum bit flips.cpp",
    "problem_title": " Minimum Bit Flips",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/2. Interview Problems/03. XOR of numbers from L to R.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "2. Interview Problems",
    "file_name": "03. XOR of numbers from L to R.cpp",
    "problem_title": " Xor Of Numbers From L To R",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/1. Learn Bit Manipulation/07.Divide two numbers using bit maipulation.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "1. Learn Bit Manipulation",
    "file_name": "07.Divide two numbers using bit maipulation.cpp",
    "problem_title": "Divide Two Numbers Using Bit Maipulation",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/1. Learn Bit Manipulation/02.Check for the ith bit.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "1. Learn Bit Manipulation",
    "file_name": "02.Check for the ith bit.cpp",
    "problem_title": "Check For The Ith Bit",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/1. Learn Bit Manipulation/06.Swap two numbers without temporary variable.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "1. Learn Bit Manipulation",
    "file_name": "06.Swap two numbers without temporary variable.cpp",
    "problem_title": "Swap Two Numbers Without Temporary Variable",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/1. Learn Bit Manipulation/05.Set the righmost unset bit.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "1. Learn Bit Manipulation",
    "file_name": "05.Set the righmost unset bit.cpp",
    "problem_title": "Set The Righmost Unset Bit",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/1. Learn Bit Manipulation/01.Bit Manipulation.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "1. Learn Bit Manipulation",
    "file_name": "01.Bit Manipulation.cpp",
    "problem_title": "Bit Manipulation",
    "question": "Given a 32-bit unsigned integer num and an integer i, perform the following operations on the number:\n1. Get the ith bit.\n2. Set the ith bit.\n3. Clear the ith bit.\n\nNote: The bits are indexed from 1 instead of 0 (1-based indexing).\n\nExample:\nInput: 70, 3\nOutput: 1 70 66\nExplanation:\n- The bit at the 3rd position from the least significant bit (LSB) is 1. (1 0 0 0 1 1 0)\n- The value of the given number after setting the 3rd bit is 70.\n- The value of the given number after clearing the 3rd bit is 66. (1 0 0 0 0 1 0)\n\nApproach:\n1. Subtract 1 from i to adjust the index to 0-based.\n2. To get the ith bit, perform a bitwise AND operation between num and (1 << i). If the result is non-zero, the ith bit is set; otherwise, it is cleared.\n3. To set the ith bit, perform a bitwise OR operation between num and (1 << i).\n4. To clear the ith bit, perform a bitwise AND operation between num and the complement of (1 << i).\n\nCODE:",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/1. Learn Bit Manipulation/08.Count set bit from numbers 1 to n.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "1. Learn Bit Manipulation",
    "file_name": "08.Count set bit from numbers 1 to n.cpp",
    "problem_title": "Count Set Bit From Numbers 1 To N",
    "question": null,
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/1. Learn Bit Manipulation/04.Check for the power of 2.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "1. Learn Bit Manipulation",
    "file_name": "04.Check for the power of 2.cpp",
    "problem_title": "Check For The Power Of 2",
    "question": "Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nExample 1:\nInput: n = 1\nOutput: true\nExplanation: 2^0 = 1\n\nExample 2:\nInput: n = 16\nOutput: true\nExplanation: 2^4 = 16",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  },
  {
    "file_path": "/home/chiranjeet/dev/dsa/Strivers-A2Z-DSA-Sheet/06.Bit Manipulation/1. Learn Bit Manipulation/03.Check for odd even.cpp",
    "section": "06.Bit Manipulation",
    "subsection": "1. Learn Bit Manipulation",
    "file_name": "03.Check for odd even.cpp",
    "problem_title": "Check For Odd Even",
    "question": "Given a positive integer N, determine whether it is odd or even.\n\nExample 1:\n\nInput:\nN = 1\nOutput:\nodd\nExplanation:\nThe number 1 is odd.\n\nAPPROACH:\nTo determine whether a positive integer N is odd or even, we can check the least significant bit (LSB) of N. \nIf the LSB is 1, the number is odd. If the LSB is 0, the number is even.\nWe can use the bitwise AND operation with 1 (N & 1) to check the LSB.\nIf the result is 1, we return \"odd\". If the result is 0, we return \"even\".\n\n\nCODE",
    "approach": null,
    "time_complexity": null,
    "space_complexity": null
  }
]