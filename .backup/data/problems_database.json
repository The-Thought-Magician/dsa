[
  {
    "id": "step_13_+_14_-_trees_+_bst_bfs-traversals",
    "title": "Bfs Traversals",
    "file_path": "Step 13 + 14 - Trees + BST/BFS-TRAVERSALS.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Easy",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Queue",
      "Two Pointers"
    ],
    "solution_code": "from typing import List, Optional\nfrom queue import Queue\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        q = Queue()\n        if not root:\n            return []\n        q.put(root)\n        level = []\n        while not q.empty():\n            size = q.qsize()\n            curr_level = []\n            while size:\n                node: Optional[TreeNode] = q.get()\n                curr_level.append(node.val)\n                if node.left:\n                    q.put(node.left)\n                if node.right:\n                    q.put(node.right)\n                size -= 1\n            level.append(curr_level)\n        return level\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_serialise-deserialise",
    "title": "Serialise Deserialise",
    "file_path": "Step 13 + 14 - Trees + BST/SERIALISE-DESERIALISE.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Easy",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Queue",
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional\nfrom queue import Queue\n\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Codec:\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"\"\n\n        seq = []\n        q = Queue()\n        q.put(root)\n        while not q.empty():\n            curr: Optional[TreeNode] = q.get()\n            if curr:\n                seq.append(str(curr.val))\n                q.put(curr.left)\n                q.put(curr.right)\n            else:\n                seq.append('#')\n\n        return ','.join(seq)\n\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return None\n\n        nodes = data.split(',')\n        root = TreeNode(int(nodes[0]))\n        q = Queue()\n        q.put(root)\n        i = 1\n        while not q.empty():\n            node = q.get()\n            if nodes[i] != '#':\n                node.left = TreeNode(int(nodes[i]))\n                q.put(node.left)\n            i += 1\n            if nodes[i] != '#':\n                node.right = TreeNode(int(nodes[i]))\n                q.put(node.right)\n            i += 1\n\n        return root\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": ":type root: TreeNode :rtype: str",
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_convert-sorted-arr-to-bst",
    "title": "Convert Sorted Arr To Bst",
    "file_path": "Step 13 + 14 - Trees + BST/CONVERT-SORTED-ARR-TO-BST.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Easy",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List, Optional\n\n# Asked in Accolite Interviews\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        n = len(nums)\n        def helper(s: int, e: int) -> Optional[TreeNode]:\n            if e <= s:\n                return None\n            m = (s + e)//2\n            curr = TreeNode(nums[m])\n            curr.left = helper(s, m)\n            curr.right= helper(m+1, e)\n            return curr\n        return helper(0, n)\n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Asked in Accolite Interviews",
    "hints": [
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_kth-smallest-element-in-bst",
    "title": "Kth Smallest Element In Bst",
    "file_path": "Step 13 + 14 - Trees + BST/KTH-SMALLEST-ELEMENT-IN-BST.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Easy",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        inorder = []\n\n        def helper(curr: Optional[TreeNode]) -> None:\n            if not curr:\n                return None\n            helper(curr.left)\n            inorder.append(curr.val)\n            helper(curr.right)\n            return None\n\n        helper(root)\n        return inorder[k - 1]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_same-tree",
    "title": "Same Tree",
    "file_path": "Step 13 + 14 - Trees + BST/SAME-TREE.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Medium",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        def helper(node1: Optional[TreeNode], node2: Optional[TreeNode]) -> bool:\n            if not node1 and not node2:\n                return True\n            elif not (node1 and node2):\n                return False\n            else:\n                if node1.val == node2.val:\n                    return helper(node1.left, node2.left) and helper(node1.right, node2.right)\n                else:\n                    return False\n\n        return helper(p, q)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_subtree-of-another-tree",
    "title": "Subtree Of Another Tree",
    "file_path": "Step 13 + 14 - Trees + BST/SUBTREE-OF-ANOTHER-TREE.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Medium",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Graph Traversal",
      "Recursion",
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subroot: Optional[TreeNode]) -> bool:\n        def helper(node1: Optional[TreeNode], node2: Optional[TreeNode]):\n            if not node1 and not node2:\n                return True\n            if not (node1 and node2):\n                return False\n            if node1.val != node2.val:\n                return False\n            return helper(node1.left, node2.left) and helper(node1.right, node2.right)\n\n        def dfs(node: Optional[TreeNode]):\n            if not node:\n                return False\n            if node.val == subroot.val:\n                if helper(node, subroot):\n                    return True\n            return dfs(node.left) or dfs(node.right)\n\n        return dfs(root)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_diameter-of-binary-tree",
    "title": "Diameter Of Binary Tree",
    "file_path": "Step 13 + 14 - Trees + BST/DIAMETER-OF-BINARY-TREE.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Medium",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional, List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        ans = 0\n\n        def helper(node: Optional[TreeNode]) -> int:\n            nonlocal ans\n            if not node:\n                return 0\n            l = helper(node.left)\n            r = helper(node.right)\n            ans = max(ans, l + r)\n            return 1 + max(l, r)\n\n        helper(root)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_max-depth-of-binary-tree",
    "title": "Max Depth Of Binary Tree",
    "file_path": "Step 13 + 14 - Trees + BST/MAX-DEPTH-OF-BINARY-TREE.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Medium",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional, List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        def helper(node: Optional[TreeNode]) -> int:\n            if not node:\n                return 0\n            left = helper(node.left)\n            right = helper(node.right)\n            return max(left, right) + 1\n\n        return helper(root)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_max-path-sum",
    "title": "Max Path Sum",
    "file_path": "Step 13 + 14 - Trees + BST/MAX-PATH-SUM.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Easy",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "import sys\nfrom typing import Optional\n\n\n# DP on Trees\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        maxi = -sys.maxsize\n\n        def helper(curr: Optional[TreeNode]) -> int:\n            if not curr:\n                return 0\n            nonlocal maxi\n            left = helper(curr.left)\n            right = helper(curr.right)\n            this = curr.val\n            maxi = max(maxi, this, this + left, this + right, this + left + right)\n            return max(this + left, this + right, this)\n\n        temp = helper(root)\n        return maxi\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "DP on Trees",
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_search-in-bst",
    "title": "Search In Bst",
    "file_path": "Step 13 + 14 - Trees + BST/SEARCH-IN-BST.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Easy",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        def helper(curr: Optional[TreeNode]) -> Optional[TreeNode]:\n            if not curr:\n                return None\n            if curr.val == val:\n                return curr\n            if val < curr.val:\n                return helper(curr.left)\n            else:\n                return helper(curr.right)\n\n        return helper(root)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_validate-bst",
    "title": "Validate Bst",
    "file_path": "Step 13 + 14 - Trees + BST/VALIDATE-BST.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Easy",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional\nimport sys\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        low = -sys.maxsize\n        high = sys.maxsize\n\n        def helper(curr: Optional[TreeNode], left: int, right: int) -> bool:\n            if not curr:\n                return True\n            if left < curr.val < right:\n                l = helper(curr.left, left, curr.val)\n                r = helper(curr.right, curr.val, right)\n                return l and r\n            else:\n                return False\n\n        return helper(root, low, high)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_binary-tree-right-side-view",
    "title": "Binary Tree Right Side View",
    "file_path": "Step 13 + 14 - Trees + BST/BINARY-TREE-RIGHT-SIDE-VIEW.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Medium",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Queue",
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional, List\nfrom queue import Queue\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        q = Queue()\n        if not root:\n            return []\n        q.put(root)\n        ans = []\n        while not q.empty():\n            size = q.qsize()\n            while size:\n                curr = q.get()\n                if size == 1:\n                    ans.append(curr.val)\n                if curr.left:\n                    q.put(curr.left)\n                if curr.right:\n                    q.put(curr.right)\n                size -= 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_construct-binary-tree-from-pre-in-traversal",
    "title": "Construct Binary Tree From Pre In Traversal",
    "file_path": "Step 13 + 14 - Trees + BST/CONSTRUCT-BINARY-TREE-FROM-PRE-IN-TRAVERSAL.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Medium",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers",
      "Collections"
    ],
    "solution_code": "from typing import Optional, List\nfrom collections import defaultdict\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        mp = defaultdict(int, {value: key for key, value in enumerate(inorder)})\n\n        def helper(prestart: int, preend: int, instart: int, inend: int) -> Optional[TreeNode]:\n            if prestart > preend or instart > inend:\n                return None\n            root_index = mp[preorder[prestart]]\n            left_length = root_index - instart\n            curr: Optional[TreeNode] = TreeNode(preorder[prestart])\n            curr.left = helper(prestart + 1, prestart + left_length, instart, root_index - 1)\n            curr.right = helper(prestart + left_length + 1, preend, root_index + 1, inend)\n            return curr\n\n        return helper(0, len(preorder) - 1, 0, len(inorder) - 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_count-good-nodes",
    "title": "Count Good Nodes",
    "file_path": "Step 13 + 14 - Trees + BST/COUNT-GOOD-NODES.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Easy",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Graph Traversal",
      "Recursion",
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def goodNodes(self, root: Optional[TreeNode]) -> int:\n        cnt = 0\n\n        def dfs(curr: Optional[TreeNode], maxi: int) -> None:\n            nonlocal cnt\n            if not curr:\n                return None\n            if curr.val >= maxi:\n                cnt += 1\n            dfs(curr.left, max(maxi, curr.val))\n            dfs(curr.right, max(maxi, curr.val))\n            return None\n\n        dfs(root, int(-1e4))  # why 1e4 -> due to lower limit of constraints in problem given\n        return cnt\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_dfs-traversals",
    "title": "Dfs Traversals",
    "file_path": "Step 13 + 14 - Trees + BST/DFS-TRAVERSALS.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Easy",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional\n\n\nclass Node:\n    def __init__(self, val: int):\n        self.data = val\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def inorder_traversal(self, root: Optional[Node]):\n        inorder = []\n\n        def helper(node: Optional[Node]):\n            if not node:\n                return\n            helper(node.left)\n            inorder.append(node.data)\n            helper(node.right)\n\n        helper(root)\n        return inorder\n\n    def preorder_traversal(self, root: Optional[Node]):\n        preorder = []\n\n        def helper(node: Optional[Node]):\n            if not node:\n                return\n            preorder.append(node.data)\n            helper(node.left)\n            helper(node.right)\n\n        helper(root)\n        return preorder\n\n    def postorder_traversal(self, root: Optional[Node]):\n        postorder = []\n\n        def helper(node: Optional[Node]):\n            if not node:\n                return\n            helper(node.left)\n            helper(node.right)\n            postorder.append(node.data)\n\n        helper(root)\n        return postorder\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_lowest-common-ancestor",
    "title": "Lowest Common Ancestor",
    "file_path": "Step 13 + 14 - Trees + BST/LOWEST-COMMON-ANCESTOR.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Easy",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional\n\n\nclass Node:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def lowestCommonAncestor(self, root: Optional[Node], p: Optional[Node], q: Optional[Node]) -> Optional[Node]:\n        if not root or root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if not left:  # no answer in left part\n            return right\n        elif not right:  # no answer in right part\n            return left\n        else:  # got answer in both part\n            return root\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_balanced-binary-tree",
    "title": "Balanced Binary Tree",
    "file_path": "Step 13 + 14 - Trees + BST/BALANCED-BINARY-TREE.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Medium",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def depth(node: Optional[TreeNode]) -> int:\n            if not node:\n                return 0\n            l = depth(node.left)\n            r = depth(node.right)\n            return 1 + max(l, r)\n\n        def helper(node: Optional[TreeNode]) -> bool:\n            if not node:\n                return True\n            dl = depth(node.left)\n            dr = depth(node.right)\n            if abs(dr - dl) > 1:\n                return False\n            return helper(node.left) and helper(node.right)\n\n        return helper(root)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_13_+_14_-_trees_+_bst_invert-binary-tree",
    "title": "Invert Binary Tree",
    "file_path": "Step 13 + 14 - Trees + BST/INVERT-BINARY-TREE.py",
    "category": "Step 13 + 14 - Trees + BST",
    "step": "Step 13 + 14 - Trees + BST",
    "difficulty": "Medium",
    "patterns": [
      "Tree",
      "Binary Tree",
      "BST",
      "DFS",
      "BFS"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        l = root.left\n        r = root.right\n        root.left = r\n        root.right = l\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_min-stack",
    "title": "Min Stack",
    "file_path": "Step 09 - Stacks Queues/MIN-STACK.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "maxsize = 2 ** 31\n\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minimum = maxsize\n\n    def push(self, val: int) -> None:\n        if val < self.minimum:\n            self.minimum = val\n        self.stack.append((val, self.minimum))\n\n    def pop(self) -> None:\n        self.stack.pop()\n        if len(self.stack):\n            self.minimum = self.stack[-1][1]\n        else:\n            self.minimum = maxsize\n\n    def top(self) -> int:\n        if len(self.stack):\n            a, b = self.stack[-1]\n            return a\n        else:\n            return -1\n\n    def getMin(self) -> int:\n        return self.minimum\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Your MinStack object will be instantiated and called as such: obj = MinStack() obj.push(val) obj.pop() param_3 = obj.top() param_4 = obj.getMin()",
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_trapping-rainwater",
    "title": "Trapping Rainwater",
    "file_path": "Step 09 - Stacks Queues/TRAPPING-RAINWATER.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List\n\n\nclass BruteForce:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        ans = 0\n        for i in range(n):\n            max_left = max(height[:i+1])\n            max_right = max(height[i:])\n            ans += min(max_left, max_right) - height[i]\n        return ans\n\n\nclass Optimised:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        max_left = [0 for _ in range(n)]\n        max_right = [0 for _ in range(n)]\n        max_left[0] = height[0]\n        for i in range(1, n):\n            max_left[i] = max(max_left[i - 1], height[i])\n        max_right[-1] = height[-1]\n        for i in range(n - 2, -1, -1):\n            max_right[i] = max(max_right[i + 1], height[i])\n        ans = 0\n        for i in range(n):  # though we can skip 0th and (n-1)th index -> bcz they will never in any case store water!\n            ans += min(max_left[i], max_right[i]) - height[i]\n        return ans\n\n\n# Incomplete\nclass Efficient:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        left = height[0]\n        right = height[-1]\n        ans = 0\n        for i in range(1, n - 2):\n            pass\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Incomplete",
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_stack-using-two-queue",
    "title": "Stack Using Two Queue",
    "file_path": "Step 09 - Stacks Queues/STACK-USING-TWO-QUEUE.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Queue",
      "Stack"
    ],
    "solution_code": "from queue import Queue\n\n\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = Queue()\n        self.q2 = Queue()\n        self.tp = -1\n\n    def push(self, x: int) -> None:\n        self.q1.put(x)\n        self.tp = x\n\n    def pop(self) -> int:\n        if self.tp == -1:\n            return -1\n        while self.q1.qsize() > 1:\n            self.q2.put(self.q1.get())\n        ans = self.q1.get()\n        if self.q2.qsize():\n            while self.q2.qsize():\n                temp = self.q2.get()\n                self.q1.put(temp)\n                self.tp = temp\n        else:\n            self.tp = -1\n        return ans\n\n    def top(self) -> int:\n        return self.tp\n\n    def empty(self) -> bool:\n        return self.tp == -1\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Your MyStack object will be instantiated and called as such: obj = MyStack() obj.push(x) param_2 = obj.pop() param_3 = obj.top() param_4 = obj.empty()",
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_asteroid-collision",
    "title": "Asteroid Collision",
    "file_path": "Step 09 - Stacks Queues/ASTEROID-COLLISION.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n        stack = []\n        for item in asteroids:\n            if len(stack):\n                if item > 0:\n                    stack.append(item)\n                else:\n                    if stack[-1] < 0:\n                        stack.append(item)\n                    else:\n                        while len(stack) and 0 < stack[-1] < abs(item):\n                            stack.pop()\n                        if len(stack):\n                            if stack[-1] < 0:\n                                stack.append(item)\n                            else:\n                                if stack[-1] == abs(item):\n                                    stack.pop()\n                                else:\n                                    continue\n                        else:\n                            stack.append(item)\n            else:\n                stack.append(item)\n        return stack\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_sum-of-subarray-minimums",
    "title": "Sum Of Subarray Minimums",
    "file_path": "Step 09 - Stacks Queues/SUM-OF-SUBARRAY-MINIMUMS.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "from typing import List\n\nmod = int(1e9 + 7)\n\n\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        n = len(arr)\n        next_smaller = [n for _ in range(n)]\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while len(stack) and arr[stack[-1]] >= arr[i]:  # edge case fix! -> arr: [1, 1] (duplicates)\n                stack.pop()\n            if len(stack):\n                next_smaller[i] = stack[-1]\n            stack.append(i)\n\n        prev_smaller = [-1 for _ in range(n)]\n        stack = []\n        for i in range(n):\n            while len(stack) and arr[stack[-1]] > arr[i]:\n                stack.pop()\n            if len(stack):\n                prev_smaller[i] = stack[-1]\n            stack.append(i)\n\n        ans = 0\n        for i in range(n):\n            contri = (i - prev_smaller[i]) * (next_smaller[i] - i)\n            ans += contri * arr[i]\n        return ans % mod\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_crawler-log-folder",
    "title": "Crawler Log Folder",
    "file_path": "Step 09 - Stacks Queues/CRAWLER-LOG-FOLDER.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def minOperations(self, logs: List[str]) -> int:\n        stack = []\n        op1, op2 = '../', './'\n        for log in logs:\n            if log == op1:\n                if len(stack) > 0:\n                    stack.pop(-1)\n                else:\n                    continue\n            elif log == op2:\n                continue\n            else:\n                log = log[:-1]\n                stack.append(log)\n        return len(stack)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_stack-using-one-queue",
    "title": "Stack Using One Queue",
    "file_path": "Step 09 - Stacks Queues/STACK-USING-ONE-QUEUE.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Queue",
      "Stack"
    ],
    "solution_code": "from queue import Queue, PriorityQueue\n\n\nclass MyStack:\n\n    def __init__(self):\n        self.q = Queue()\n        self.tp = -1\n\n    def push(self, x: int) -> None:\n        self.q.put(x)\n        self.tp = x\n\n    def pop(self) -> int:\n        n = self.q.qsize()\n        while n > 1:\n            temp = self.q.get()\n            self.q.put(temp)\n            n -= 1\n            self.tp = temp\n        ans = self.q.get()\n        if self.q.empty():\n            self.tp = -1\n        return ans\n\n    def top(self) -> int:\n        return self.tp\n\n    def empty(self) -> bool:\n        return self.tp == -1\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Your MyStack object will be instantiated and called as such: obj = MyStack() obj.push(x) param_2 = obj.pop() param_3 = obj.top() param_4 = obj.empty()",
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_queue-using-stack",
    "title": "Queue Using Stack",
    "file_path": "Step 09 - Stacks Queues/QUEUE-USING-STACK.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Queue",
      "Stack"
    ],
    "solution_code": "class MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n        self.front = -1\n\n    def push(self, x: int) -> None:\n        if not len(self.stack1):\n            self.front = x\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        ans = self.front\n        while len(self.stack1) > 1:\n            self.stack2.append(self.stack1.pop())\n        if len(self.stack1):\n            self.stack1.pop()\n        if len(self.stack2):\n            self.front = self.stack2[-1]\n        else:\n            self.front = -1\n        while len(self.stack2):\n            self.stack1.append(self.stack2.pop())\n        return ans\n\n    def peek(self) -> int:\n        return self.front\n\n    def empty(self) -> bool:\n        return self.front == -1\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Your MyQueue object will be instantiated and called as such: obj = MyQueue() obj.push(x) param_2 = obj.pop() param_3 = obj.peek() param_4 = obj.empty()",
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_next-smaller",
    "title": "Next Smaller",
    "file_path": "Step 09 - Stacks Queues/NEXT-SMALLER.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def help_classmate(self, arr: List[int], n: int):\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while len(stack) and stack[-1] >= arr[i]:\n                stack.pop()\n            temp = arr[i]\n            if len(stack):\n                arr[i] = stack[-1]\n            else:\n                arr[i] = -1\n            stack.append(temp)\n        return arr\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_valid-parantheses",
    "title": "Valid Parantheses",
    "file_path": "Step 09 - Stacks Queues/VALID-PARANTHESES.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        for item in s:\n            if item == '(' or item == '[' or item == '{':\n                stack.append(item)\n            elif item == ')':\n                if len(stack) > 0 and stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n            elif item == ']':\n                if len(stack) > 0 and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n            elif item == '}':\n                if len(stack) > 0 and stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n        return len(stack) == 0\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_maximal-rectangle",
    "title": "Maximal Rectangle",
    "file_path": "Step 09 - Stacks Queues/MAXIMAL-RECTANGLE.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "from typing import List\n\n'''\nHint: this problem is just a tweaked version of 'Largest Rectangle in Histogram' problem on leetcode.\nHere convert this grid into histograms!\n'''\n\n\nclass Solution:\n    def maximalRectangle(self, grid: List[List[str]]) -> int:\n        n, m = len(grid), len(grid[0])\n        grid = [list(map(int, grid[i])) for i in range(n)]\n        for i in range(1, n):\n            for j in range(m):\n                if grid[i][j]:\n                    grid[i][j] += grid[i - 1][j]\n        maxi = max([self.helper(grid[i]) for i in range(n)])\n        return maxi\n\n    def helper(self, row: List[int]) -> int:\n        \"\"\"\n        Same function as used in Largest Rectangle in Histogram Solution 3\n        \"\"\"\n        stack = []\n        n = len(row)\n        ans = 0\n        for i, h in enumerate(row):\n            while len(stack) and h < row[stack[-1]]:\n                nse = i\n                curr = stack.pop()\n                pse = -1\n                if len(stack):\n                    pse = stack[-1]\n                ans = max(ans, (nse - pse - 1) * row[curr])\n            stack.append(i)\n        while len(stack):\n            nse = n\n            curr = stack.pop()\n            pse = -1\n            if len(stack):\n                pse = stack[-1]\n            ans = max(ans, (nse - pse - 1) * row[curr])\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Hint: this problem is just a tweaked version of 'Largest Rectangle in Histogram' problem on leetcode. Here convert this grid into histograms!",
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_stock-span",
    "title": "Stock Span",
    "file_path": "Step 09 - Stacks Queues/STOCK-SPAN.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "class StockSpanner:\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        cnt = 1\n        while len(self.stack) and self.stack[-1][0] <= price:\n            cnt += self.stack[-1][1]\n            self.stack.pop()\n        self.stack.append((price, cnt))\n        return cnt\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Your StockSpanner object will be instantiated and called as such: obj = StockSpanner() param_1 = obj.next(price)",
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_remove-k-digits",
    "title": "Remove K Digits",
    "file_path": "Step 09 - Stacks Queues/REMOVE-K-DIGITS.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "class Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        n = len(num)\n        if k == n:\n            return \"0\"\n        if k == 0:\n            return num\n        num = list(map(int, num))\n        stack = []\n        i = 0\n        while k and i < n:\n            while k and len(stack) and stack[-1] > num[i]:\n                k -= 1\n                stack.pop()\n            stack.append(num[i])\n            i += 1\n        if i < n:\n            stack += num[i:]\n        if k > 0:\n            stack = stack[:-k]\n        s = \"\".join(list(map(str, stack)))\n        s = s.lstrip('0')\n        return s if len(s) else \"0\"\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_next-greater-element-2",
    "title": "Next Greater Element 2",
    "file_path": "Step 09 - Stacks Queues/NEXT-GREATER-ELEMENT-2.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\n        nums.extend(nums)\n        n = len(nums)\n        ans = [-1 for _ in range(n)]\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while len(stack) and stack[-1] <= nums[i]:\n                stack.pop()\n            if len(stack):\n                ans[i] = stack[-1]\n            else:\n                ans[i] = -1\n            stack.append(nums[i])\n        return ans[:n // 2]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_number-of-nges-to-the-right",
    "title": "Number Of Nges To The Right",
    "file_path": "Step 09 - Stacks Queues/NUMBER-OF-NGES-TO-THE-RIGHT.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def count_NGEs(self, n: int, arr: List[int], queries: int, indices: List[int]) -> List[int]:\n        ans = []\n        for q in indices:\n            cnt = 0\n            for item in arr[q + 1:]:\n                if item > arr[q]:\n                    cnt += 1\n            ans.append(cnt)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_stack-using-linkedlist",
    "title": "Stack Using Linkedlist",
    "file_path": "Step 09 - Stacks Queues/STACK-USING-LINKEDLIST.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Queue",
      "Stack",
      "Collections"
    ],
    "solution_code": "from collections import defaultdict\n\n\nclass MyStack:\n    class StackNode:\n        def __init__(self, data):\n            self.data = data\n            self.next = None\n\n    def __init__(self):\n        self.prev = defaultdict()\n        self.tail = self.StackNode(-1)\n\n    def push(self, data) -> None:\n        node = self.StackNode(data)\n        self.prev[node] = self.tail\n        self.tail.next = node\n        self.tail = self.tail.next\n\n    def pop(self) -> int:\n        ans = self.tail.data\n        self.tail.next = None\n        if self.tail in self.prev:\n            self.tail = self.prev[self.tail]\n        return ans\n\n\n'''\nNote: Queue can also be implemented using Linkedlist in the similar fashion only difference is in that case we have to\nmaintain two pointers one head and one tail for FIFO operation!\n'''",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Note: Queue can also be implemented using Linkedlist in the similar fashion only difference is in that case we have to maintain two pointers one head and one tail for FIFO operation!",
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_sliding-window-max",
    "title": "Sliding Window Max",
    "file_path": "Step 09 - Stacks Queues/SLIDING-WINDOW-MAX.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Medium",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Queue",
      "Heap",
      "Collections"
    ],
    "solution_code": "from typing import List\nimport heapq\nfrom collections import deque\n\n\nclass Solution1:\n    \"\"\"\n    Using Priority Queue\n    \"\"\"\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        pq = []\n        for i in range(k):\n            item = nums[i]\n            heapq.heappush(pq, (-item, i))\n        ans = [-pq[0][0]]\n        for i in range(k, n):\n            left = i - k\n            item = nums[i]\n            while len(pq) and pq[0][1] <= left:\n                heapq.heappop(pq)\n            heapq.heappush(pq, (-item, i))\n            ans.append(-pq[0][0])\n        return ans\n\n\nclass Solution2:\n    \"\"\"\n    Using Deque\n    \"\"\"\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        dq = deque()\n        ans = []\n        n = len(nums)\n        for i, item in enumerate(nums):\n            while len(dq) and dq[0] <= i - k:\n                dq.popleft()\n            while len(dq) and nums[dq[-1]] <= item:\n                dq.pop()\n            dq.append(i)\n            if i >= k - 1:\n                ans.append(nums[dq[0]])\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Using Priority Queue",
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_sum-of-subarray-ranges",
    "title": "Sum Of Subarray Ranges",
    "file_path": "Step 09 - Stacks Queues/SUM-OF-SUBARRAY-RANGES.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        maxi = self.subarrayMaximum(nums)\n        mini = self.subarrayMinimum(nums)\n        return maxi - mini\n\n    def subarrayMinimum(self, nums: List[int]):\n        n = len(nums)\n        prev_smaller = [-1 for _ in range(n)]\n        stack = []\n        for i in range(n):\n            while len(stack) and nums[stack[-1]] >= nums[i]:\n                stack.pop()\n            if len(stack):\n                prev_smaller[i] = stack[-1]\n            stack.append(i)\n        next_smaller = [n for _ in range(n)]\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while len(stack) and nums[stack[-1]] > nums[i]:\n                stack.pop()\n            if len(stack):\n                next_smaller[i] = stack[-1]\n            stack.append(i)\n        return sum([nums[i] * (i - prev_smaller[i]) * (next_smaller[i] - i) for i in range(n)])\n\n    def subarrayMaximum(self, nums: List[int]):\n        n = len(nums)\n        prev_greater = [-1 for _ in range(n)]\n        stack = []\n        for i in range(n):\n            while len(stack) and nums[stack[-1]] <= nums[i]:\n                stack.pop()\n            if len(stack):\n                prev_greater[i] = stack[-1]\n            stack.append(i)\n        next_greater = [n for _ in range(n)]\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while len(stack) and nums[stack[-1]] < nums[i]:\n                stack.pop()\n            if len(stack):\n                next_greater[i] = stack[-1]\n            stack.append(i)\n        return sum([nums[i] * (i - prev_greater[i]) * (next_greater[i] - i) for i in range(n)])\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_09_-_stacks_queues_largest-rectangle-in-histogram",
    "title": "Largest Rectangle In Histogram",
    "file_path": "Step 09 - Stacks Queues/LARGEST-RECTANGLE-IN-HISTOGRAM.py",
    "category": "Step 09 - Stacks Queues",
    "step": "Step 09 - Stacks Queues",
    "difficulty": "Easy",
    "patterns": [
      "Stack",
      "Queue",
      "Monotonic Stack"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "from typing import List\n\n'''\nSolution 1:\nTraverse through each element and determing the prev_smaller_element and the next_smaller_element for this ith indexed\nelement -> to get the width for this rectangle -> (i - pse[i] + nse[i] - i - 1) = (nse[i] - pse[i] - 1) and height\nwould be obviously heights[i]\n'''\n\n'''\nSolution 2:\nSolution 1 could be optimised using stacks by storing the pse and nse for each element separately in different vectors.\nBut this solution is multi-pass solution and we need to traverse through the array 3 times to get the largest rectangle\narea!\n'''\n\n\nclass Optimised:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        prev_smaller = [-1 for _ in range(n)]\n        stack = []\n        for i, h in enumerate(heights):\n            while len(stack) and heights[stack[-1]] >= h:\n                stack.pop()\n            if len(stack):\n                prev_smaller[i] = stack[-1]\n            stack.append(i)\n        next_smaller = [n for _ in range(n)]\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while len(stack) and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            if len(stack):\n                next_smaller[i] = stack[-1]\n            stack.append(i)\n\n        return max([heights[i] * (i - prev_smaller[i] + next_smaller[i] - i - 1) for i in range(n)])\n\n\n'''\nSolution 3: Efficient : One-Pass Solution (Best Explanation Striver[New Video])\n'''\n\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        n = len(heights)\n        ans = 0\n        for i, h in enumerate(heights):\n            while len(stack) and h < heights[stack[-1]]:\n                nse = i\n                curr = stack.pop()\n                pse = -1\n                if len(stack):\n                    pse = stack[-1]\n                ans = max(ans, (nse - pse - 1) * heights[curr])\n            stack.append(i)\n        while len(stack):\n            nse = n\n            curr = stack.pop()\n            pse = -1\n            if len(stack):\n                pse = stack[-1]\n            ans = max(ans, (nse - pse - 1) * heights[curr])\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Solution 1: Traverse through each element and determing the prev_smaller_element and the next_smaller_element for this ith indexed element -> to get the width for this rectangle -> (i - pse[i] + nse[i] - i - 1) = (nse[i] - pse[i] - 1) and height would be obviously heights[i]",
    "hints": []
  },
  {
    "id": "infix-prefix-postfix_prefix-infix",
    "title": "Prefix Infix",
    "file_path": "Step 09 - Stacks Queues/INFIX-PREFIX-POSTFIX/PREFIX-INFIX.py",
    "category": "INFIX-PREFIX-POSTFIX",
    "step": "INFIX-PREFIX-POSTFIX",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "class Solution:\n    def preToInfix(self, exp: str):\n        stack = []\n        for item in exp[::-1]:\n            if item.isalnum():\n                stack.append(item)\n            else:\n                a = stack.pop()\n                b = stack.pop()\n                temp = f\"({a}{item}{b})\"\n                stack.append(temp)\n        return stack[-1]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "infix-prefix-postfix_prefix-postfix",
    "title": "Prefix Postfix",
    "file_path": "Step 09 - Stacks Queues/INFIX-PREFIX-POSTFIX/PREFIX-POSTFIX.py",
    "category": "INFIX-PREFIX-POSTFIX",
    "step": "INFIX-PREFIX-POSTFIX",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "class Solution:\n    def preToPost(self, exp: str):\n        stack = []\n        for item in exp[::-1]:\n            if item.isalnum():\n                stack.append(item)\n            else:\n                top1 = stack.pop()\n                top2 = stack.pop()\n                temp = top1 + top2 + item\n                stack.append(temp)\n        return stack[-1]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "infix-prefix-postfix_postfix-prefix",
    "title": "Postfix Prefix",
    "file_path": "Step 09 - Stacks Queues/INFIX-PREFIX-POSTFIX/POSTFIX-PREFIX.py",
    "category": "INFIX-PREFIX-POSTFIX",
    "step": "INFIX-PREFIX-POSTFIX",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "class Solution:\n    def postToPre(self, exp: str):\n        stack = []\n        for item in exp:\n            if item.isalnum():\n                stack.append(item)\n            else:\n                top1 = stack.pop()\n                top2 = stack.pop()\n                temp = item + top2 + top1\n                stack.append(temp)\n        return stack[-1]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "infix-prefix-postfix_infix-prefix",
    "title": "Infix Prefix",
    "file_path": "Step 09 - Stacks Queues/INFIX-PREFIX-POSTFIX/INFIX-PREFIX.py",
    "category": "INFIX-PREFIX-POSTFIX",
    "step": "INFIX-PREFIX-POSTFIX",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "class Solution:\n    \"\"\"\n    Step 1: Reverse\n    Step 2: Replace\n    Step 3: Infix-Postfix (with one slight change in equality sign)\n    Step 4: Reverse\n    \"\"\"\n    def InfixtoPrefix(self, exp: str):\n        exp = exp[::-1]\n        s = \"\"\n        for i in range(len(exp)):\n            if exp[i] == '(':\n                s += ')'\n            elif exp[i] == ')':\n                s += '('\n            else:\n                s += exp[i]\n        ans = self.InfixtoPostfix(s)\n        return ans[::-1]\n\n    def InfixtoPostfix(self, exp: str):\n        ans = \"\"\n        n = len(exp)\n        stack = []\n        priority = {'^': 3, '*': 2, '/': 2, '+': 1, '-': 1}\n        for i in range(n):\n            c = exp[i]\n            if 'a' <= c <= 'z' or 'A' <= c <= 'Z' or '0' <= c <= '9':\n                # operand\n                ans += c\n            elif c == '(':\n                # opening bracket\n                stack.append(c)\n            elif c == ')':\n                # closing bracket\n                while len(stack) and stack[-1] != '(':\n                    ans += stack[-1]\n                    stack.pop()\n                if len(stack) and stack[-1] == '(':\n                    stack.pop()\n            else:\n                # operator\n                if len(stack):\n                    while len(stack) and stack[-1] != '(' and priority[stack[-1]] > priority[c]:  # CHANGES\n                        ans += stack[-1]\n                        stack.pop()\n                    stack.append(c)\n                else:\n                    stack.append(c)\n        while len(stack):\n            ans += stack[-1]\n            stack.pop()\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Step 1: Reverse Step 2: Replace Step 3: Infix-Postfix (with one slight change in equality sign) Step 4: Reverse",
    "hints": []
  },
  {
    "id": "infix-prefix-postfix_infix-postfix",
    "title": "Infix Postfix",
    "file_path": "Step 09 - Stacks Queues/INFIX-PREFIX-POSTFIX/INFIX-POSTFIX.py",
    "category": "INFIX-PREFIX-POSTFIX",
    "step": "INFIX-PREFIX-POSTFIX",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "class Solution:\n    def InfixtoPostfix(self, exp: str):\n        ans = \"\"\n        n = len(exp)\n        stack = []\n        priority = {'^': 3, '*': 2, '/': 2, '+': 1, '-': 1}\n        for i in range(n):\n            c = exp[i]\n            if 'a' <= c <= 'z' or 'A' <= c <= 'Z' or '0' <= c <= '9':\n                # operand\n                ans += c\n            elif c == '(':\n                # opening bracket\n                stack.append(c)\n            elif c == ')':\n                # closing bracket\n                while len(stack) and stack[-1] != '(':\n                    ans += stack[-1]\n                    stack.pop()\n                if len(stack) and stack[-1] == '(':\n                    stack.pop()\n            else:\n                # operator\n                if len(stack):\n                    while len(stack) and stack[-1] != '(' and priority[stack[-1]] >= priority[c]:\n                        ans += stack[-1]\n                        stack.pop()\n                    stack.append(c)\n                else:\n                    stack.append(c)\n        while len(stack):\n            ans += stack[-1]\n            stack.pop()\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "operand opening bracket closing bracket operator",
    "hints": []
  },
  {
    "id": "infix-prefix-postfix_postfix-infix",
    "title": "Postfix Infix",
    "file_path": "Step 09 - Stacks Queues/INFIX-PREFIX-POSTFIX/POSTFIX-INFIX.py",
    "category": "INFIX-PREFIX-POSTFIX",
    "step": "INFIX-PREFIX-POSTFIX",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "class Solution:\n    def postToInfix(self, exp: str):\n        n = len(exp)\n        stack = []\n        for i in range(n):\n            c = exp[i]\n            '''\n            if 'a' <= c <= 'z' or 'A' <= c <= 'Z' or '0' <= c <= '9':\n            we have a function for this in python! isalnum()\n            '''\n            if c.isalnum():\n                stack.append(c)\n            else:\n                a = stack.pop()\n                b = stack.pop()\n                temp = f\"({b}{c}{a})\"\n                stack.append(temp)\n        return stack[-1]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "if 'a' <= c <= 'z' or 'A' <= c <= 'Z' or '0' <= c <= '9': we have a function for this in python! isalnum()",
    "hints": []
  },
  {
    "id": "step_15_-_graphs_cheapest-flight-k-stops",
    "title": "Cheapest Flight K Stops",
    "file_path": "Step 15 - Graphs/CHEAPEST-FLIGHT-K-STOPS.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Medium",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import PriorityQueue\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        adj = [[] for _ in range(n)]\n        for u, v, wt in flights:\n            adj[u].append((v, wt))\n        ans = int(1e9)\n        price = [int(1e9) for _ in range(n)]\n        pq = PriorityQueue()\n        pq.put((-1, 0, src))\n        price[src] = 0\n        while not pq.empty():\n            stops, cost, curr = pq.get()\n            if curr == dst:\n                ans = min(ans, cost)\n            if stops + 1 <= k:\n                for v, wt in adj[curr]:\n                    if price[v] > cost + wt:\n                        price[v] = cost + wt\n                        pq.put((stops + 1, price[v], v))\n        return ans if ans < int(1e9) else -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_enclaves",
    "title": "Enclaves",
    "file_path": "Step 15 - Graphs/ENCLAVES.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Recursion"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def numEnclaves(self, grid: List[List[int]]) -> int:\n        row = [-1, 0, 1, 0]\n        col = [0, 1, 0, -1]\n        n = len(grid)\n        m = len(grid[0])\n\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = -1\n            for k in range(4):\n                ni = i + row[k]\n                nj = j + col[k]\n                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:\n                    dfs(ni, nj)\n\n        for i in range(n):\n            for j in range(m):\n                if (i == 0 or i == n - 1 or j == 0 or j == m - 1) and grid[i][j] == 1:\n                    dfs(i, j)\n\n        cnt = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    cnt += 1\n        return cnt\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_make-a-large-island",
    "title": "Make A Large Island",
    "file_path": "Step 15 - Graphs/MAKE-A-LARGE-ISLAND.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n'''\nJust take some hint : https://youtu.be/lgiz0Oup6gM?si=sLQo3V1Cs8C7jxE1\n'''\n\n\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        dset = DisjointSet(n * m)\n\n        def is_valid(i: int, j: int) -> bool:\n            return 0 <= i < n and 0 <= j < m and grid[i][j] == 1\n\n        row = [-1, 0, 1, 0]\n        col = [0, 1, 0, -1]\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:\n                    u = i * m + j\n                    for k in range(4):\n                        ni = i + row[k]\n                        nj = j + col[k]\n                        if is_valid(ni, nj):\n                            v = ni * m + nj\n                            dset.union_by_size(u, v)\n        ans = max(dset.size[i] for i in range(n * m))\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    u = i * m + j\n                    size = 1\n                    st = set()\n                    for k in range(4):\n                        ni = i + row[k]\n                        nj = j + col[k]\n                        if is_valid(ni, nj):\n                            v = ni * m + nj\n                            if dset.find_parent(v) not in st:\n                                size += dset.size[dset.find_parent(v)]\n                                st.add(dset.find_parent(v))\n                    ans = max(ans, size)\n        return ans\n\n\nclass DisjointSet:\n    def __init__(self, n: int):\n        self.rank = [0 for _ in range(n)]  # for union-by-rank\n        self.size = [1 for _ in range(n)]  # for union-by-size\n        self.parent = [i for i in range(n)]\n\n    def find_parent(self, x: int) -> int:\n        if x == self.parent[x]:\n            return x\n        self.parent[x] = self.find_parent(self.parent[x])\n        return self.parent[x]\n\n    def union_by_rank(self, u: int, v: int) -> None:\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n        if pu == pv:  # if both are already connected\n            return None\n        if self.rank[pu] >= self.rank[pv]:\n            self.parent[pv] = pu\n            if self.rank[pu] == self.rank[pv]:\n                self.rank[pu] += 1\n        else:\n            self.parent[pu] = pv\n        return None\n\n    def union_by_size(self, u: int, v: int) -> None:\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n        if pu == pv:  # if both are already connected\n            return None\n        if self.size[pu] >= self.size[pv]:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n        else:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        return None\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Just take some hint : https://youtu.be/lgiz0Oup6gM?si=sLQo3V1Cs8C7jxE1",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_bipartite-graph",
    "title": "Bipartite Graph",
    "file_path": "Step 15 - Graphs/BIPARTITE-GRAPH.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Hard",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Queue",
      "Recursion"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\"\"\"\nGraph is bipartite means that no adjacent nodes are of the same color if we try to color all the nodes of the graph\nusing just two colors! \n\"\"\"\n\n\nclass Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        n = len(graph)\n        color = [0 for _ in range(n)]\n\n        def bfs(i: int):\n            q = Queue()\n            q.put((i, 1))\n            color[i] = 1\n            while not q.empty():\n                node, col = q.get()\n                pre = lambda x: 1 if x == 2 else 2\n                for item in graph[node]:\n                    if color[item] == 0:\n                        color[item] = pre(col)\n                        q.put((item, color[item]))\n                    else:\n                        if color[item] == col:\n                            return False\n            return True\n\n        for i in range(n):\n            if color[i] == 0:\n                if not bfs(i):\n                    return False\n        return True\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Graph is bipartite means that no adjacent nodes are of the same color if we try to color all the nodes of the graph using just two colors!",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_minimum-effort-path",
    "title": "Minimum Effort Path",
    "file_path": "Step 15 - Graphs/MINIMUM-EFFORT-PATH.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import PriorityQueue\n\n\nclass Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        n = len(heights)\n        m = len(heights[0])\n        row = [-1, 0, 1, 0]\n        col = [0, 1, 0, -1]\n\n        def isValid(i: int, j: int) -> bool:\n            return 0 <= i < n and 0 <= j < m\n\n        distance = [[int(1e9) for _ in range(m)] for _ in range(n)]\n        pq = PriorityQueue()\n        pq.put((0, 0, 0))\n        distance[0][0] = 0\n        while not pq.empty():\n            dist, i, j = pq.get()\n            if (i, j) == (n - 1, m - 1):\n                return dist\n            for k in range(4):\n                ni = i + row[k]\n                nj = j + col[k]\n                if isValid(ni, nj):\n                    max_wt = max(dist, abs(heights[ni][nj] - heights[i][j]))\n                    if distance[ni][nj] > max_wt:\n                        distance[ni][nj] = max_wt\n                        pq.put((max_wt, ni, nj))\n        return distance[n - 1][m - 1]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_most-stones-removed-within-same-row",
    "title": "Most Stones Removed Within Same Row",
    "file_path": "Step 15 - Graphs/MOST-STONES-REMOVED-WITHIN-SAME-ROW.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class DisjointSet:\n    def __init__(self, n):\n        self.size = [1] * n\n        self.parent = list(range(n))\n\n    def find_parent(self, node):\n        if self.parent[node] == node:\n            return node\n        self.parent[node] = self.find_parent(self.parent[node])\n        return self.parent[node]\n\n    def union_by_size(self, u, v):\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n\n        # If both nodes have the same parent, they are already connected\n        if pu == pv:\n            return\n\n        # Connect the smaller tree to the larger one\n        if self.size[pu] < self.size[pv]:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        else:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n\n    def is_same_component(self, u, v):\n        return self.find_parent(u) == self.find_parent(v)\n\n\nclass Solution:\n    def removeStones(self, stones):\n        n = len(stones)\n        # Find the maximum row and column indices in the stones list\n        maxi_row = max(stone[0] for stone in stones)\n        maxi_col = max(stone[1] for stone in stones)\n\n        # Initialize the disjoint set\n        ds = DisjointSet(maxi_row + maxi_col + 2)\n\n        # A dictionary to mark where stones are placed\n        stone_map = {}\n\n        # Union rows and columns\n        for stone in stones:\n            u, v = stone[0], stone[1] + maxi_row + 1\n            ds.union_by_size(u, v)\n            stone_map[u] = 1\n            stone_map[v] = 1\n\n        # Calculate the maximum number of stones that can be removed\n        ans = n\n        for i in range(maxi_row + maxi_col + 2):\n            if i in stone_map:\n                if ds.find_parent(i) == i:\n                    ans -= 1\n\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "If both nodes have the same parent, they are already connected Connect the smaller tree to the larger one Find the maximum row and column indices in the stones list Initialize the disjoint set A dictionary to mark where stones are placed Union rows and columns Calculate the maximum number of stones that can be removed",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_aliens-dictionary",
    "title": "Aliens Dictionary",
    "file_path": "Step 15 - Graphs/ALIENS-DICTIONARY.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def findOrder(self, dictionary: List[str], n: int, k: int) -> List[str]:\n        def node(c: chr) -> int:\n            return ord(c) - ord('a')\n\n        adj = [[] for _ in range(k)]\n        indegree = [0 for _ in range(k)]\n        for i in range(1, n):\n            item1 = dictionary[i - 1]\n            item2 = dictionary[i]\n            size = min(len(item1), len(item2))\n            j = 0\n            while j < size and item1[j] == item2[j]:\n                j += 1\n            if j < size:\n                u = node(item1[j])\n                v = node(item2[j])\n                adj[u].append(v)\n                indegree[v] += 1\n        q = Queue()\n        for i in range(k):\n            if indegree[i] == 0:\n                q.put(i)\n        ans = []\n        while not q.empty():\n            curr = q.get()\n            curr_char = chr(curr + ord('a'))\n            ans.append(curr_char)\n            for item in adj[curr]:\n                indegree[item] -= 1\n                if indegree[item] == 0:\n                    q.put(item)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_eventual-safe-states",
    "title": "Eventual Safe States",
    "file_path": "Step 15 - Graphs/EVENTUAL-SAFE-STATES.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        adj = [[] for _ in range(n)]\n        outdegree = [0 for _ in range(n)]\n        q = Queue()\n        for u in range(n):\n            outdegree[u] = len(graph[u])\n            if outdegree[u] == 0:\n                q.put(u)\n            for v in graph[u]:\n                adj[v].append(u)\n        ans = []\n        while not q.empty():\n            curr = q.get()\n            ans.append(curr)\n            for i in adj[curr]:\n                outdegree[i] -= 1\n                if outdegree[i] == 0:\n                    q.put(i)\n        return sorted(ans)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_num-ways-to-arrive-at-destination",
    "title": "Num Ways To Arrive At Destination",
    "file_path": "Step 15 - Graphs/NUM-WAYS-TO-ARRIVE-AT-DESTINATION.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import PriorityQueue\nimport sys\n\n\nclass Solution:\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\n        pq = PriorityQueue()\n        adj = [[] for _ in range(n)]\n        for u, v, wt in roads:\n            adj[u].append((v, wt))\n            adj[v].append((u, wt))\n        distance = [sys.maxsize for _ in range(n)]  # sys.maxsize bcz it was the upper limit in the problem!\n        distance[0] = 0\n        pq.put((0, 0))\n        ways = [1 for _ in range(n)]\n        while not pq.empty():\n            cost, curr = pq.get()\n            for v, wt in adj[curr]:\n                if distance[v] > cost + wt:\n                    distance[v] = cost + wt\n                    pq.put((distance[v], v))\n                    ways[v] = ways[curr]\n                elif distance[v] == cost + wt:\n                    ways[v] += ways[curr]\n        return ways[n - 1] % int(1e9 + 7)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_number-provinces",
    "title": "Number Provinces",
    "file_path": "Step 15 - Graphs/NUMBER-PROVINCES.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Recursion"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def findCircleNum(self, adj: List[List[int]]) -> int:\n        n = len(adj)\n        isVisited = [0 for _ in range(n)]\n\n        def dfs(curr: int) -> None:\n            isVisited[curr] = 1\n            for i in range(n):\n                if adj[curr][i] and i != curr and not isVisited[i]:\n                    dfs(i)\n            return None\n\n        cnt = 0\n        for i in range(n):\n            if not isVisited[i]:\n                cnt += 1\n                dfs(i)\n        return cnt\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_mst-kruskal-algo",
    "title": "Mst Kruskal Algo",
    "file_path": "Step 15 - Graphs/MST-KRUSKAL-ALGO.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def spanningTree(self, n: int, adj: List[List[int]]):\n        edges = []\n        for i in range(n):\n            for v, wt in adj[i]:\n                edges.append((i, v, wt))\n        edges.sort(key=lambda x: x[2])\n        mst = 0\n        dset = DisjointSet(n)\n        for u, v, wt in edges:\n            pu = dset.find_parent(u)\n            pv = dset.find_parent(v)\n            if pu != pv:\n                mst += wt\n                dset.union_by_rank(u, v)\n        return mst\n\n\nclass DisjointSet:\n    def __init__(self, n: int):\n        self.rank = [0 for _ in range(n)]  # for union-by-rank\n        self.size = [1 for _ in range(n)]  # for union-by-size\n        self.parent = [i for i in range(n)]\n\n    def find_parent(self, x: int) -> int:\n        if x == self.parent[x]:\n            return x\n        self.parent[x] = self.find_parent(self.parent[x])\n        return self.parent[x]\n\n    def union_by_rank(self, u: int, v: int) -> None:\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n        if pu == pv:  # if both are already connected\n            return None\n        if self.rank[pu] >= self.rank[pv]:\n            self.parent[pv] = pu\n            if self.rank[pu] == self.rank[pv]:\n                self.rank[pu] += 1\n        else:\n            self.parent[pu] = pv\n        return None\n\n    def union_by_size(self, u: int, v: int) -> None:\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n        if pu == pv:  # if both are already connected\n            return None\n        if self.size[pu] >= self.size[pv]:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n        else:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        return None\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_dfs",
    "title": "Dfs",
    "file_path": "Step 15 - Graphs/DFS.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Recursion"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def dfsOfGraph(self, v: int, adj: List[List[int]]):\n        ans = []\n        isVisited = [0 for _ in range(v)]\n\n        def dfs(node: int):\n            ans.append(node)\n            isVisited[node] = 1\n            for item in adj[node]:\n                if not isVisited[item]:\n                    dfs(item)\n            return None\n\n        dfs(0)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_djikstra-algorithm",
    "title": "Djikstra Algorithm",
    "file_path": "Step 15 - Graphs/DJIKSTRA-ALGORITHM.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import PriorityQueue\n\n\nclass Solution:\n    def shortestPath(self, n: int, m: int, edges: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for u, v, wt in edges:\n            adj[u].append((v, wt))\n        distance = [int(1e9) for _ in range(n)]\n        pq = PriorityQueue()\n        pq.put((0, 0))  # src = 0\n        distance[0] = 0\n        while not pq.empty():\n            dist, curr = pq.get()\n            for v, wt in adj[curr]:\n                if distance[v] > dist + wt:\n                    distance[v] = dist + wt\n                    pq.put((distance[v], v))\n        for i in range(n):\n            if distance[i] == int(1e9):\n                distance[i] = -1\n        return distance\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_mst-prims-algorithm",
    "title": "Mst Prims Algorithm",
    "file_path": "Step 15 - Graphs/MST-PRIMS-ALGORITHM.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import PriorityQueue\n\n\n# Considering the graph is fully-connected.\n\nclass Solution:\n    def spanningTree(self, n: int, adj: List[List[int]]):\n        pq = PriorityQueue()\n        mst = 0\n        isVisited = [0 for _ in range(n)]\n        pq.put((0, 0))\n        while not pq.empty():\n            wt, curr = pq.get()\n            if not isVisited[curr]:\n                isVisited[curr] = 1\n                mst += wt\n                for v, weight in adj[curr]:\n                    if not isVisited[v]:\n                        pq.put((weight, v))\n        return mst\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Considering the graph is fully-connected.",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_undirected-graph-cycle-dfs",
    "title": "Undirected Graph Cycle Dfs",
    "file_path": "Step 15 - Graphs/UNDIRECTED-GRAPH-CYCLE-DFS.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Hard",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Recursion"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def isCycle(self, v: int, adj: List[List[int]]) -> bool:\n        isVisited = [0 for _ in range(v)]\n\n        def dfs(parent, node) -> bool:\n            nonlocal isVisited\n            isVisited[node] = 1\n            for item in adj[node]:\n                if not isVisited[item]:\n                    if dfs(node, item):\n                        return True\n                else:\n                    if item != parent:\n                        return True\n            return False\n\n        for i in range(v):\n            if not isVisited[i]:\n                if dfs(-1, i):\n                    return True\n        return False\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_bfs",
    "title": "Bfs",
    "file_path": "Step 15 - Graphs/BFS.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Queue",
      "Recursion"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def bfsOfGraph(self, v: int, adj: List[List[int]]) -> List[int]:\n        q = Queue()\n        ans = []\n        isVisited = [0 for _ in range(v)]\n        q.put(0)\n        isVisited[0] = 1\n        while not q.empty():\n            curr = q.get()\n            ans.append(curr)\n            for item in adj[curr]:\n                if not isVisited[item]:\n                    q.put(item)\n                    isVisited[item] = 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_disjoint-set-implementation",
    "title": "Disjoint Set Implementation",
    "file_path": "Step 15 - Graphs/DISJOINT-SET-IMPLEMENTATION.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class DisjointSet:\n    def __init__(self, n: int):\n        self.rank = [0 for _ in range(n)]  # for union-by-rank\n        self.size = [1 for _ in range(n)]  # for union-by-size\n        self.parent = [i for i in range(n)]\n\n    def find_parent(self, x: int) -> int:\n        if x == self.parent[x]:\n            return x\n        self.parent[x] = self.find_parent(self.parent[x])\n        return self.parent[x]\n\n    def union_by_rank(self, u: int, v: int) -> None:\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n        if pu == pv:  # if both are already connected\n            return None\n        if self.rank[pu] >= self.rank[pv]:\n            self.parent[pv] = pu\n            if self.rank[pu] == self.rank[pv]:\n                self.rank[pu] += 1\n        else:\n            self.parent[pu] = pv\n        return None\n\n    def union_by_size(self, u: int, v: int) -> None:\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n        if pu == pv:  # if both are already connected\n            return None\n        if self.size[pu] >= self.size[pv]:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n        else:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        return None\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_smallest-distance-threshold",
    "title": "Smallest Distance Threshold",
    "file_path": "Step 15 - Graphs/SMALLEST-DISTANCE-THRESHOLD.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def findTheCity(self, n: int, edges: List[List[int]], threshold: int) -> int:\n        maxi = int(1e9)\n        matrix = [[maxi for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    matrix[i][j] = 0\n        for u, v, wt in edges:\n            matrix[u][v] = matrix[v][u] = wt\n        for k in range(n):\n            for u in range(n):\n                for v in range(n):\n                    matrix[u][v] = min(matrix[u][v], matrix[u][k] + matrix[k][v])\n        cnt = [0 for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] <= threshold:\n                    cnt[i] += 1\n        res = min(cnt)\n        ans = 0\n        for i, item in enumerate(cnt):\n            if item == res:\n                ans = i\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_directed-graph-cycle-dfs",
    "title": "Directed Graph Cycle Dfs",
    "file_path": "Step 15 - Graphs/DIRECTED-GRAPH-CYCLE-DFS.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Hard",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Recursion"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def isCyclic(self, n: int, adj: List[List[int]]) -> bool:\n        isVisited = [0 for _ in range(n)]\n        isSamePath = [0 for _ in range(n)]\n\n        def dfs(node: int) -> bool:\n            isVisited[node] = 1\n            isSamePath[node] = 1\n            for item in adj[node]:\n                # Return True when:\n                # already visited and same path\n                # not visited -> so visit and it returns True\n                if (isVisited[item] and isSamePath[item]) or (not isVisited[item] and dfs(item)):\n                    return True\n            isSamePath[node] = 0\n            return False\n\n        for i in range(n):\n            if not isVisited[i] and dfs(i):\n                return True\n        return False\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Return True when: already visited and same path not visited -> so visit and it returns True",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_min-multiplications-to-reach-end",
    "title": "Min Multiplications To Reach End",
    "file_path": "Step 15 - Graphs/MIN-MULTIPLICATIONS-TO-REACH-END.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def minimumMultiplications(self, arr: List[int], start: int, end: int) -> int:\n        mod = int(1e5)\n        count = [int(1e9) for _ in range(mod)]  # max we can reach upto (mod - 1) bcz we have to take mod\n        q = Queue()\n        q.put((0, start))\n        while not q.empty():\n            cnt, curr = q.get()\n            if curr == end:\n                return cnt\n            for i in arr:\n                t = (curr * i) % mod\n                if count[t] > cnt + 1:\n                    count[t] = cnt + 1\n                    q.put((count[t], t))\n        return -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_01-matrix",
    "title": "01 Matrix",
    "file_path": "Step 15 - Graphs/01-MATRIX.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        n = len(mat)\n        m = len(mat[0])\n        q = Queue()\n        row = [-1, 0, 1, 0]\n        col = [0, 1, 0, -1]\n        distance = [[int(1e9) for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if mat[i][j] == 0:\n                    q.put((i, j, 0))\n                    distance[i][j] = 0\n        while not q.empty():\n            i, j, dis = q.get()\n            for k in range(4):\n                ni = i + row[k]\n                nj = j + col[k]\n                if 0 <= ni < n and 0 <= nj < m and mat[ni][nj] == 1 and distance[ni][nj] > 1 + dis:\n                    q.put((ni, nj, dis + 1))\n                    distance[ni][nj] = 1 + dis\n        return distance\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_floyd-warshall",
    "title": "Floyd Warshall",
    "file_path": "Step 15 - Graphs/FLOYD-WARSHALL.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def shortest_distance(self, matrix: List[List[int]]):\n        n = len(matrix)\n        maxi = int(1e9)\n        # Modify the non-reachable edges (which are -1 by default)\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] == -1:\n                    matrix[i][j] = maxi\n                if i == j:  # distance from node to itself is zero always (important)\n                    matrix[i][j] = 0\n        # Calculating shortest distance b/w each pair of nodes\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j])\n        # Place -1 for the nodes which are unreachable from each other\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] == maxi:\n                    matrix[i][j] = -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Modify the non-reachable edges (which are -1 by default) Calculating shortest distance b/w each pair of nodes Place -1 for the nodes which are unreachable from each other",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_binary-maze-shortest-path",
    "title": "Binary Maze Shortest Path",
    "file_path": "Step 15 - Graphs/BINARY-MAZE-SHORTEST-PATH.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Medium",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import PriorityQueue\n\n\nclass Solution:\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        if grid[0][0] == 1 or grid[n - 1][m - 1] == 1:\n            return -1\n        distance = [[int(1e9) for _ in range(m)] for _ in range(n)]\n        row = [-1, -1, -1, 0, 1, 1, 1, 0]\n        col = [-1, 0, 1, 1, 1, 0, -1, -1]\n\n        def isValid(i: int, j: int) -> bool:\n            return 0 <= i < n and 0 <= j < m and grid[i][j] == 0\n\n        distance[0][0] = 1\n        pq = PriorityQueue()\n        pq.put((1, 0, 0))\n        while not pq.empty():\n            dist, i, j = pq.get()\n            if i == n - 1 and j == m - 1:\n                return dist\n            for k in range(8):\n                ni = i + row[k]\n                nj = j + col[k]\n                if isValid(ni, nj) and distance[ni][nj] > dist + 1:\n                    distance[ni][nj] = dist + 1\n                    pq.put((distance[ni][nj], ni, nj))\n        return -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_topological-sort-dfs",
    "title": "Topological Sort Dfs",
    "file_path": "Step 15 - Graphs/TOPOLOGICAL-SORT-DFS.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Stack",
      "Recursion"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def topoSort(self, n: int, adj: List[List[int]]):\n        isVisited = [0 for _ in range(n)]\n        stack = []\n\n        def dfs(node):\n            isVisited[node] = 1\n            for v in adj[node]:\n                if not isVisited[v]:\n                    dfs(v)\n            stack.append(node)\n\n        for i in range(n):\n            if not isVisited[i]:\n                dfs(i)\n\n        return stack[::-1]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal",
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_15_-_graphs_word-ladder-2",
    "title": "Word Ladder 2",
    "file_path": "Step 15 - Graphs/WORD-LADDER-2.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue",
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\nfrom collections import defaultdict, Counter\n\n\"\"\"\nBetter watch the video!\n\"\"\"\n\n\nclass Solution:\n    def findLadders(self, begin: str, end: str, wordlist: List[str]) -> List[List[str]]:\n        st = set(wordlist)\n        q = Queue()\n        q.put([begin])\n        used_on_level = [begin]\n        level = 0\n        ans = []\n        while not q.empty():\n            curr: List[str] = q.get()\n            if len(curr) > level:\n                level += 1\n                for item in used_on_level:\n                    st.discard(item)\n            word = curr[-1]\n            if word == end:\n                if len(ans) == 0:\n                    ans.append(curr)\n                elif len(ans[-1]) == len(curr):\n                    ans.append(curr)\n            for i in range(len(word)):\n                for c in range(ord('a'), ord('z') + 1):\n                    ch = chr(c)\n                    temp = word[:i] + ch + word[i + 1:]\n                    if temp in st:\n                        curr_copy = curr[:] + [temp]  # we need to create the copy bcz Python sucks here you know!\n                        q.put(curr_copy)\n                        used_on_level.append(temp)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Better watch the video!",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_shortest-path-ug",
    "title": "Shortest Path Ug",
    "file_path": "Step 15 - Graphs/SHORTEST-PATH-UG.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def shortestPath(self, edges: List[List[int]], n: int, m: int, src: int):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        distance = [int(1e9) for _ in range(n)]\n        q = Queue()\n        q.put(src)\n        distance[src] = 0\n        while not q.empty():\n            curr = q.get()\n            for item in adj[curr]:\n                item: int\n                if distance[item] > 1 + distance[curr]:\n                    distance[item] = 1 + distance[curr]\n                    q.put(item)\n        for i in range(n):\n            if distance[i] == int(1e9):\n                distance[i] = -1\n        return distance\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_word-ladder-1",
    "title": "Word Ladder 1",
    "file_path": "Step 15 - Graphs/WORD-LADDER-1.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue",
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict, Counter\nfrom queue import Queue\n\n\"\"\"\nBFS\n\"\"\"\n\n\nclass Solution:\n    def ladderLength(self, begin: str, end: str, wordList: List[str]) -> int:\n        mp = defaultdict(int, Counter(wordList))\n        if end not in mp:\n            return 0\n        distance = defaultdict(int, {item: int(1e9) for item in wordList})\n        \"\"\"\n        Use of distance is necessary because without it, it would be giving TLE. Why? -> Because we would be stuck in a\n        infinite queue where we would be always inserting the begin word in the queue again and again. But when we would\n        use a distance dictionary we would fix that issue!\n        \"\"\"\n        q = Queue()\n        q.put((begin, 1))\n        n = len(begin)\n        while not q.empty():\n            curr, dis = q.get()\n            if curr == end:\n                return dis\n            for i in range(n):\n                for c in range(ord('a'), ord('z') + 1):\n                    ch = chr(c)\n                    next = curr[:i] + ch + curr[i + 1:]\n                    if next in mp and distance[next] > dis + 1:\n                        q.put((next, dis + 1))\n                        distance[next] = dis + 1\n        return 0\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "BFS",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_topological-sort-bfs-kahns-algo",
    "title": "Topological Sort Bfs Kahns Algo",
    "file_path": "Step 15 - Graphs/TOPOLOGICAL-SORT-BFS-KAHNS-ALGO.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\"\"\"\nTopo Sort Using Kahn's Algo (BFS)\n\"\"\"\n\n\nclass Solution:\n    def topoSort(self, n: int, adj: List[List[int]]) -> List[int]:\n        q = Queue()\n        indegree = [0 for _ in range(n)]\n        for u in range(n):\n            for v in adj[u]:\n                indegree[v] += 1\n        for u in range(n):\n            if indegree[u] == 0:\n                q.put(u)\n        ans = []\n        while not q.empty():\n            curr = q.get()\n            ans.append(curr)\n            for v in adj[curr]:\n                indegree[v] -= 1\n                if indegree[v] == 0:\n                    q.put(v)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Topo Sort Using Kahn's Algo (BFS)",
    "hints": [
      "Consider DFS or BFS traversal",
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_15_-_graphs_operations-to-make-network-connected",
    "title": "Operations To Make Network Connected",
    "file_path": "Step 15 - Graphs/OPERATIONS-TO-MAKE-NETWORK-CONNECTED.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n'''\nConcept:\nNodes which have same parent are already connected so the edge between them would be counted as extra cable.\nAt last the number of ultimate parents (independent nodes) need to be connected together.\nSo we can connect 'n' nodes with 'n-1' cables.\n'''\n\n\nclass Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        dset = DisjointSet(n)\n        cables = len(connections)\n        req = extra = 0\n        for u, v in connections:\n            if dset.union_by_size(u, v):\n                extra += 1\n        for par, i in enumerate(dset.parent):\n            if par == i:\n                req += 1\n        return req - 1 if req - 1 <= extra else -1\n\n\nclass DisjointSet:\n    def __init__(self, n: int):\n        self.rank = [0 for _ in range(n)]  # for union-by-rank\n        self.size = [1 for _ in range(n)]  # for union-by-size\n        self.parent = [i for i in range(n)]\n\n    def find_parent(self, x: int) -> int:\n        if x == self.parent[x]:\n            return x\n        self.parent[x] = self.find_parent(self.parent[x])\n        return self.parent[x]\n\n    def union_by_rank(self, u: int, v: int) -> int:\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n        if pu == pv:  # if both are already connected\n            return None\n        if self.rank[pu] >= self.rank[pv]:\n            self.parent[pv] = pu\n            if self.rank[pu] == self.rank[pv]:\n                self.rank[pu] += 1\n        else:\n            self.parent[pu] = pv\n        return None\n\n    def union_by_size(self, u: int, v: int) -> None:\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n        if pu == pv:  # if both are already connected\n            return 1\n        if self.size[pu] >= self.size[pv]:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n        else:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        return 0\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Concept: Nodes which have same parent are already connected so the edge between them would be counted as extra cable. At last the number of ultimate parents (independent nodes) need to be connected together. So we can connect 'n' nodes with 'n-1' cables.",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_rotten-oranges",
    "title": "Rotten Oranges",
    "file_path": "Step 15 - Graphs/ROTTEN-ORANGES.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        q = Queue()\n        row = [-1, 0, 1, 0]\n        col = [0, 1, 0, -1]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 2:\n                    q.put((i, j, 0))\n                    grid[i][j] = 0\n        ans = 0\n        while not q.empty():\n            i, j, time = q.get()\n            ans = max(ans, time)\n            for k in range(4):\n                ni = i + row[k]\n                nj = j + col[k]\n                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:\n                    grid[ni][nj] = 0\n                    q.put((ni, nj, time + 1))\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    return -1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_account-merge",
    "title": "Account Merge",
    "file_path": "Step 15 - Graphs/ACCOUNT-MERGE.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\n\n# Just take hint from starting 2-3 lines and you would automatically understand that!\n# https://takeuforward.org/data-structure/accounts-merge-dsu-g-50/\n\n\nclass Solution:\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\n        n = len(accounts)\n        dset = DisjointSet(n)\n        mp = defaultdict()\n        for i in range(n):\n            for mail in accounts[i][1:]:\n                if mail in mp:\n                    u = mp[mail]\n                    v = i\n                    dset.union_by_rank(u, v)\n                else:\n                    mp[mail] = i\n        mails = defaultdict(set)\n        for i in range(n):\n            parent = dset.find_parent(i)\n            for mail in accounts[i][1:]:\n                mails[parent].add(mail)\n        ans = []\n        for key, value in mails.items():\n            curr = [accounts[key][0]]\n            curr.extend(sorted(list(value)))\n            ans.append(curr)\n        return ans\n\n\nclass DisjointSet:\n    def __init__(self, n: int):\n        self.rank = [0 for _ in range(n)]  # for union-by-rank\n        self.size = [1 for _ in range(n)]  # for union-by-size\n        self.parent = [i for i in range(n)]\n\n    def find_parent(self, x: int) -> int:\n        if x == self.parent[x]:\n            return x\n        self.parent[x] = self.find_parent(self.parent[x])\n        return self.parent[x]\n\n    def union_by_rank(self, u: int, v: int) -> None:\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n        if pu == pv:  # if both are already connected\n            return None\n        if self.rank[pu] >= self.rank[pv]:\n            self.parent[pv] = pu\n            if self.rank[pu] == self.rank[pv]:\n                self.rank[pu] += 1\n        else:\n            self.parent[pu] = pv\n        return None\n\n    def union_by_size(self, u: int, v: int) -> None:\n        pu = self.find_parent(u)\n        pv = self.find_parent(v)\n        if pu == pv:  # if both are already connected\n            return None\n        if self.size[pu] >= self.size[pv]:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n        else:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        return None\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Just take hint from starting 2-3 lines and you would automatically understand that! https://takeuforward.org/data-structure/accounts-merge-dsu-g-50/",
    "hints": [
      "Consider DFS or BFS traversal",
      "Consider the merge operation in merge sort"
    ]
  },
  {
    "id": "step_15_-_graphs_bellman-ford",
    "title": "Bellman Ford",
    "file_path": "Step 15 - Graphs/BELLMAN-FORD.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def bellman_ford(self, n: int, edges: List[List[int]], s: int):\n        maxi = int(1e8)  # given in problem to keep max limit as 1e8\n        distance = [maxi for _ in range(n)]\n        distance[s] = 0\n        # Bellman Ford's necessary (n-1) iterations\n        for i in range(n - 1):\n            for u, v, wt in edges:\n                if distance[u] != maxi and distance[v] > distance[u] + wt:\n                    distance[v] = distance[u] + wt\n        # One more iteration to check negative cycle\n        negative_cycle = False\n        for u, v, wt in edges:\n            if distance[u] != maxi and distance[v] > distance[u] + wt:\n                negative_cycle = True\n                break\n        return [-1] if negative_cycle else distance\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Bellman Ford's necessary (n-1) iterations One more iteration to check negative cycle",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_undirected-graph-cycle-bfs",
    "title": "Undirected Graph Cycle Bfs",
    "file_path": "Step 15 - Graphs/UNDIRECTED-GRAPH-CYCLE-BFS.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Hard",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Queue",
      "Recursion"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def isCycle(self, v: int, adj: List[List[int]]) -> bool:\n        isVisited = [0 for _ in range(v)]\n\n        def bfs(i: int) -> bool:\n            q = Queue()\n            q.put((i, -1))\n            isVisited[i] = 1\n            while not q.empty():\n                node, parent = q.get()\n                for item in adj[node]:\n                    if not isVisited[item]:\n                        isVisited[item] = 1\n                        q.put((item, node))\n                    else:\n                        if item != parent:\n                            return True\n            return False\n\n        for i in range(v):\n            if not isVisited[i] and bfs(i):\n                return True\n        return False",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_directed-graph-cycle-bfs",
    "title": "Directed Graph Cycle Bfs",
    "file_path": "Step 15 - Graphs/DIRECTED-GRAPH-CYCLE-BFS.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Hard",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "\"\"\"\nUsing Topo Sort Concept\n\"\"\"\nfrom typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def isCyclic(self, n: int, adj: List[List[int]]) -> bool:\n        indegree = [0 for _ in range(n)]\n        for u in range(n):\n            for v in adj[u]:\n                indegree[v] += 1\n        q = Queue()\n        for i in range(n):\n            if indegree[i] == 0:\n                q.put(i)\n        topo = []\n        while not q.empty():\n            node = q.get()\n            topo.append(node)\n            for v in adj[node]:\n                indegree[v] -= 1\n                if indegree[v] == 0:\n                    q.put(v)\n        return len(topo) != n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Using Topo Sort Concept",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_course-schedule-2",
    "title": "Course Schedule 2",
    "file_path": "Step 15 - Graphs/COURSE-SCHEDULE-2.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def findOrder(self, n: int, pre: List[List[int]]) -> List[int]:\n        ans = []\n        indegree = [0 for _ in range(n)]\n        adj = [[] for _ in range(n)]\n        for u, v in pre:\n            indegree[u] += 1\n            adj[v].append(u)\n        q = Queue()\n        for i in range(n):\n            if indegree[i] == 0:\n                q.put(i)\n        while not q.empty():\n            curr = q.get()\n            ans.append(curr)\n            for v in adj[curr]:\n                indegree[v] -= 1\n                if indegree[v] == 0:\n                    q.put(v)\n        return ans if len(ans) == n else []\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_network-delay",
    "title": "Network Delay",
    "file_path": "Step 15 - Graphs/NETWORK-DELAY.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import PriorityQueue\n\n\nclass Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        adj = [[] for _ in range(n + 1)]  # due to problem being given in 1-indexed nodes\n        for u, v, wt in times:\n            adj[u].append((v, wt))\n        pq = PriorityQueue()\n        pq.put((0, k))\n        time = [int(1e9) for _ in range(n + 1)]\n        time[k] = 0\n        while not pq.empty():\n            t, curr = pq.get()\n            for v, wt in adj[curr]:\n                if time[v] > t + wt:\n                    time[v] = t + wt\n                    pq.put((time[v], v))\n        ans = max(time[1:])\n        return ans if ans < int(1e9) else -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_course-schedule-1",
    "title": "Course Schedule 1",
    "file_path": "Step 15 - Graphs/COURSE-SCHEDULE-1.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import Queue\n\n\nclass Solution:\n    def canFinish(self, n: int, pre: List[List[int]]) -> bool:\n        adj = [[] for _ in range(n)]\n        indegree = [0 for _ in range(n)]\n        for u, v in pre:\n            adj[u].append(v)\n            indegree[v] += 1\n        q = Queue()\n        for i in range(n):\n            if indegree[i] == 0:\n                q.put(i)\n        ans = []\n        while not q.empty():\n            curr = q.get()\n            ans.append(curr)\n            for v in adj[curr]:\n                indegree[v] -= 1\n                if indegree[v] == 0:\n                    q.put(v)\n        return len(ans) == n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_surrounded-regions",
    "title": "Surrounded Regions",
    "file_path": "Step 15 - Graphs/SURROUNDED-REGIONS.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Recursion"
    ],
    "solution_code": "from typing import List\n\n\"\"\"\nInitiate those 'O's which are at border of the board and apply dfs from there to mark 'O's which would remain unchanged.\nRest all the cells would be captured in the final board!\n\"\"\"\n\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        row = [-1, 0, 1, 0]\n        col = [0, 1, 0, -1]\n\n        def dfs(i: int, j: int) -> None:\n            board[i][j] = -1\n            for k in range(4):\n                ni = i + row[k]\n                nj = j + col[k]\n                if 0 <= ni < n and 0 <= nj < m and board[ni][nj] == 'O':\n                    dfs(ni, nj)\n\n        n = len(board)\n        m = len(board[0])\n        for i in range(n):\n            for j in range(m):\n                if (i == 0 or i == n - 1 or j == 0 or j == m - 1) and board[i][j] == 'O':\n                    dfs(i, j)\n\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != -1:\n                    board[i][j] = 'X'\n                else:\n                    board[i][j] = 'O'\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Initiate those 'O's which are at border of the board and apply dfs from there to mark 'O's which would remain unchanged. Rest all the cells would be captured in the final board!",
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_15_-_graphs_flood-fill",
    "title": "Flood Fill",
    "file_path": "Step 15 - Graphs/FLOOD-FILL.py",
    "category": "Step 15 - Graphs",
    "step": "Step 15 - Graphs",
    "difficulty": "Easy",
    "patterns": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "concepts": [
      "Graph Traversal",
      "Recursion"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        curr_color = image[sr][sc]\n\n        if curr_color == color:  # Edge Case\n            return image\n\n        n = len(image)\n        m = len(image[0])\n        row = [-1, 0, 1, 0]\n        col = [0, 1, 0, -1]\n\n        def isValid(i, j):\n            return 0 <= i < n and 0 <= j < m and image[i][j] == curr_color\n\n        def dfs(i: int, j: int):\n            image[i][j] = color\n            for k in range(4):\n                ni = i + row[k]\n                nj = j + col[k]\n                if isValid(ni, nj):\n                    dfs(ni, nj)\n            return None\n\n        dfs(sr, sc)\n        return image\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider DFS or BFS traversal"
    ]
  },
  {
    "id": "step_02_-_sorting_techniques_bubble-sort",
    "title": "Bubble Sort",
    "file_path": "Step 02 - Sorting Techniques/BUBBLE-SORT.py",
    "category": "Step 02 - Sorting Techniques",
    "step": "Step 02 - Sorting Techniques",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "# ITERATIVE\nclass Solution:\n    # Function to sort the array using bubble sort algorithm.\n    def bubbleSort(self, arr, n):\n        flag = True  # flag introduces to counter the case when there's no swapping -> then the array is sorted\n        for i in range(n - 1, -1, -1):\n            if flag:\n                flag = False\n                for j in range(i):\n                    if arr[j] > arr[j + 1]:\n                        flag = True\n                        arr[j], arr[j + 1] = arr[j + 1], arr[j]\n        return arr\n\n\n# RECURSIVE\nclass Solution:\n    def bubbleSort(self, arr, n):\n        if n > 1:\n            for j in range(n-1):\n                if arr[j] > arr[j+1]:\n                    arr[j], arr[j+1] = arr[j+1], arr[j]\n            self.bubbleSort(arr, n-1)",
    "time_complexity": null,
    "space_complexity": null,
    "description": "ITERATIVE Function to sort the array using bubble sort algorithm. RECURSIVE",
    "hints": [
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_02_-_sorting_techniques_merge-sort",
    "title": "Merge Sort",
    "file_path": "Step 02 - Sorting Techniques/MERGE-SORT.py",
    "category": "Step 02 - Sorting Techniques",
    "step": "Step 02 - Sorting Techniques",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def merge(self, arr: List[int], l, m, r):\n        l1, l2 = l, m + 1\n        temp = []\n        while l1 <= m and l2 <= r:\n            if arr[l1] <= arr[l2]:\n                temp += [arr[l1]]\n                l1 += 1\n            else:\n                temp += [arr[l2]]\n                l2 += 1\n        temp.extend(arr[l1:m + 1])\n        temp.extend(arr[l2:r + 1])\n        arr[l:r + 1] = temp[:]\n\n    def mergeSort(self, arr: List[int], l, r):\n        if l >= r:\n            return\n        mid = (l + r) // 2\n        self.mergeSort(arr, l, mid)\n        self.mergeSort(arr, mid + 1, r)\n        self.merge(arr, l, mid, r)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about different sorting algorithms and their properties",
      "Consider the merge operation in merge sort"
    ]
  },
  {
    "id": "step_02_-_sorting_techniques_selection-sort",
    "title": "Selection Sort",
    "file_path": "Step 02 - Sorting Techniques/SELECTION-SORT.py",
    "category": "Step 02 - Sorting Techniques",
    "step": "Step 02 - Sorting Techniques",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def selectionSort(self, arr: List[int], n: int):\n        for i in range(n):\n            mini = i\n            for j in range(i, n):\n                if arr[j] < arr[mini]:\n                    mini = j\n            arr[i], arr[mini] = arr[mini], arr[i]\n        return arr\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_02_-_sorting_techniques_quick-sort",
    "title": "Quick Sort",
    "file_path": "Step 02 - Sorting Techniques/QUICK-SORT.py",
    "category": "Step 02 - Sorting Techniques",
    "step": "Step 02 - Sorting Techniques",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n# To understand the concept please dry run the code on arr = [4, 3, 1, 5, 2]\n# Only way to understand Quick Sort is using dry-run!\n\n\nclass Solution:\n    def quickSort(self, arr: List[int], low: int, high: int) -> None:\n        if low < high:\n            pi = self.partition(arr, low, high)\n\n            self.quickSort(arr, low, pi-1)\n            self.quickSort(arr, pi+1, high)\n\n    def partition(self, arr: List[int], low: int, high: int) -> int:\n        pivot = arr[low]  # consider the first element as the pivot element\n        i, j = low, high\n\n        while i < j:\n            while i < high and arr[i] <= pivot:\n                i += 1\n            while j > low and arr[j] > pivot:\n                j -= 1\n            if i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[low], arr[j] = arr[j], arr[low]\n\n        return j\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "To understand the concept please dry run the code on arr = [4, 3, 1, 5, 2] Only way to understand Quick Sort is using dry-run!",
    "hints": [
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_02_-_sorting_techniques_insertion-sort",
    "title": "Insertion Sort",
    "file_path": "Step 02 - Sorting Techniques/INSERTION-SORT.py",
    "category": "Step 02 - Sorting Techniques",
    "step": "Step 02 - Sorting Techniques",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def insertionSort(self, arr: List[int], n: int):\n        for i in range(1, n):\n            j = i\n            while j > 0 and arr[j-1] > arr[j]:\n                arr[j-1], arr[j] = arr[j], arr[j-1]\n                j -= 1\n        return arr\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_subseq-05-partn-with-given-diff",
    "title": "Subseq 05 Partn With Given Diff",
    "file_path": "Step 16 - Dynamic Programming/SUBSEQ-05-PARTN-WITH-GIVEN-DIFF.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def countPartitions(self, n: int, d: int, arr: List[int]) -> int:\n        total = sum(arr)\n        if total < d:  # not possible if partition_sum is greater than total sum of array\n            return 0\n        subs1 = total - d\n        if subs1 & 1:\n            return 0\n        else:\n            target = subs1 // 2  # s1 = (total + d)//2 and s2 = (total - d)//2\n            dp = [[-1 for _ in range(target + 1)] for _ in range(n)]\n\n            def memo(ind: int, rem: int) -> int:\n                if ind == n - 1:\n                    if rem == 0 and arr[ind] == 0:\n                        return 2\n                    elif rem == 0 or arr[ind] == rem:\n                        return 1\n                    else:\n                        return 0\n                if dp[ind][rem] != -1:\n                    return dp[ind][rem]\n                not_pick = memo(ind + 1, rem)\n                pick = 0\n                if arr[ind] <= rem:\n                    pick = memo(ind + 1, rem - arr[ind])\n                dp[ind][rem] = pick + not_pick\n                return dp[ind][rem]\n\n            return memo(0, target) % int(1e9 + 7)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_subseq-03-partition-arr-to-min-sum-diff",
    "title": "Subseq 03 Partition Arr To Min Sum Diff",
    "file_path": "Step 16 - Dynamic Programming/SUBSEQ-03-PARTITION-ARR-TO-MIN-SUM-DIFF.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\"\"\"\nSolution would work only when 0 <= arr[i]\n\"\"\"\n\n\nclass Solution:\n    def minimumDifference(self, nums: List[int]) -> int:\n        n = len(nums)\n        total = sum(nums)\n        dp = [[False for _ in range(total + 1)] for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = True\n        # print(dp)\n        dp[0][nums[0]] = True  # to handle the case when we have only one element\n        for i in range(1, n):\n            for j in range(total + 1):\n                not_take = dp[i - 1][j]\n                take = False\n                if j >= nums[i]:\n                    take = dp[i - 1][j - nums[i]]\n                dp[i][j] = take or not_take\n        for j in range(total // 2, -1, -1):\n            if dp[n - 1][j]:\n                return abs(j - (total - j))\n        return -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Solution would work only when 0 <= arr[i]",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_minimal-cost",
    "title": "Minimal Cost",
    "file_path": "Step 16 - Dynamic Programming/MINIMAL-COST.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def recursion(self, ind: int, arr: List[int], k: int, n: int):\n        if ind == 0:\n            return 0\n        mini = int(1e9)\n        for i in range(1, k + 1):\n            if ind - i >= 0:\n                mini = min(mini, abs(arr[ind] - arr[ind - i]) + self.recursion(ind - i, arr, k, n))\n        return mini\n\n    def minimizeCost(self, arr: List[int], k: int):\n        n = len(arr)\n\n        dp = [-1 for _ in range(n)]\n\n        def memoization(ind: int):\n            if ind == 0:\n                return 0\n            if dp[ind] != -1:\n                return dp[ind]\n            mini = int(1e9)\n            for i in range(1, k + 1):\n                if ind - i >= 0:\n                    mini = min(mini, abs(arr[ind] - arr[ind - i]) + memoization(ind - i))\n            dp[ind] = mini\n            return mini\n\n        def tabulation():\n            dpp = [0 for _ in range(n)]\n            dpp[0] = 0\n            dpp[1] = abs(arr[1] - arr[0])\n            for i in range(2, n):\n                mini = int(1e9)\n                for j in range(1, k+1):\n                    if i - j >= 0:\n                        mini = min(mini, abs(arr[i-j] - arr[i]) + dpp[i - j])\n                dpp[i] = mini\n            return dpp[n - 1]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_choco-pickup",
    "title": "Choco Pickup",
    "file_path": "Step 16 - Dynamic Programming/CHOCO-PICKUP.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def solve(self, n: int, m: int, grid: List[List[int]]):\n\n        def out_of_bounds(j):\n            return j < 0 or j >= m\n\n        def recursion(i1, i2, j1, j2) -> int:\n            if out_of_bounds(j1) or out_of_bounds(j2):\n                return 0\n            if i1 == n - 1 or i2 == n - 1:\n                if j1 == j2:\n                    return grid[i1][j1]\n                else:\n                    return grid[i1][j1] + grid[i2][j2]\n            maxi = 0\n            for k1 in range(-1, 2):\n                for k2 in range(-1, 2):\n                    if j1 == j2:\n                        maxi = max(maxi, grid[i1][j1] + recursion(i1 + 1, i2 + 1, j1 + k1, j2 + k2))\n                    else:\n                        maxi = max(maxi, grid[i1][j1] + grid[i2][j2] + recursion(i1 + 1, i2 + 1, j1 + k1, j2 + k2))\n            return maxi\n\n        # return recursion(0, 0, 0, m - 1)\n\n        dp = [[[-1 for _ in range(m)] for _ in range(m)] for _ in range(n)]\n\n        # since i1 and i2  would always be same bcz both the robots would always be at the same level! -> 3d DP\n        def memoization(i, j1, j2) -> int:\n            if out_of_bounds(j1) or out_of_bounds(j2):\n                return 0\n            if dp[i][j1][j2] != -1:\n                return dp[i][j1][j2]\n            if i == n - 1:\n                if j1 == j2:\n                    return grid[i][j1]\n                else:\n                    return grid[i][j1] + grid[i][j2]\n            maxi = 0\n            for k1 in range(-1, 2):\n                for k2 in range(-1, 2):\n                    if j1 == j2:\n                        maxi = max(maxi, grid[i][j1] + memoization(i + 1, j1 + k1, j2 + k2))\n                    else:\n                        maxi = max(maxi, grid[i][j1] + grid[i][j2] + memoization(i + 1, j1 + k1, j2 + k2))\n            dp[i][j1][j2] = maxi\n            return maxi\n\n        return memoization(0, 0, m - 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "return recursion(0, 0, 0, m - 1) since i1 and i2  would always be same bcz both the robots would always be at the same level! -> 3d DP",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_stocks-6",
    "title": "Stocks 6",
    "file_path": "Step 16 - Dynamic Programming/STOCKS-6.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\"\"\"\nIntroduced a txn fee on selling stocks. So just subtract that fee from the profit when selling.\n\"\"\"\n\n\nclass Solution:\n    def maxProfit(self, prices: List[int], fee: int) -> int:\n        n = len(prices)\n        dp = [[-1 for _ in range(2)] for _ in range(n)]\n\n        def memo(ind: int, buy_stats: int) -> int:\n            if ind >= n:\n                return 0\n            if dp[ind][buy_stats] != -1:\n                return dp[ind][buy_stats]\n            maxi = 0\n            profit1 = profit2 = profit3 = profit4 = 0\n            if buy_stats:\n                profit1 = -prices[ind] + memo(ind + 1, 0)\n                profit2 = memo(ind + 1, buy_stats)\n            else:\n                profit3 = prices[ind] - fee + memo(ind + 1, 1)\n                profit4 = 0 + memo(ind + 1, buy_stats)\n            maxi = max(maxi, profit1, profit2, profit3, profit4)\n            dp[ind][buy_stats] = maxi\n            return maxi\n\n        return memo(0, 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Introduced a txn fee on selling stocks. So just subtract that fee from the profit when selling.",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_shortest-common-superseq",
    "title": "Shortest Common Superseq",
    "file_path": "Step 16 - Dynamic Programming/SHORTEST-COMMON-SUPERSEQ.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "class Solution:\n    def shortestCommonSupersequence(self, s: str, t: str) -> str:\n        n = len(s)\n        m = len(t)\n        # tabulation part -> calculate dp array ->\n        dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = 1 + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        ans = \"\"\n        i = n\n        j = m\n        # string formation part\n        while i > 0 and j > 0:\n            if s[i - 1] == t[j - 1]:\n                ans += s[i - 1]\n                i -= 1\n                j -= 1\n            else:\n                if dp[i - 1][j] >= dp[i][j - 1]:\n                    ans += s[i - 1]\n                    i -= 1\n                else:\n                    ans += t[j - 1]\n                    j -= 1\n        while i > 0:\n            ans += s[i - 1]\n            i -= 1\n        while j > 0:\n            ans += t[j - 1]\n            j -= 1\n        ans = ans[::-1]\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "tabulation part -> calculate dp array -> string formation part",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_subseq-09-knapsack",
    "title": "Subseq 09 Knapsack",
    "file_path": "Step 16 - Dynamic Programming/SUBSEQ-09-KNAPSACK.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def knapSack(self, n: int, w: int, val: List[int], wt: List[int]):\n        dp = [[-1 for _ in range(w + 1)] for _ in range(n)]\n\n        def tabulation():\n            pass\n\n        def memo(ind: int, rem: int) -> int:\n            if ind == n or rem == 0:\n                return 0\n            if dp[ind][rem] != -1:\n                return dp[ind][rem]\n            notpick = memo(ind + 1, rem)\n            pick = 0\n            if wt[ind] <= rem:\n                pick = val[ind] + memo(ind, rem - wt[ind])\n            dp[ind][rem] = max(pick, notpick)\n            return dp[ind][rem]\n\n        return memo(0, w)\n\n\n\"\"\"\nDont know whats wrong with gfg but it gives error while executing correct code.\nIt has occurred to me multiple times that it continuously gives error while\nexecuting memoization code.\n\"\"\"\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Dont know whats wrong with gfg but it gives error while executing correct code. It has occurred to me multiple times that it continuously gives error while executing memoization code.",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_stocks-4",
    "title": "Stocks 4",
    "file_path": "Step 16 - Dynamic Programming/STOCKS-4.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Stack",
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\"\"\"\nCan do at most k transactions and cant hold more than one stack at a time!\nHint: Exactly similar to Stocks 3, just here cap = k\n\"\"\"\n\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[[-1 for _ in range(2)] for _ in range(k)] for _ in range(n)]\n\n        def memo(ind: int, buy_stat: int, cap: int) -> int:\n            if cap < 0 or ind >= n:\n                return 0\n            if dp[ind][cap][buy_stat] != -1:\n                return dp[ind][cap][buy_stat]\n            maxi = 0\n            profit1 = profit2 = profit3 = profit4 = 0\n            if buy_stat:\n                profit1 = -prices[ind] + memo(ind + 1, 0, cap)\n                profit2 = memo(ind + 1, buy_stat, cap)\n            else:\n                profit3 = prices[ind] + memo(ind + 1, 1, cap - 1)\n                profit4 = 0 + memo(ind + 1, buy_stat, cap)\n            maxi = max(profit1, profit2, profit3, profit4)\n            dp[ind][cap][buy_stat] = maxi\n            return maxi\n\n        return memo(0, 1, k - 1)\n        # cap = 1 bcz we shifted origin for cap which now can be 0 or 1 as to accommodate in dp\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Can do at most k transactions and cant hold more than one stack at a time! Hint: Exactly similar to Stocks 3, just here cap = k",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_stocks-5",
    "title": "Stocks 5",
    "file_path": "Step 16 - Dynamic Programming/STOCKS-5.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\"\"\"\nBuy and sell stock as many as you want but hold only one stock at a time, and after selling a\nstock cooldown period is 1 day i.e., you have to wait one day before buying another stock!\n\"\"\"\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[-1 for _ in range(2)] for _ in range(n)]\n\n        def memo(ind: int, buy_stats: int) -> int:\n            if ind >= n:\n                return 0\n            if dp[ind][buy_stats] != -1:\n                return dp[ind][buy_stats]\n            maxi = 0\n            profit1 = profit2 = profit3 = profit4 = 0\n            if buy_stats:\n                profit1 = -prices[ind] + memo(ind + 1, 0)\n                profit2 = memo(ind + 1, buy_stats)\n            else:\n                profit3 = prices[ind] + memo(ind + 2, 1)\n                profit4 = 0 + memo(ind + 1, buy_stats)\n            maxi = max(maxi, profit1, profit2, profit3, profit4)\n            dp[ind][buy_stats] = maxi\n            return maxi\n\n        return memo(0, 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Buy and sell stock as many as you want but hold only one stock at a time, and after selling a stock cooldown period is 1 day i.e., you have to wait one day before buying another stock!",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_stocks-2",
    "title": "Stocks 2",
    "file_path": "Step 16 - Dynamic Programming/STOCKS-2.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\"\"\"\nCan buy multiple stocks but can hold only one at a time.\n\"\"\"\n\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        buy = -1\n        profit = 0\n        n = len(prices)\n        i = 0\n        while i < n:\n            if buy == -1:\n                while i + 1 < n and prices[i + 1] <= prices[i]:\n                    i += 1\n                buy = prices[i]\n            else:\n                while i + 1 < n and prices[i + 1] >= prices[i]:\n                    i += 1\n                if i < n:\n                    profit += (prices[i] - buy)\n                    buy = -1\n            i += 1\n        return profit\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Can buy multiple stocks but can hold only one at a time.",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_subseq-08-coin-change2",
    "title": "Subseq 08 Coin Change2",
    "file_path": "Step 16 - Dynamic Programming/SUBSEQ-08-COIN-CHANGE2.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        n = len(coins)\n        dp = [[-1 for _ in range(amount + 1)] for _ in range(n)]\n        m = int(1e9)\n\n        def tabulation():\n            dpp = [[0 for _ in range(amount + 1)] for _ in range(n)]\n            for i in range(amount + 1):\n                dpp[0][i] = i // coins[0] if i % coins[0] == 0 else m\n            for i in range(1, n):\n                for j in range(amount + 1):\n                    not_take = dpp[i - 1][j]\n                    take = m\n                    if coins[i] <= j:\n                        take = 1 + dpp[i][j - coins[i]]\n                    dpp[i][j] = min(not_take, take)\n            return dpp[n - 1][amount]\n\n        def memo(ind: int, rem: int) -> int:\n            if ind == n:\n                return 1 if rem == 0 else 0\n            if rem == 0:\n                return 1\n            if dp[ind][rem] != -1:\n                return dp[ind][rem]\n            notpick = memo(ind + 1, rem)\n            pick = 0\n            if coins[ind] <= rem:\n                pick = memo(ind, rem - coins[ind])\n            dp[ind][rem] = pick + notpick\n            return dp[ind][rem]\n\n        ans = memo(0, amount)\n        return -1 if ans == m else ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_subseq-04-count-subset-eq-to-given-sum",
    "title": "Subseq 04 Count Subset Eq To Given Sum",
    "file_path": "Step 16 - Dynamic Programming/SUBSEQ-04-COUNT-SUBSET-EQ-TO-GIVEN-SUM.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def perfectSum(self, arr: List[int], n: int, target: int):\n        def tabulation():\n            dp = [[0 for _ in range(target + 1)] for _ in range(n+1)]\n            for i in range(n+1):\n                dp[i][0] = 1\n            if arr[0] <= target:\n                dp[1][arr[0]] = 1\n            for i in range(1, n+1):\n                for j in range(1, target + 1):\n                    not_taken = dp[i - 1][j]\n                    taken = 0\n                    if arr[i-1] <= j:\n                        taken = dp[i - 1][j - arr[i-1]]\n                    dp[i][j] = taken + not_taken\n            return dp[n][target]\n\n        return tabulation()\n\n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_climbing-stairs",
    "title": "Climbing Stairs",
    "file_path": "Step 16 - Dynamic Programming/CLIMBING-STAIRS.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "class Solution:\n    def recursion(self, ind: int, n: int):\n        if ind > n:\n            return 0\n        if ind == n:\n            return 1\n        choice1 = self.recursion(ind + 1, n)\n        choice2 = self.recursion(ind + 2, n)\n        return choice1 + choice2\n\n    def climbStairs(self, n: int) -> int:\n        dp = [-1 for _ in range(n)]\n\n        def memo(ind: int):\n            if ind > n:\n                return 0\n            if ind == n:\n                return 1\n            if dp[ind] != -1:\n                return dp[ind]\n\n            choice1 = memo(ind + 1)\n            choice2 = memo(ind + 2)\n            dp[ind] = choice1 + choice2\n            return dp[ind]\n\n        def tabulation():\n            dpp = [0 for _ in range(n + 1)]\n            dpp[0] = dpp[1] = 1\n            for i in range(2, n + 1):\n                dpp[i] = dpp[i - 1] + dpp[i - 2]\n            return dpp[n]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_subseq-07-target-sum",
    "title": "Subseq 07 Target Sum",
    "file_path": "Step 16 - Dynamic Programming/SUBSEQ-07-TARGET-SUM.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [[-1 for _ in range(2001)] for _ in range(n)]\n        # 2001 bcz we need to have target + sum(arr) + 1 columns in dp to accomodate all the possible sums\n        #/ and its upper limit acc to ques is 2000\n\n        def memo(ind: int, rem: int):\n            if ind == n:\n                return 1 if rem == 0 else 0\n            if dp[ind][rem] != -1:\n                return dp[ind][rem]\n            plus = memo(ind + 1, rem - nums[ind])\n            mins = memo(ind + 1, rem + nums[ind])\n            dp[ind][rem] = plus + mins\n            return dp[ind][rem]\n\n        return memo(0, target)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "2001 bcz we need to have target + sum(arr) + 1 columns in dp to accomodate all the possible sums / and its upper limit acc to ques is 2000",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_longest-palindromic-subseq",
    "title": "Longest Palindromic Subseq",
    "file_path": "Step 16 - Dynamic Programming/LONGEST-PALINDROMIC-SUBSEQ.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        n = len(s)\n\n        def tabulation_lcs():\n            s1 = s\n            s2 = s[::-1]\n            dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n            for i in range(1, n + 1):\n                for j in range(1, n + 1):\n                    if s1[i] == s2[j]:\n                        dp[i][j] = 1 + dp[i - 1][j - 1]\n                    else:\n                        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n            return dp[n][n]\n\n        return tabulation_lcs()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_subseq-06-coin-change",
    "title": "Subseq 06 Coin Change",
    "file_path": "Step 16 - Dynamic Programming/SUBSEQ-06-COIN-CHANGE.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n# This problem was asked to me in my Info Edge Interview Round 1. But I was also asked to print all the denominations which\n# are included in the answer!\n\n# Standard Problem\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        dp = [[-1 for _ in range(amount + 1)] for _ in range(n)]\n\n        def tabulation():\n            dpp = [[0 for _ in range(amount+1)] for _ in range(n)]\n            for i in range(amount + 1):\n                dpp[0][i] = i // coins[0] if i % coins[0] == 0 else int(1e9)\n            for i in range(1, n):\n                for amt in range(amount + 1):\n                    not_take = dpp[i-1][amt]\n                    take = int(1e9)\n                    if coins[i] <= amt:\n                        take = 1 + dpp[i][amt - coins[i]]\n                    dpp[i][amt] = min(take, not_take)\n            \n            # Printing the denominatons which we are taking to make our amount!\n            ans = []\n            i = n - 1\n            j = amount\n            res = dpp[n-1][amount]\n            if res < int(1e9):\n                while i >= 0 and j > 0:\n                    if i > 0 and dpp[i-1][j] == dpp[i][j]:\n                        i -= 1\n                    elif dpp[i][j - coins[i]] + 1 == dpp[i][j]:\n                        ans.append(coins[i])\n                        j -= coins[i]\n                print(ans)\n            return res\n            \n\n        def memo(i: int, rem: int) -> int:\n            if rem == 0:\n                return 0\n            if i >= n:\n                return int(1e9)\n            if dp[i][rem] != -1:\n                return dp[i][rem]\n            op1 = op2 = int(1e9)\n            if coins[i] <= rem:\n                op1 = 1 + memo(i, rem - coins[i])\n            op2 = 0 + memo(i+1, rem)\n            dp[i][rem] = min(op1, op2)\n            return dp[i][rem]\n        ans = tabulation()\n        return ans if ans < int(1e9) else -1\n\n# Standard Problem with Tweaks -> Print All the Denominations That You Are Taking!\n\nobj = Solution()\ncoins = list(map(int, input().split()))\namount = int(input())\nprint(obj.coinChange(coins, amount))",
    "time_complexity": null,
    "space_complexity": null,
    "description": "This problem was asked to me in my Info Edge Interview Round 1. But I was also asked to print all the denominations which are included in the answer! Standard Problem Printing the denominatons which we are taking to make our amount! Standard Problem with Tweaks -> Print All the Denominations That You Are Taking!",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_subseq-01-subset-sum-problem",
    "title": "Subseq 01 Subset Sum Problem",
    "file_path": "Step 16 - Dynamic Programming/SUBSEQ-01-SUBSET-SUM-PROBLEM.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def isSubsetSum(self, n: int, arr: List[int], target: int):\n        dp = [[-1 for _ in range(target + 1)] for _ in range(n)]\n\n        def memo(ind: int, rem: int) -> bool:\n            if ind == n:\n                return True if rem == 0 else False\n            if rem == 0:\n                return True\n            if dp[ind][rem] != -1:\n                return bool(dp[ind][rem])\n            pick = notpick = 0\n            if arr[ind] <= rem:\n                pick = memo(ind + 1, rem - arr[ind])\n            notpick = memo(ind + 1, rem)\n            dp[ind][rem] = pick or notpick\n            return bool(dp[ind][rem])\n\n        def tabulation():\n            dpp = [[False for _ in range(target + 1)] for _ in range(n)]\n            for i in range(n):\n                dpp[i][0] = True\n            if arr[0] <= target:\n                dpp[0][arr[0]] = True\n            for level in range(1, n):\n                for summ in range(1, target + 1):\n                    notpick = dpp[level - 1][summ]\n                    pick = False\n                    if arr[level] <= summ:\n                        pick = dpp[level - 1][summ - arr[level]]\n                    dpp[level][summ] = pick or notpick\n            return dpp[n - 1][target]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_lis-02-print-lis",
    "title": "Lis 02 Print Lis",
    "file_path": "Step 16 - Dynamic Programming/LIS-02-PRINT-LIS.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\"\"\"\nTrace back the dp (2D) array\n\"\"\"\n\n\nclass Solution:\n    def longestIncreasingSubsequence(self, n: int, arr: List[int]):\n        dp = [1 for _ in range(n)]\n        last = [-1 for _ in range(n)]\n        for curr in range(1, n):\n            for prev in range(curr):\n                if arr[curr] > arr[prev] and dp[curr] < dp[prev] + 1:\n                    dp[curr] = dp[prev] + 1\n                    last[curr] = prev\n        res = maxi = 0\n        for i, lis in enumerate(dp):\n            if lis > maxi:\n                maxi = lis\n                res = i\n        ans = []\n        while res != -1:\n            ans.append(arr[res])\n            res = last[res]\n        return reversed(ans)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Trace back the dp (2D) array",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_mcm-01-mcm",
    "title": "Mcm 01 Mcm",
    "file_path": "Step 16 - Dynamic Programming/MCM-01-MCM.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def matrixMultiplication(self, n: int, arr: List[int]):\n        dp = [[-1 for _ in range(n)] for _ in range(n)]\n\n        def memo(i: int, j: int) -> int:\n            if i == j:\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            res = sys.maxsize\n            for k in range(i, j):\n                steps = (arr[i - 1] * arr[k] * arr[j]) + memo(i, k) + memo(k + 1, j)\n                res = min(steps, res)\n            dp[i][j] = res\n            return res\n\n        return memo(1, n - 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_subseq-10-rod-cutting",
    "title": "Subseq 10 Rod Cutting",
    "file_path": "Step 16 - Dynamic Programming/SUBSEQ-10-ROD-CUTTING.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def cutRod(self, price: List[int], n: int):\n        dp = [[-1 for _ in range(n + 1)] for _ in range(n)]\n\n        def memo(i: int, rem: int) -> int:\n            if i == n or rem == 0:\n                return 0\n            if dp[i][rem] != -1:\n                return dp[i][rem]\n            notpick = 0 + memo(i + 1, rem)\n            pick = 0\n            if i + 1 <= rem:\n                pick = price[i] + memo(i, rem - (i + 1))\n            dp[i][rem] = max(pick, notpick)\n            return dp[i][rem]\n\n        return memo(0, n)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_delete-operationg-make-string-same",
    "title": "Delete Operationg Make String Same",
    "file_path": "Step 16 - Dynamic Programming/DELETE-OPERATIONG-MAKE-STRING-SAME.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "\"\"\"\nFollowed Up From: MIN-INSERTIONS-TO-MAKE-STRING-PALINDROME\n\"\"\"\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        def lcs(s1: str, s2: str) -> int:\n            n = len(s1)\n            m = len(s2)\n            dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n            for i in range(1, n + 1):\n                for j in range(1, m + 1):\n                    if s1[i - 1] == s2[j - 1]:\n                        dp[i][j] = dp[i - 1][j - 1] + 1\n                    else:\n                        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n            return dp[n][m]\n\n        rem = lcs(word1, word2)\n        ans = len(word1) + len(word2) - 2 * rem\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Followed Up From: MIN-INSERTIONS-TO-MAKE-STRING-PALINDROME",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_longest-common-subseq",
    "title": "Longest Common Subseq",
    "file_path": "Step 16 - Dynamic Programming/LONGEST-COMMON-SUBSEQ.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "\"\"\"\nSimilar to DP on LIS, here also tabulation approach would be more intuitive and helpful in solving other problems!\n\"\"\"\n\n\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        n = len(text1)\n        m = len(text2)\n\n        dp = [[-1 for _ in range(m)] for _ in range(n)]\n\n        def tabulation():\n            dpp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n            for i in range(1, n + 1):\n                for j in range(1, m + 1):\n                    if text1[i - 1] == text2[j - 1]:\n                        dpp[i][j] = 1 + dpp[i - 1][j - 1]\n                    else:\n                        dpp[i][j] = max(dpp[i - 1][j], dpp[i][j - 1])\n            return dpp[n][m]\n\n        def memoization(i: int, j: int) -> int:\n            if i >= n or j >= m:\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            not_pick = pick = 0\n            if text1[i] == text2[j]:\n                pick = 1 + memoization(i + 1, j + 1)\n            else:\n                case1 = 0 + memoization(i + 1, j)\n                case2 = 0 + memoization(i, j + 1)\n                not_pick = max(case1, case2)\n            dp[i][j] = max(pick, not_pick)\n            return dp[i][j]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Similar to DP on LIS, here also tabulation approach would be more intuitive and helpful in solving other problems!",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_lis-04-number-lis",
    "title": "Lis 04 Number Lis",
    "file_path": "Step 16 - Dynamic Programming/LIS-04-NUMBER-LIS.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def findNumberOfLIS(self, arr: List[int]):\n        n = len(arr)\n        dp = [1 for _ in range(n)]\n        count = [1 for _ in range(n)]\n        for i in range(1, n):\n            maxi = 0\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    if dp[i] < dp[j] + 1:\n                        dp[i] = dp[j] + 1\n                        maxi = max(maxi, dp[i])\n                        count[i] = count[j]\n                    elif maxi == dp[j] + 1:\n                        count[i] += count[j]\n        # array contains duplicate elements!\n        maxxi = max(dp)\n        print(dp, count)\n        ans = 0\n        for i in range(n):\n            if dp[i] == maxxi:\n                ans += count[i]\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "array contains duplicate elements!",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_distinct-subseq",
    "title": "Distinct Subseq",
    "file_path": "Step 16 - Dynamic Programming/DISTINCT-SUBSEQ.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        n = len(s)\n        m = len(t)\n        dp = [[-1 for _ in range(m)] for _ in range(n)]\n\n        def memo(i: int, j: int) -> int:\n            if j >= m:\n                return 1\n            if i >= n:\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            res = 0\n            if s[i] == t[j]:\n                pick = memo(i + 1, j + 1)\n                notPick = memo(i + 1, j)\n                res = pick + notPick\n            else:\n                res = memo(i + 1, j)\n            dp[i][j] = res\n            return res\n\n        return memo(0, 0)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_burst-balloon-02",
    "title": "Burst Balloon 02",
    "file_path": "Step 16 - Dynamic Programming/BURST-BALLOON-02.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n# https://leetcode.com/problems/burst-balloons/description/\n# [MCM DP]\n\n\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums = [1] + nums + [1]\n        dp = [[-1 for _ in range(n+2)] for _ in range(n+2)]\n\n        def solver(i: int, j: int) -> int:\n            if i > j:\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            maxi = 0\n            for index in range(i, j+1):\n                curr = nums[i-1] * nums[index] * nums[j+1] + \\\n                    solver(i, index-1) + solver(index+1, j)\n                maxi = max(maxi, curr)\n            dp[i][j] = maxi\n            return maxi\n        return solver(1, n)\n\n\ndef main():\n    obj = Solution()\n    nums = list(map(int, input().split()))\n    print(obj.maxCoins(nums))\n\n\nif __name__ == '__main__':\n    main()\n\n\n# VERDICT : AC",
    "time_complexity": null,
    "space_complexity": null,
    "description": "https://leetcode.com/problems/burst-balloons/description/ [MCM DP] VERDICT : AC",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_subseq-02-partition-equal-subset-sum",
    "title": "Subseq 02 Partition Equal Subset Sum",
    "file_path": "Step 16 - Dynamic Programming/SUBSEQ-02-PARTITION-EQUAL-SUBSET-SUM.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        target = sum(nums)\n        if target & 1:\n            return False\n        else:\n            target //= 2\n\n            def tabulation():\n                n = len(nums)\n                dp = [[False for _ in range(target + 1)] for _ in range(n)]\n                for i in range(n):\n                    dp[i][0] = True\n                if nums[0] <= target:\n                    dp[0][nums[0]] = True\n                for i in range(1, n):\n                    for summ in range(1, target + 1):\n                        notpick = dp[i - 1][summ]\n                        pick = False\n                        if nums[i] <= summ:\n                            pick = dp[i - 1][summ - nums[i]]\n                        dp[i][summ] = pick or notpick\n                return dp[n - 1][target]\n\n            return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_min-path-sum-triangle",
    "title": "Min Path Sum Triangle",
    "file_path": "Step 16 - Dynamic Programming/MIN-PATH-SUM-TRIANGLE.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        n = len(triangle)\n        m = len(triangle[-1])\n        dp = [[-1 for _ in range(m)] for _ in range(n)]\n\n        def memo(i: int, j: int) -> int:\n            if j >= m:\n                return sys.maxsize\n            if i == n - 1:\n                return triangle[i][j]\n            if dp[i][j] != -1:\n                return dp[i][j]\n            op1 = triangle[i][j] + memo(i + 1, j)\n            op2 = triangle[i][j] + memo(i + 1, j + 1)\n            dp[i][j] = min(op1, op2)\n            return dp[i][j]\n\n        def tabulation():\n            dpp = [[sys.maxsize for _ in range(m + 1)] for _ in range(n)]\n            dpp[0][1] = triangle[0][0]\n            for i in range(1, n):\n                for j in range(1, i+2):\n                    print(i, j)\n                    dpp[i][j] = triangle[i][j-1] + min(dpp[i - 1][j - 1], dpp[i - 1][j])\n            return min(dpp[-1])\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_lis-03-largest-div-subset",
    "title": "Lis 03 Largest Div Subset",
    "file_path": "Step 16 - Dynamic Programming/LIS-03-LARGEST-DIV-SUBSET.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        nums.sort()  # we need to sort since the problem asks about Subset and not Subseq\n        dp = [1 for _ in range(n)]\n        prev = [-1 for _ in range(n)]\n        index = 0\n        maxi = 0\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1:\n                    prev[i] = j\n                    dp[i] = dp[j] + 1\n                    if maxi < dp[i]:\n                        maxi = dp[i]\n                        index = i\n        ans = []\n        while index != -1:\n            ans.append(nums[index])\n            index = prev[index]\n        return list(reversed(ans))\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_min-insertions-to-make-string-palindrome",
    "title": "Min Insertions To Make String Palindrome",
    "file_path": "Step 16 - Dynamic Programming/MIN-INSERTIONS-TO-MAKE-STRING-PALINDROME.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "class Solution:\n    def minInsertions(self, s: str) -> int:\n        n = len(s)\n        t = s[::-1]\n        dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = 1 + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        res = dp[n][n]\n        return n - res\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems",
      "Palindromes read the same forwards and backwards"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_frog-jump",
    "title": "Frog Jump",
    "file_path": "Step 16 - Dynamic Programming/FROG-JUMP.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\nm = int(1e9)\n\n\nclass Solution:\n    def minimumEnergy(self, height: List[int], n: int):\n        dp = [-1 for _ in range(n)]\n\n        def memoization(ind: int):\n            if ind == 0:\n                return 0\n            if dp[ind] != -1:\n                return dp[ind]\n            choice1 = abs(height[ind - 1] - height[ind]) + memoization(ind - 1)\n            choice2 = m\n            if ind > 1:\n                choice2 = abs(height[ind - 2] - height[ind]) + memoization(ind - 2)\n            dp[ind] = min(choice1, choice2)\n            return dp[ind]\n\n        def tabulation(ind: int):\n            dpp = [0 for _ in range(n)]\n            dpp[0] = 0\n            if n > 1:\n                dpp[1] = abs(height[1] - height[0])\n            for i in range(2, n):\n                choice1 = abs(height[i] - height[i - 1]) + dpp[i - 1]\n                choice2 = abs(height[i] - height[i - 2]) + dpp[i - 2]\n                dpp[i] = min(choice1, choice2)\n            return dpp[n - 1]\n\n        return tabulation(n - 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_mcm-02-min-cost-to-cut-stick",
    "title": "Mcm 02 Min Cost To Cut Stick",
    "file_path": "Step 16 - Dynamic Programming/MCM-02-MIN-COST-TO-CUT-STICK.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "import sys\nfrom typing import List\n\n\"\"\"\nJust watch the video for explanation -> I think its very tough to actually\nvisualise the solution by just seeing the code or reading any article.\n\"\"\"\n\n\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        c = len(cuts)\n        dp = [[-1 for _ in range(c + 1)] for _ in range(c + 1)]\n        cuts = [0] + cuts + [n]\n        cuts.sort()\n\n        def memo(i, j):\n            if i > j:\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            mini = sys.maxsize\n            for ind in range(i, j + 1):\n                ans = cuts[j + 1] - cuts[i - 1] + memo(i, ind - 1) + memo(ind + 1, j)\n                mini = min(mini, ans)\n            dp[i][j] = mini\n            return mini\n\n        return memo(1, c)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Just watch the video for explanation -> I think its very tough to actually visualise the solution by just seeing the code or reading any article.",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_stocks-1",
    "title": "Stocks 1",
    "file_path": "Step 16 - Dynamic Programming/STOCKS-1.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\"\"\"\nCan buy and sell only one stock in the entire span.\n\"\"\"\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        profit = 0\n        buy = prices[0]\n        for price in prices[1:]:\n            if price < buy:\n                buy = price\n            elif price > buy:\n                profit = max(profit, price - buy)\n        return profit\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Can buy and sell only one stock in the entire span.",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_min-falling-path-sum",
    "title": "Min Falling Path Sum",
    "file_path": "Step 16 - Dynamic Programming/MIN-FALLING-PATH-SUM.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        lim = sys.maxsize\n        dp = [[-1 for _ in range(m)] for _ in range(n)]\n\n        def memo(i: int, j: int) -> int:\n            if i >= n or j >= m:\n                return lim\n            if (i, j) == (n - 1, m - 1):\n                return grid[i][j]\n            if dp[i][j] != -1:\n                return dp[i][j]\n            down = grid[i][j] + memo(i + 1, j)\n            right = grid[i][j] + memo(i, j + 1)\n            dp[i][j] = min(down, right)\n            return dp[i][j]\n\n        def tabulation():\n            dpp = [[0 for _ in range(m)] for _ in range(n)]\n            dpp[0][0] = grid[0][0]\n            for i in range(1, n):\n                dpp[i][0] = grid[i][0] + dpp[i - 1][0]\n            for j in range(1, m):\n                dpp[0][j] = grid[0][j] + dpp[0][j - 1]\n            for i in range(1, n):\n                for j in range(1, m):\n                    dpp[i][j] = grid[i][j] + min(dpp[i - 1][j], dpp[i][j - 1])\n            return dpp[n - 1][m - 1]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_dp-square-count-submatrics",
    "title": "Dp Square Count Submatrics",
    "file_path": "Step 16 - Dynamic Programming/DP-SQUARE-COUNT-SUBMATRICS.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Hard",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def countSquares(self, mat: List[List[int]]) -> int:\n        n = len(mat)\n        m = len(mat[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = mat[i][0]\n        for j in range(m):\n            dp[0][j] = mat[0][j]\n        for i in range(1, n):\n            for j in range(1, m):\n                if mat[i][j]:\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n        ans = 0\n        for i in range(n):\n            for j in range(m):\n                ans += dp[i][j]\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_edit-distance",
    "title": "Edit Distance",
    "file_path": "Step 16 - Dynamic Programming/EDIT-DISTANCE.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "class Solution:\n    def minDistance(self, s: str, t: str) -> int:\n        n = len(s)\n        m = len(t)\n        dp = [[-1 for _ in range(m)] for _ in range(n)]\n\n        def memo(i: int, j: int) -> int:\n            if i < 0:\n                return j + 1\n            if j < 0:\n                return i + 1\n            if dp[i][j] != -1:\n                return dp[i][j]\n            res = 0\n            if s[i] == t[j]:\n                res = memo(i - 1, j - 1)\n            else:\n                res = min(memo(i, j - 1), memo(i - 1, j), memo(i - 1, j - 1))  # insert, delete, replace\n            dp[i][j] = res\n            return res\n\n        return memo(n - 1, m - 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_lis-05-bitonic",
    "title": "Lis 05 Bitonic",
    "file_path": "Step 16 - Dynamic Programming/LIS-05-BITONIC.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def LongestBitonicSequence(self, n: int, nums: List[int]) -> int:\n\n        def helper(arr: List[int]):\n            dp = [1 for _ in range(n)]\n            for i in range(1, n):\n                for j in range(i):\n                    if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                        dp[i] = dp[j] + 1\n            return dp\n\n        lis1 = helper(nums)\n        lis2 = list(reversed(helper(nums[::-1])))\n        ans = 0\n        for i in range(n):\n            if lis1[i] > 1 and lis2[i] > 1:  # edge case: when we only have strictly inc or dec subsequence\n                ans = max(ans, lis1[i] + lis2[i] - 1)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_stocks-3",
    "title": "Stocks 3",
    "file_path": "Step 16 - Dynamic Programming/STOCKS-3.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Stack",
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\"\"\"\nCan do at most 2 transactions and cant hold more than one stack at a time!\n\"\"\"\n\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[[-1 for _ in range(2)] for _ in range(2)] for _ in range(n)]\n        \n        def memo(ind: int, buy_stat: int, cap: int) -> int:\n            if cap < 0 or ind >= n:\n                return 0\n            if dp[ind][cap][buy_stat] != -1:\n                return dp[ind][cap][buy_stat]\n            maxi = 0\n            profit1 = profit2 = profit3 = profit4 = 0\n            if buy_stat:\n                profit1 = -prices[ind] + memo(ind + 1, 0, cap)\n                profit2 = memo(ind + 1, buy_stat, cap)\n            else:\n                profit3 = prices[ind] + memo(ind + 1, 1, cap - 1)\n                profit4 = 0 + memo(ind + 1, buy_stat, cap)\n            maxi = max(profit1, profit2, profit3, profit4)\n            dp[ind][cap][buy_stat] = maxi\n            return maxi\n\n        return memo(0, 1, 1)\n        # cap = 1 bcz we shifted origin for cap which now can be 0 or 1 as to accommodate in dp\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Can do at most 2 transactions and cant hold more than one stack at a time!",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_print-longest-common-subseq",
    "title": "Print Longest Common Subseq",
    "file_path": "Step 16 - Dynamic Programming/PRINT-LONGEST-COMMON-SUBSEQ.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "\"\"\"\nPrints only one LCS\n\"\"\"\n\n\nclass Solution1:\n    def all_longest_common_subsequences(self, s: str, t: str):\n        n = len(s)\n        m = len(t)\n\n        def helper():\n            dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n            for i in range(1, n + 1):\n                for j in range(1, m + 1):\n                    if s[i - 1] == t[j - 1]:\n                        dp[i][j] = 1 + dp[i - 1][j - 1]\n                    else:\n                        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n            return dp\n\n        res = helper()\n        i, j = n, m\n        ans = \"\"\n        while i > 0 and j > 0:\n            if s[i - 1] == t[j - 1]:\n                ans += s[i - 1]\n                i -= 1\n                j -= 1\n            else:\n                if res[i - 1][j] > res[i][j - 1]:\n                    i -= 1\n                else:\n                    j -= 1\n\n        ans = ans[::-1]\n        return [ans]\n\n\n\"\"\"\nPrint all the LCS\n\"\"\"\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Prints only one LCS",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_lis-06-longest-string-chain",
    "title": "Lis 06 Longest String Chain",
    "file_path": "Step 16 - Dynamic Programming/LIS-06-LONGEST-STRING-CHAIN.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def longestStrChain(self, words: List[str]) -> int:\n        words.sort(key=lambda x: len(x))\n\n        def compare(s: str, t: str) -> bool:\n            n = len(s)  # suc\n            m = len(t)  # pre\n            if n - m != 1:\n                return False\n            i = j = 0\n            while i < n and j < m:\n                if s[i] == t[j]:\n                    i += 1\n                    j += 1\n                else:\n                    i += 1\n            if (j == m and i == n) or (j == m and i + 1 == n):\n                return True\n            else:\n                return False\n\n        n = len(words)\n        dp = [1 for _ in range(n)]\n        for i in range(1, n):\n            for j in range(i):\n                if compare(words[i], words[j]):\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_0-1-knapsack",
    "title": "0 1 Knapsack",
    "file_path": "Step 16 - Dynamic Programming/0-1-KNAPSACK.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def knapSack(self, w: int, wt: List[int], val: List[int], n: int):\n        dp = [[-1 for _ in range(w + 1)] for _ in range(n)]\n\n        def tabulation():\n            dpp = [[0 for _ in range(w + 1)] for _ in range(n)]\n            for j in range(wt[0], w + 1):\n                dpp[0][j] = val[0]\n            for i in range(1, n):\n                for j in range(w + 1):\n                    not_take = dpp[i - 1][j]\n                    take = 0\n                    if j >= wt[i]:\n                        take = val[i] + dpp[i - 1][w - wt[i]]\n                    dpp[i][j] = max(take, not_take)\n            return dpp[n - 1][w]\n\n        def memo(ind: int, rem: int) -> int:\n            if ind == n or rem == 0:\n                return 0\n            if dp[ind][rem] != -1:\n                return dp[ind][rem]\n            notpick = 0 + memo(ind + 1, rem)\n            pick = 0\n            if wt[ind] <= rem:\n                pick = val[ind] + memo(ind + 1, rem - wt[ind])\n            dp[ind][rem] = max(pick, notpick)\n            return dp[ind][rem]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_unique-paths-2",
    "title": "Unique Paths 2",
    "file_path": "Step 16 - Dynamic Programming/UNIQUE-PATHS-2.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n\n        if grid[0][0]:\n            return 0\n\n        def tabulation():\n            dp = [[0 for _ in range(m)] for _ in range(n)]\n            for i in range(n):\n                if grid[i][0]:\n                    break\n                dp[i][0] = 1\n            for j in range(m):\n                if grid[0][j]:\n                    break\n                dp[0][j] = 1\n            for i in range(1, n):\n                for j in range(1, m):\n                    if grid[i][j]:\n                        continue\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n            return dp[n - 1][m - 1]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_wildcard-matching",
    "title": "Wildcard Matching",
    "file_path": "Step 16 - Dynamic Programming/WILDCARD-MATCHING.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        n = len(s)\n        m = len(p)\n        dp = [[-1 for _ in range(m)] for _ in range(n)]\n\n        def memo(i: int, j: int) -> bool:\n            if i < 0:\n                if j < 0:  # both s and t exhausted\n                    return True\n                else:  # s exhausted but t rem\n                    while j >= 0:\n                        if p[j] != '*':\n                            return False\n                        j -= 1\n                    return True\n            if j < 0 <= i:  # t exhausted but s rem\n                return False\n            if dp[i][j] != -1:\n                return bool(dp[i][j])\n            res = None\n            if s[i] == p[j] or p[j] == '?':\n                res = memo(i - 1, j - 1)\n            else:\n                if p[j] == '*':\n                    res = memo(i - 1, j) or memo(i, j - 1) or memo(i - 1, j - 1)\n                else:\n                    res = False\n            dp[i][j] = res\n            return res\n\n        return memo(n - 1, m - 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_lis-01-implement",
    "title": "Lis 01 Implement",
    "file_path": "Step 16 - Dynamic Programming/LIS-01-IMPLEMENT.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[-1 for _ in range(n + 1)] for _ in range(n)]\n\n        def tabulation():\n            dpp = [1 for _ in range(n)]\n            for curr in range(1, n):\n                for prev in range(curr):\n                    if nums[curr] > nums[prev]:\n                        dpp[curr] = max(dpp[curr], dpp[prev] + 1)\n            return max(dpp)\n\n        def memo(i: int, prev: int):\n            if i == n:\n                return 0\n            if dp[i][prev + 1] != -1:\n                return dp[i][prev + 1]\n            pick = 0\n            if prev == -1 or nums[i] > nums[prev]:\n                pick = 1 + memo(i + 1, i)\n            not_pick = 0 + memo(i + 1, prev)\n            dp[i][prev + 1] = max(pick, not_pick)\n            return dp[i][prev + 1]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_ninjas-training",
    "title": "Ninjas Training",
    "file_path": "Step 16 - Dynamic Programming/NINJAS-TRAINING.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\"\"\"\nMarked for revision -> could not understand the logic behind its tabulation approach!\n\"\"\"\n\nclass Solution:\n    def maximumPoints(self, arr: List[List[int]], n: int):\n        dp = [[-1 for _ in range(n + 1)] for _ in range(n)]\n\n        def memo(prev: int, curr: int):\n            if curr == n:\n                return 0\n            if dp[curr][prev + 1] != -1:\n                return dp[curr][prev + 1]\n            maxi = -1\n            for i in range(3):\n                if i != prev:\n                    maxi = max(maxi, arr[curr][i] + memo(i, curr + 1))\n            dp[curr][prev + 1] = maxi\n            return maxi\n\n        # return memo(-1, 0)\n\n        def tabulation():\n            dpp = [[-1 for _ in range(4)] for _ in range(n)]\n            dpp[0][0] = max(arr[0][1], arr[0][2])\n            dpp[0][1] = max(arr[0][0], arr[0][2])\n            dpp[0][2] = max(arr[0][0], arr[0][1])\n            dpp[0][3] = max(arr[0][0], arr[0][1], arr[0][2])  # which might be the case if n = 1 (single day)\n            for curr in range(1, n):\n                for last in range(4):\n                    maxi = 0\n                    for task in range(3):\n                        if task != last:\n                            maxi = max(maxi, arr[curr][task] + dpp[curr - 1][task])\n                    dpp[curr][last] = maxi\n            return dpp[n - 1][3]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Marked for revision -> could not understand the logic behind its tabulation approach!",
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_house-robber-2",
    "title": "House Robber 2",
    "file_path": "Step 16 - Dynamic Programming/HOUSE-ROBBER-2.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def rob(self, arr: List[int]) -> int:\n\n        if len(arr) == 1:\n            return arr[0]\n\n        def tabulation(nums: List[int]):\n            n = len(nums)\n            dp = [0 for _ in range(n)]\n            dp[0] = nums[0]\n            for i in range(1, n):\n                pick = nums[i]\n                if i > 1:\n                    pick += dp[i - 2]\n                notpick = 0 + dp[i - 1]\n                dp[i] = max(pick, notpick)\n            return dp[n - 1]\n\n        return max(tabulation(arr[1:]), tabulation(arr[:-1]))\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_unique-paths-1",
    "title": "Unique Paths 1",
    "file_path": "Step 16 - Dynamic Programming/UNIQUE-PATHS-1.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[-1 for _ in range(n)] for _ in range(m)]\n\n        def memoization(i: int, j: int) -> int:\n            if (i, j) == (m - 1, n - 1):\n                return 1\n            if i >= m or j >= n:\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            down = memoization(i + 1, j)\n            right = memoization(i, j + 1)\n            dp[i][j] = down + right\n            return dp[i][j]\n\n        def tabulation():\n            dpp = [[0 for _ in range(n)] for _ in range(m)]\n            for i in range(m):\n                dpp[i][0] = 1\n            for j in range(n):\n                dpp[0][j] = 1\n            for i in range(1, m):\n                for j in range(1, n):\n                    dpp[i][j] = dpp[i - 1][j] + dpp[i][j - 1]\n            return dpp[m - 1][n - 1]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_house-robber-1",
    "title": "House Robber 1",
    "file_path": "Step 16 - Dynamic Programming/HOUSE-ROBBER-1.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        dp = [-1 for _ in range(n)]\n\n        def memo(ind: int):\n            if ind >= n:\n                return 0\n            if dp[ind] != -1:\n                return dp[ind]\n            pick = nums[ind] + memo(ind + 2)\n            notpick = 0 + memo(ind + 1)\n            dp[ind] = max(pick, notpick)\n            return dp[ind]\n\n        def tabulation():\n            dpp = [0 for _ in range(n)]\n            dpp[0] = nums[0]\n            for i in range(1, n):\n                pick = nums[i]\n                if i > 1:\n                    pick += dpp[i - 2]\n                notpick = 0 + dpp[i - 1]\n                dpp[i] = max(pick, notpick)\n            return dpp[n - 1]\n\n        return tabulation()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_16_-_dynamic_programming_longest-common-substring",
    "title": "Longest Common Substring",
    "file_path": "Step 16 - Dynamic Programming/LONGEST-COMMON-SUBSTRING.py",
    "category": "Step 16 - Dynamic Programming",
    "step": "Step 16 - Dynamic Programming",
    "difficulty": "Easy",
    "patterns": [
      "Dynamic Programming",
      "Optimization"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "class Solution:\n    def longestCommonSubstr(self, s1: str, s2: str):\n        n = len(s1)\n        m = len(s2)\n        dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n        ans = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = 1 + dp[i - 1][j - 1]\n                    ans = max(ans, dp[i][j])  # we need to keep ans bcz it would not follow till last row\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Look for overlapping subproblems"
    ]
  },
  {
    "id": "step_06_-_linked_list_intersection-of-ll",
    "title": "Intersection Of Ll",
    "file_path": "Step 06 - Linked List/INTERSECTION-OF-LL.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def getlength(self, head: Optional[ListNode]) -> int:\n        curr = 0\n        while head:\n            curr += 1\n            head = head.next\n        return curr\n\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        len1, len2 = self.getlength(headA), self.getlength(headB)\n        if len1 > len2:\n            return self.getIntersectionNode(headB, headA)\n        k = len2 - len1\n        slow, fast = headA, headB\n        while k > 0:\n            k -= 1\n            fast = fast.next\n        while slow and fast and slow != fast:\n            slow = slow.next\n            fast = fast.next\n        if slow and fast and slow == fast:\n            return slow\n        else:\n            return None\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_length-of-cycle",
    "title": "Length Of Cycle",
    "file_path": "Step 06 - Linked List/LENGTH-OF-CYCLE.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Node:\n    def __init__(self, data):  # data -> value stored in node\n        self.data = data\n        self.next = None\n\n\ndef countNodesinLoop(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            curr = slow.next\n            count = 1\n            while curr != slow:\n                count += 1\n                curr = curr.next\n            return count\n    return 0\n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_flatten-dll",
    "title": "Flatten Dll",
    "file_path": "Step 06 - Linked List/FLATTEN-DLL.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\n# PRE-REQUISITE: FLATTEN LINKED LIST\n# https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/\n\nclass Node:\n    def __init__(self, val, prev, next, child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\n\nclass Solution:\n    def gettail(self, head):\n        if not head or not head.next:\n            return head\n        while head.next:\n            head = head.next\n        return head\n\n    def flatten(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return head\n        curr = next = None\n        curr = head\n        while curr:\n            if curr.child is None:\n                curr = curr.next\n            else:\n                next = curr.next\n                temp = curr.child\n                curr.child = None\n                childhead = self.flatten(temp)\n                childtail = self.gettail(childhead)\n                curr.next = childhead\n                childhead.prev = curr\n                childtail.next = next\n                if next:\n                    next.prev = childtail\n                curr = next\n\n        return head\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "PRE-REQUISITE: FLATTEN LINKED LIST https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_split-linked-list-in-parts",
    "title": "Split Linked List In Parts",
    "file_path": "Step 06 - Linked List/SPLIT-LINKED-LIST-IN-PARTS.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List, Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def length(self, head: Optional[ListNode]) -> int:\n        cnt = 0\n        while head:\n            cnt += 1\n            head = head.next\n        return cnt\n\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n        n = self.length(head)\n        ans = []\n        each = n // k\n        extra = n % k\n        for i in range(k):\n            count = each + 1 if i < extra else each\n            # for initial extra splits we would keep one extra node in them\n            tail = ListNode(-1)\n            curr = tail\n            while head and count:\n                curr.next = ListNode(head.val)\n                head = head.next\n                count -= 1\n                curr = curr.next\n            ans.append(tail.next)\n\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "for initial extra splits we would keep one extra node in them",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_pairs-in-dll",
    "title": "Pairs In Dll",
    "file_path": "Step 06 - Linked List/PAIRS-IN-DLL.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    def findPairsWithGivenSum(self, target: int, head: Optional['Node']) -> List[List[int]]:\n        tail = head\n        while tail.next:\n            tail = tail.next\n        ans = []\n        while head and tail and head.data < tail.data:\n            temp = head.data + tail.data\n            if temp == target:\n                ans.append([head.data, tail.data])\n                head = head.next\n                tail = tail.prev\n            elif temp < target:\n                head = head.next\n            else:\n                tail = tail.prev\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_flatten-ll",
    "title": "Flatten Ll",
    "file_path": "Step 06 - Linked List/FLATTEN-LL.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass Node:\n    def __init__(self, d):\n        self.data = d\n        self.next = None\n        self.bottom = None\n\n\n# BRUTE FORCE APPROACH\ndef flatten_bruteforce(root):\n    arr = []\n    while root:\n        arr.append(root.data)\n        curr = root.bottom\n        while curr:\n            arr.append(curr.data)\n            curr = curr.bottom\n        root = root.next\n    arr.sort()\n    curr = head = Node(-1)\n    for item in arr:\n        curr.bottom = Node(item)\n        curr = curr.bottom\n    return head.bottom\n\n\n# OPTIMISED APPROACH\ndef merge(head1: Optional[Node], head2: Optional[Node]) -> Optional[Node]:\n    if not head1:\n        return head2\n    if not head2:\n        return head1\n    curr = dummyHead = Node(-1)\n    while head1 and head2:\n        if head1.data <= head2.data:\n            curr.bottom = Node(head1.data)\n            head1 = head1.bottom\n        else:\n            curr.bottom = Node(head2.data)\n            head2 = head2.bottom\n        curr = curr.bottom\n    if head1:\n        curr.bottom = head1\n    if head2:\n        curr.bottom = head2\n    return dummyHead.bottom\n\n\ndef flatten(root):\n    if not root or not root.next:\n        return root\n    root.next = flatten(root.next)\n    root = merge(root, root.next)\n    return root\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "BRUTE FORCE APPROACH OPTIMISED APPROACH",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_palindrome",
    "title": "Palindrome",
    "file_path": "Step 06 - Linked List/PALINDROME.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        if not head or not head.next:\n            return True\n        n, curr = 0, head\n        while curr:\n            n += 1\n            curr = curr.next\n        odd = n % 2\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        prev, curr = None, head\n        while curr != slow:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        head = prev\n        if odd:\n            slow = slow.next\n        while head and slow:\n            if head.val != slow.val:\n                return False\n            head = head.next\n            slow = slow.next\n        return True\n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Palindromes read the same forwards and backwards"
    ]
  },
  {
    "id": "step_06_-_linked_list_rotate-list",
    "title": "Rotate List",
    "file_path": "Step 06 - Linked List/ROTATE-LIST.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional, Tuple\n\n# SIMILAR TO ROTATE ARRAY\n'''\nHere we have applied the technique which we applied in Rotating Array.\n1. Reverse the whole array\n2. Reverse the first k elements\n3. Reverse the next n-k elements\n'''\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def getLength(self, head: Optional[ListNode]) -> int:\n        length = 0\n        while head:\n            length += 1\n            head = head.next\n        return length\n\n    def reverse(self, head: Optional[ListNode], k: int) -> Tuple:\n        prev, curr = None, head\n        while curr and k:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            k -= 1\n        return prev, curr\n\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        n = self.getLength(head)\n        if n <= 1:\n            return head\n        k = k % n\n        if k == 0:\n            return head\n        head, _ = self.reverse(head, n)\n        head, temp = self.reverse(head, k)\n        curr = head\n        while curr.next:\n            curr = curr.next\n        t, _ = self.reverse(temp, n - k)\n        curr.next = t\n        return head\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "SIMILAR TO ROTATE ARRAY Here we have applied the technique which we applied in Rotating Array. 1. Reverse the whole array 2. Reverse the first k elements 3. Reverse the next n-k elements",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_remove-duplicates-dll",
    "title": "Remove Duplicates Dll",
    "file_path": "Step 06 - Linked List/REMOVE-DUPLICATES-DLL.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Node:\n    def __init__(self, data):  # data -> value stored in node\n        self.data = data\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    # Function to remove duplicates from unsorted linked list.\n    def removeDuplicates(self, head):\n        # code here\n        # return head after editing list\n        if not head:\n            return None\n        prev = head\n        curr = head.next\n        while curr:\n            while curr and curr.data == prev.data:\n                curr = curr.next\n            prev.next = curr\n            if curr:\n                curr.prev = prev\n                prev = curr\n                curr = curr.next\n        return head\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Function to remove duplicates from unsorted linked list. code here return head after editing list",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_sort-list",
    "title": "Sort List",
    "file_path": "Step 06 - Linked List/SORT-LIST.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def findMid(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n    def merge(self, head1: Optional[ListNode], head2: Optional[ListNode]) -> Optional[ListNode]:\n        if not head1:\n            return head2\n        if not head2:\n            return head1\n        curr = dummyHead = ListNode(-1)\n        while head1 and head2:\n            if head1.val <= head2.val:\n                curr.next = ListNode(head1.val)\n                head1 = head1.next\n            else:\n                curr.next = ListNode(head2.val)\n                head2 = head2.next\n            curr = curr.next\n        if head1:\n            curr.next = head1\n        if head2:\n            curr.next = head2\n        return dummyHead.next\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        left = mid = right = None\n        left, mid = head, self.findMid(head)\n        right = mid.next\n        mid.next = None\n        left = self.sortList(left)\n        right = self.sortList(right)\n        result = self.merge(left, right)\n        return result\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_06_-_linked_list_remove-nth-node",
    "title": "Remove Nth Node",
    "file_path": "Step 06 - Linked List/REMOVE-NTH-NODE.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        slow = fast = head\n        while k > 0:\n            fast = fast.next\n            k -= 1\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        slow.next = slow.next.next\n        return head\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_detect-cycle",
    "title": "Detect Cycle",
    "file_path": "Step 06 - Linked List/DETECT-CYCLE.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n\n\n'''\nOther possible solutions are:\n1. using a hashmap\n2. using a flag attribute: modify the ListNode object to store a fflag\nwhich is True if the node is already visible!\n'''\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Other possible solutions are: 1. using a hashmap 2. using a flag attribute: modify the ListNode object to store a fflag which is True if the node is already visible!",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_odd-even-grouping",
    "title": "Odd Even Grouping",
    "file_path": "Step 06 - Linked List/ODD-EVEN-GROUPING.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ind = 1\n        odd, even = ListNode(-1), ListNode(-1)\n        curr = head\n        dummyOdd, dummyEven = odd, even\n        while curr:\n            if ind & 1:\n                odd.next = ListNode(curr.val)\n                odd = odd.next\n            else:\n                even.next = ListNode(curr.val)\n                even = even.next\n            ind += 1\n            curr = curr.next\n        odd.next = dummyEven.next\n        return dummyOdd.next\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_reverse-ll",
    "title": "Reverse Ll",
    "file_path": "Step 06 - Linked List/REVERSE-LL.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        prev, curr = None, head\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        return prev\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_detect-cycle-ii",
    "title": "Detect Cycle Ii",
    "file_path": "Step 06 - Linked List/DETECT-CYCLE-II.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                slow = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow\n        return None\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_insert-node-dll",
    "title": "Insert Node Dll",
    "file_path": "Step 06 - Linked List/INSERT-NODE-DLL.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\n\ndef addNode(head, p, data):\n    back, front = head, head.next\n    while p > 0:\n        back, front = front, front.next\n        p -= 1\n    node = Node(data)\n    node.prev, node.next = back, front\n    back.next = node\n    if front:\n        front.prev = node\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_insert-gcd-in-linked-list",
    "title": "Insert Gcd In Linked List",
    "file_path": "Step 06 - Linked List/INSERT-GCD-IN-LINKED-LIST.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\nfrom math import gcd\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n        curr = head\n        while curr.next:\n            fwd: ListNode = curr.next\n            gcd_val = gcd(curr.val, fwd.val)\n            temp = ListNode(gcd_val)\n            curr.next = temp\n            temp.next = fwd\n            curr = fwd\n        return head\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_remove-nodes-dll",
    "title": "Remove Nodes Dll",
    "file_path": "Step 06 - Linked List/REMOVE-NODES-DLL.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "# Node Class\nclass Node:\n    def __init__(self, data):  # data -> value stored in node\n        self.data = data\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    def deleteAllOccurOfX(self, head, x):\n        while head and head.data == x:\n            head = head.next\n        prev = head\n        curr = head.next\n        while curr:\n            next = curr.next\n            if curr.data == x:\n                prev.next = next\n                if next:\n                    next.prev = prev\n                curr = next\n            else:\n                prev = curr\n                curr = next\n        return head\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Node Class",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_add-two-numbers",
    "title": "Add Two Numbers",
    "file_path": "Step 06 - Linked List/ADD-TWO-NUMBERS.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = head = ListNode(-1)\n        carry = 0\n        while l1 or l2 or carry:\n            curr = carry + (l1.val if l1 else 0) + (l2.val if l2 else 0)\n            head.next = ListNode(curr % 10)\n            carry = curr // 10\n            head = head.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummy.next\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_tortoise-hair-method",
    "title": "Tortoise Hair Method",
    "file_path": "Step 06 - Linked List/TORTOISE-HAIR-METHOD.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_clone-list",
    "title": "Clone List",
    "file_path": "Step 06 - Linked List/CLONE-LIST.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import Optional\nfrom collections import defaultdict\n\n\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        mp = defaultdict()\n        temp = head\n        while temp:\n            mp[temp] = Node(temp.val)\n            temp = temp.next\n        temp = head\n        while temp:\n            mp[temp].next = mp[temp.next] if temp.next else None\n            mp[temp].random = mp[temp.random] if temp.random else None\n            temp = temp.next\n        return mp[head]\n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_sort-0s-1s-2s",
    "title": "Sort 0S 1S 2S",
    "file_path": "Step 06 - Linked List/SORT-0S-1S-2S.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass Solution:\n    def segregate(self, head):\n        dummyz, dummyo, dummyt = Node(-1), Node(-1), Node(-1)\n        zero, ones, twos = dummyz, dummyo, dummyt\n        while head:\n            if head.data == 0:\n                zero.next = Node(0)\n                zero = zero.next\n            elif head.data == 1:\n                ones.next = Node(1)\n                ones = ones.next\n            else:\n                twos.next = Node(2)\n                twos = twos.next\n            head = head.next\n        ones.next = dummyt.next\n        if dummyz.next:\n            zero.next = dummyo.next\n            return dummyz.next\n        else:\n            return dummyo.next\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_06_-_linked_list_reverse-dll",
    "title": "Reverse Dll",
    "file_path": "Step 06 - Linked List/REVERSE-DLL.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    def reverseDLL(self, head):\n        if not head or not head.next:\n            return head\n        prev, curr, next = None, head, head.next\n        while curr:\n            curr.next = prev\n            curr.prev = next\n            prev = curr\n            curr = next\n            if curr:\n                next = curr.next\n        return prev\n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_06_-_linked_list_reverse-nodes-in-group-of-k",
    "title": "Reverse Nodes In Group Of K",
    "file_path": "Step 06 - Linked List/REVERSE-NODES-IN-GROUP-OF-K.py",
    "category": "Step 06 - Linked List",
    "step": "Step 06 - Linked List",
    "difficulty": "Easy",
    "patterns": [
      "Linked List",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n'''\nImportant Given Constraints:\n1 <= k <= n\n'''\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        prev, curr = None, head\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        return prev\n\n    def getkthnode(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        count = 1\n        while count < k and head:\n            head = head.next\n            count += 1\n        return head\n\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        prev, temp, next = None, head, None\n        while temp:\n            kthNode = self.getkthnode(temp, k)\n            if kthNode is None:\n                prev.next = temp\n                break\n            else:\n                next = kthNode.next\n                kthNode.next = None\n                new = self.reverseList(temp)\n                if temp == head:\n                    head = new\n                else:\n                    prev.next = new\n                prev = temp\n                temp = next\n        return head\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Important Given Constraints: 1 <= k <= n",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "design_based_lfu-cache",
    "title": "Lfu Cache",
    "file_path": "Step 06 - Linked List/DESIGN BASED/LFU-CACHE.py",
    "category": "DESIGN BASED",
    "step": "DESIGN BASED",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "\"\"\"\nIf this problem comes in Interview then only God can save us!\n\"\"\"\n\n\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.cnt = 1\n        self.next = None\n        self.prev = None\n\n\nclass List:\n    def __init__(self):\n        self.size = 0\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def addFront(self, node):\n        temp = self.head.next\n        node.next = temp\n        node.prev = self.head\n        self.head.next = node\n        temp.prev = node\n        self.size += 1\n\n    def removeNode(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n        self.size -= 1\n\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.keyNode = {}\n        self.freqListMap = {}\n        self.maxSizeCache = capacity\n        self.minFreq = 0\n        self.curSize = 0\n\n    def updateFreqListMap(self, node):\n        del self.keyNode[node.key]\n        self.freqListMap[node.cnt].removeNode(node)\n        if node.cnt == self.minFreq and self.freqListMap[node.cnt].size == 0:\n            self.minFreq += 1\n\n        node.cnt += 1\n        if node.cnt not in self.freqListMap:\n            self.freqListMap[node.cnt] = List()\n        self.freqListMap[node.cnt].addFront(node)\n        self.keyNode[node.key] = node\n\n    def get(self, key: int) -> int:\n        if key in self.keyNode:\n            node = self.keyNode[key]\n            self.updateFreqListMap(node)\n            return node.value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if self.maxSizeCache == 0:\n            return\n\n        if key in self.keyNode:\n            node = self.keyNode[key]\n            node.value = value\n            self.updateFreqListMap(node)\n        else:\n            if self.curSize == self.maxSizeCache:\n                list_to_remove = self.freqListMap[self.minFreq]\n                del self.keyNode[list_to_remove.tail.prev.key]\n                list_to_remove.removeNode(list_to_remove.tail.prev)\n                self.curSize -= 1\n\n            self.curSize += 1\n            self.minFreq = 1\n            new_node = Node(key, value)\n            if self.minFreq not in self.freqListMap:\n                self.freqListMap[self.minFreq] = List()\n            self.freqListMap[self.minFreq].addFront(new_node)\n            self.keyNode[key] = new_node\n\n# Example usage:\n# obj = LFUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key, value)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "If this problem comes in Interview then only God can save us!",
    "hints": []
  },
  {
    "id": "design_based_lru-cache",
    "title": "Lru Cache",
    "file_path": "Step 06 - Linked List/DESIGN BASED/LRU-CACHE.py",
    "category": "DESIGN BASED",
    "step": "DESIGN BASED",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "\"\"\"\nImportant\nNot so easy but not that tough as LFU Cache!\nMay come in Interview!\n\"\"\"\n\n\nclass ListNode:\n    def __init__(self, prev=None, next=None, data=(-1, -1)):\n        self.prev = prev\n        self.next = next\n        self.data = data\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _remove(self, node: ListNode):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def _add(self, node: ListNode):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            self._add(node)\n            return node.data[1]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self._remove(self.cache[key])\n        node = ListNode(data=(key, value))\n        self._add(node)\n        self.cache[key] = node\n        if len(self.cache) > self.cap:\n            lru = self.tail.prev\n            self._remove(lru)\n            del self.cache[lru.data[0]]\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key, value)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Important Not so easy but not that tough as LFU Cache! May come in Interview!",
    "hints": []
  },
  {
    "id": "step_04_-_binary_search_painters-partition",
    "title": "Painters Partition",
    "file_path": "Step 04 - Binary Search/PAINTERS-PARTITION.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def minTime(self, arr: List[int], n: int, k: int):\n        def isValid(time: int):\n            count, curr = 1, 0\n            for item in arr:\n                if item > time:\n                    return False\n                if curr + item <= time:\n                    curr += item\n                else:\n                    count += 1\n                    curr = item\n            return count <= k\n        low, high, ans = 0, sum(arr), 0\n        while low <= high:\n            mid = (low+high)//2\n            if isValid(mid):\n                ans, high = mid, mid-1\n            else:\n                low = mid + 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_2d-matrix-binary-search",
    "title": "2D Matrix Binary Search",
    "file_path": "Step 04 - Binary Search/2D-MATRIX-BINARY-SEARCH.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Medium",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Binary Search"
    ],
    "solution_code": "from typing import List\nimport bisect\n\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        n, m = len(matrix), len(matrix[0])\n        low, high = 0, n - 1\n        while low <= high:\n            mid = (low + high) // 2\n            print(mid)\n            if target <= matrix[mid][m - 1]:\n                if target >= matrix[mid][0]:\n                    ind = bisect.bisect_left(matrix[mid], target)\n                    print(mid, ind)\n                    return 0 <= ind < m and matrix[mid][ind] == target\n                else:\n                    high = mid - 1\n            else:\n                low = mid + 1\n        return False\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_2d-matrix-bs-hard",
    "title": "2D Matrix Bs Hard",
    "file_path": "Step 04 - Binary Search/2D-MATRIX-BS-HARD.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Binary Search"
    ],
    "solution_code": "from typing import List\nimport bisect\n\n\nclass Solution1:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        n, m = len(matrix), len(matrix[0])\n        cr, cc = 0, m - 1\n        while cr < n and cc >= 0:\n            if matrix[cr][cc] == target:\n                return True\n            elif target > matrix[cr][cc]:\n                cr += 1\n            else:\n                cc -= 1\n        return False\n\n\nclass Solution2:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        n, m = len(matrix), len(matrix[0])\n        cr, cc = n - 1, 0\n        while cr >= 0 and cc < m:\n            print(cr, cc)\n            if matrix[cr][cc] == target:\n                return True\n            elif target > matrix[cr][cc]:\n                cc += 1\n            else:\n                cr -= 1\n        return False\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_first-last-index",
    "title": "First Last Index",
    "file_path": "Step 04 - Binary Search/FIRST-LAST-INDEX.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Binary Search",
      "Two Pointers"
    ],
    "solution_code": "import bisect\nfrom typing import List\n\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        # we can either use binary search -> two times -> first to find the first pos and then the last pos\n        # else we can use bisect\n        last = bisect.bisect_right(nums, target)\n        first = bisect.bisect_left(nums, target)\n        # case 1 : target exists\n        if first < len(nums) and nums[first] == target and last - 1 >= 0 and nums[last - 1] == target:\n            return [first, last - 1]\n        # case 2 : does not exist\n        else:\n            return [-1, -1]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "we can either use binary search -> two times -> first to find the first pos and then the last pos else we can use bisect case 1 : target exists case 2 : does not exist",
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_min-in-rotated-array",
    "title": "Min In Rotated Array",
    "file_path": "Step 04 - Binary Search/MIN-IN-ROTATED-ARRAY.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\nfrom sys import maxsize\n\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n        ans = maxsize\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] >= nums[low]:\n                ans = min(ans, nums[low])\n                low = mid + 1\n            else:\n                ans = min(ans, nums[mid])\n                high = mid - 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_ship-packages",
    "title": "Ship Packages",
    "file_path": "Step 04 - Binary Search/SHIP-PACKAGES.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\n        def isValid(limit: int) -> bool:\n            curr, count = 0, 1\n            for item in weights:\n                if curr + item <= limit:\n                    curr += item\n                else:\n                    count += 1\n                    curr = item\n                    if count > days or item > limit:\n                        return False\n            return count <= days\n\n        low, high = min(weights), sum(weights)\n        ans = high\n        while low <= high:\n            mid = (low + high) // 2\n            if isValid(mid):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n\n\n'''\n1. exact days taken -> since we want min capacity -> we would reduce high\n2. less days taken -> since we want min capacity -> we would reduce high\n3. more days taken -> increase the capacity -> increase low\n'''\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "1. exact days taken -> since we want min capacity -> we would reduce high 2. less days taken -> since we want min capacity -> we would reduce high 3. more days taken -> increase the capacity -> increase low",
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_split-largest",
    "title": "Split Largest",
    "file_path": "Step 04 - Binary Search/SPLIT-LARGEST.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\n# THIS PROBLEM IS SAME AS BOOK ALLOCATION PROBLEM!\n\n\nclass Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n        def isValid(limit: int) -> bool:\n            curr, count = 0, 1\n            for item in nums:\n                if item > limit:\n                    return False\n                if curr + item <= limit:\n                    curr += item\n                else:\n                    count += 1\n                    curr = item\n            return count <= k\n\n        low, high = min(nums), sum(nums)\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if isValid(mid):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "THIS PROBLEM IS SAME AS BOOK ALLOCATION PROBLEM!",
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_nth-root",
    "title": "Nth Root",
    "file_path": "Step 04 - Binary Search/NTH-ROOT.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "import math\n\n\nclass Solution:\n    def NthRoot(self, n, m):\n        low, high, ans = 0, m, -1\n        while low <= high:\n            mid = (low + high) // 2\n            res = math.pow(mid, n)\n            if res == m:\n                return mid\n            elif res < m:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_aggressive-cows",
    "title": "Aggressive Cows",
    "file_path": "Step 04 - Binary Search/AGGRESSIVE-COWS.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def solve(self, n: int, k: int, stalls: List[int]):\n        if n < k:\n            return -1\n        stalls.sort()\n\n        def isValid(mid: int):\n            count, last = 1, stalls[0]\n            for item in stalls[1:]:\n                if item - last >= mid:\n                    count += 1\n                    last = item\n            return count >= k\n\n        low, high = 0, stalls[-1] - stalls[0]\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if isValid(mid):\n                ans = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_max-1s-row",
    "title": "Max 1S Row",
    "file_path": "Step 04 - Binary Search/MAX-1S-ROW.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Binary Search"
    ],
    "solution_code": "from typing import List\nimport bisect\n\n\nclass Solution:\n    def rowWithMax1s(self, arr: List[List[int]], n: int, m: int):\n        maxi, index = 0, -1\n        for i in range(n):\n            count = m - bisect.bisect_left(arr[i], 1)\n            if count > maxi:\n                maxi, index = count, i\n        return index\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_sqrt",
    "title": "Sqrt",
    "file_path": "Step 04 - Binary Search/SQRT.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "import math\n\n\nclass Solution1:\n    def floorSqrt(self, x):\n        return math.floor(math.sqrt(x))\n\n\nclass Solution:\n    def floorSqrt(self, x):\n        low, high, ans = 1, x, -1\n        while low <= high:\n            mid = (low + high) // 2\n            if mid ** 2 == x:\n                return mid\n            elif mid ** 2 < x:\n                ans = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_kth-missing-pos",
    "title": "Kth Missing Pos",
    "file_path": "Step 04 - Binary Search/KTH-MISSING-POS.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\n\n# APPROACH 1 : USING O(N) TIME AND SPACE\nclass Solution1:\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        mp = defaultdict(int, {item: 1 for item in arr})\n        i = 1\n        while k:\n            if i not in mp:\n                k -= 1\n            i += 1\n        return i - 1\n\n\n# APPROACH 2 : O(N) TIME ; O(1) SPACE\nclass Solution:\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        for item in arr:\n            if item <= k:\n                k += 1\n            else:\n                break\n        return k\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "APPROACH 1 : USING O(N) TIME AND SPACE APPROACH 2 : O(N) TIME ; O(1) SPACE",
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_median-of-two-sorted-arr",
    "title": "Median Of Two Sorted Arr",
    "file_path": "Step 04 - Binary Search/MEDIAN-OF-TWO-SORTED-ARR.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List\nfrom sys import maxsize as LIMIT\n\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        n1, n2 = len(nums1), len(nums2)\n        if n1 > n2:\n            '''\n            It handles the edge case like : nums1 = [2] nums2 = []\n            '''\n            return self.findMedianSortedArrays(nums2, nums1)\n        low, high = 0, n1\n        while low <= high:\n            cut1 = (low + high) // 2\n            cut2 = (n1 + n2 + 1) // 2 - cut1  # ceil division\n            left1 = -LIMIT if cut1 == 0 else nums1[cut1 - 1]\n            right1 = LIMIT if cut1 == n1 else nums1[cut1]\n            left2 = -LIMIT if cut2 == 0 else nums2[cut2 - 1]\n            right2 = LIMIT if cut2 == n2 else nums2[cut2]\n            if left1 <= right2 and left2 <= right1:\n                if (n1 + n2) & 1:\n                    return max(left1, left2)\n                else:\n                    return (max(left1, left2) + min(right1, right2)) / 2\n            elif left1 > right2:\n                high = cut1 - 1\n            else:\n                low = cut1 + 1\n        return 0\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "It handles the edge case like : nums1 = [2] nums2 = []",
    "hints": [
      "Think about binary search on the answer",
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_04_-_binary_search_search-rot-sorted-1",
    "title": "Search Rot Sorted 1",
    "file_path": "Step 04 - Binary Search/SEARCH-ROT-SORTED-1.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = low + (high - low) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[low] <= nums[mid]:\n                if nums[low] <= target < nums[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            else:\n                if nums[mid] < target <= nums[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n        return -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer",
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_04_-_binary_search_gas-stations",
    "title": "Gas Stations",
    "file_path": "Step 04 - Binary Search/GAS-STATIONS.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\nimport math\n\n\nclass Solution:\n    def findSmallestMaxDist(self, stations: List[int], K: int):\n        stations.sort()\n\n        def isValid(d: int):\n            count = 0\n            for i in range(1, len(stations)):\n                dis = stations[i] - stations[i - 1]\n                if dis <= d:\n                    continue\n                else:\n                    count += math.ceil(dis / d) - 1\n            return count <= K\n\n        ans = low = 0\n        high = max(stations[i] - stations[i - 1] for i in range(1, len(stations)))\n        while high - low >= 1e-6:\n            mid = (low + high) / 2\n            if isValid(mid):\n                ans = mid\n                high = mid\n            else:\n                low = mid\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_koko-eating-bananas",
    "title": "Koko Eating Bananas",
    "file_path": "Step 04 - Binary Search/KOKO-EATING-BANANAS.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        def isValid(k):\n            count = 0\n            for item in piles:\n                count += (item + k - 1)//k\n                if count > h:\n                    return False\n            return count <= h\n\n        low, high = 0, sum(piles)\n        ans = high\n        while low <= high:\n            mid = (low + high) // 2\n            if mid > 0 and isValid(mid):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_rotation",
    "title": "Rotation",
    "file_path": "Step 04 - Binary Search/ROTATION.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def findKRotation(self, arr: List[int], n: int):\n        low, high, mini, ind = 0, len(arr)-1, sys.maxsize, None\n        while low <= high:\n            mid = (low + high)//2\n            if arr[low] <= arr[mid]:\n                if arr[low] < mini:\n                    mini = arr[low]\n                    ind = low\n                low = mid + 1\n            else:\n                if arr[mid] < mini:\n                    mini = arr[mid]\n                    ind = mid\n                high = mid - 1\n        return ind\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_book-allocation-problem",
    "title": "Book Allocation Problem",
    "file_path": "Step 04 - Binary Search/BOOK-ALLOCATION-PROBLEM.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def findPages(self, n: int, arr: List[int], m: int) -> int:\n        if m > n:\n            return -1\n\n        def isValid(limit: int) -> int:\n            count, curr = 1, 0\n            for item in arr:\n                if item > limit:\n                    return int(1e9)\n                if curr + item <= limit:\n                    curr += item\n                else:\n                    count += 1\n                    curr = item\n            return count\n\n        low, high = 0, sum(arr)\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            students = isValid(mid)\n            if students <= m:\n                '''\n                Why are we considering ans = mid in the case when students < m? ->\n                1. Its bcz in this case also we need to reduce the upper_bound of our range to reduce the mid so that more\n                students can be accommodated.\n                2. Second reason to ye hain ki like if we have m = 5 and we have accommodated 3 students on the basis\n                of our current mid, then we can do one thing ki 1st student ko mid jitna page de diaa jaae and baaki students\n                ko thoda km km diaa jaae taaki saare usi mein accommodate ho jaae. Bcz we only want to consider the max\n                page accommodated to any student to wo (mid ho jaaega) and baaki students ko mid se km mile tb saare\n                accommodate ho jaaenge usi mein!\n                '''\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Why are we considering ans = mid in the case when students < m? -> 1. Its bcz in this case also we need to reduce the upper_bound of our range to reduce the mid so that more students can be accommodated. 2. Second reason to ye hain ki like if we have m = 5 and we have accommodated 3 students on the basis of our current mid, then we can do one thing ki 1st student ko mid jitna page de diaa jaae and baaki students ko thoda km km diaa jaae taaki saare usi mein accommodate ho jaae. Bcz we only want to consider the max page accommodated to any student to wo (mid ho jaaega) and baaki students ko mid se km mile tb saare accommodate ho jaaenge usi mein!",
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_ceil-floor",
    "title": "Ceil Floor",
    "file_path": "Step 04 - Binary Search/CEIL-FLOOR.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Binary Search",
      "Two Pointers"
    ],
    "solution_code": "import bisect\n\n\ndef getFloorAndCeil(arr, n, x):\n    # code here\n    arr.sort()\n    lower = bisect.bisect_left(arr, x)\n    ans = []\n    if lower < n and arr[lower] == x:\n        ans.append(x)\n    elif lower - 1 >= 0:\n        ans.append(arr[lower - 1])\n    else:\n        ans.append(-1)\n    upper = bisect.bisect_right(arr, x)\n    if upper < n:\n        if upper - 1 >= 0 and arr[upper - 1] == x:\n            ans.append(x)\n        else:\n            ans.append(arr[upper])\n    else:\n        ans.append(-1)\n    return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "code here",
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_peak-element",
    "title": "Peak Element",
    "file_path": "Step 04 - Binary Search/PEAK-ELEMENT.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n# NOTE: Given that nums[i] != nums[i+1] for all 'i' means there are no duplicates involved\n# well this given criteria is necessary as well -> bcz then only this solution would work\n\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[-1] > nums[-2]:\n            return n - 1\n        low, high = 1, n - 2\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid - 1] < nums[mid] > nums[mid + 1]:\n                return mid\n            if nums[mid - 1] > nums[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        return -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "NOTE: Given that nums[i] != nums[i+1] for all 'i' means there are no duplicates involved well this given criteria is necessary as well -> bcz then only this solution would work",
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_peak-element-02",
    "title": "Peak Element 02",
    "file_path": "Step 04 - Binary Search/PEAK-ELEMENT-02.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List\n\n\n# SIMILAR TO PEAK ELEMENT\n\nclass Solution:\n    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:\n        n, m = len(mat), len(mat[0])\n        low, high = 0, n - 1\n        while low <= high:\n            mid = (low + high) // 2\n            col, maxi = max(enumerate(mat[mid]), key=lambda x: x[1])\n            up = -1 if mid == 0 else mat[mid - 1][col]\n            right = -1 if col == m - 1 else mat[mid][col + 1]\n            down = -1 if mid == n - 1 else mat[mid + 1][col]\n            left = -1 if col == 0 else mat[mid][col - 1]\n            if maxi > up and maxi > down and maxi > left and maxi > right:\n                return [mid, col]\n            elif maxi < up:\n                high = mid - 1\n            else:\n                low = mid + 1\n        return [-1, -1]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "SIMILAR TO PEAK ELEMENT",
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_single-element",
    "title": "Single Element",
    "file_path": "Step 04 - Binary Search/SINGLE-ELEMENT.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        low, high = 0, n - 1\n        while low <= high:\n            mid = low + (high - low) // 2\n            if mid == 0 and nums[mid] != nums[mid + 1]:\n                return nums[mid]\n            if mid == n - 1 and nums[mid] != nums[mid - 1]:\n                return nums[mid]\n            if nums[mid] != nums[mid-1] and nums[mid] != nums[mid+1]:\n                return nums[mid]\n            if mid & 1:\n                if nums[mid - 1] == nums[mid]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            else:\n                if mid + 1 < n and nums[mid] == nums[mid + 1]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n        return -1",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_search-insert-position",
    "title": "Search Insert Position",
    "file_path": "Step 04 - Binary Search/SEARCH-INSERT-POSITION.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Binary Search"
    ],
    "solution_code": "import bisect\nfrom typing import List\n\n\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        ind = bisect.bisect_right(nums, target)\n        if ind - 1 >= 0 and nums[ind - 1] == target:\n            return ind - 1\n        else:\n            return ind\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_smallest-divisor",
    "title": "Smallest Divisor",
    "file_path": "Step 04 - Binary Search/SMALLEST-DIVISOR.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        if threshold < n:\n            return -1\n\n        def isValid(divisor: int):\n            res = 0\n            for item in nums:\n                res += (item + divisor - 1) // divisor\n                if res > threshold:\n                    return False\n            return res <= threshold\n\n        low, high = 1, max(nums)\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if isValid(mid):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_min-days-m-bouqets",
    "title": "Min Days M Bouqets",
    "file_path": "Step 04 - Binary Search/MIN-DAYS-M-BOUQETS.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def isValid(mid):\n            count = temp = 0\n            for item in bloomDay:\n                if item <= mid:\n                    temp += 1\n                    if temp == k:\n                        temp, count = 0, count + 1\n                else:\n                    temp = 0\n            return count >= m\n\n        low, high = min(bloomDay), max(bloomDay)\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            print(low, mid, high)\n            if isValid(mid):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_median-in-matrix",
    "title": "Median In Matrix",
    "file_path": "Step 04 - Binary Search/MEDIAN-IN-MATRIX.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Binary Search"
    ],
    "solution_code": "from typing import List\nimport bisect\n\n\nclass Solution:\n    def median(self, matrix: List[List[int]], R: int, C: int) -> int:\n        low, high = float('inf'), float('-inf')\n\n        # Find the minimum and maximum elements in the matrix\n        for i in range(R):\n            low = min(low, matrix[i][0])\n            high = max(high, matrix[i][C - 1])\n\n        while low <= high:\n            mid = low + (high - low) // 2\n            count = 0\n\n            # Count elements less than or equal to mid\n            for i in range(R):\n                count += bisect.bisect_right(matrix[i], mid)\n\n            if count <= (R * C) // 2:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return low\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Find the minimum and maximum elements in the matrix Count elements less than or equal to mid",
    "hints": [
      "Think about binary search on the answer"
    ]
  },
  {
    "id": "step_04_-_binary_search_search-rot-sorted-2",
    "title": "Search Rot Sorted 2",
    "file_path": "Step 04 - Binary Search/SEARCH-ROT-SORTED-2.py",
    "category": "Step 04 - Binary Search",
    "step": "Step 04 - Binary Search",
    "difficulty": "Easy",
    "patterns": [
      "Binary Search",
      "Search"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return True\n            # EDGE CASE\n            if nums[low] == nums[mid] == nums[high]:\n                low += 1\n                high -= 1\n                continue\n            if nums[low] <= nums[mid]:\n                if nums[low] <= target < nums[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            else:\n                if nums[mid] < target <= nums[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n        return -1",
    "time_complexity": null,
    "space_complexity": null,
    "description": "EDGE CASE",
    "hints": [
      "Think about binary search on the answer",
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_17_-_tries_word-search-2",
    "title": "Word Search 2",
    "file_path": "Step 17 - Tries/WORD-SEARCH-2.py",
    "category": "Step 17 - Tries",
    "step": "Step 17 - Tries",
    "difficulty": "Easy",
    "patterns": [
      "Trie",
      "String"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_17_-_tries_dp-on-tries-min-valid-substring",
    "title": "Dp On Tries Min Valid Substring",
    "file_path": "Step 17 - Tries/DP-ON-TRIES-MIN-VALID-SUBSTRING.py",
    "category": "Step 17 - Tries",
    "step": "Step 17 - Tries",
    "difficulty": "Hard",
    "patterns": [
      "Trie",
      "String"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n# https://leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-i/description/\n\n\nclass TrieNode:\n    def __init__(self, val: str = '#') -> None:\n        self.val = val\n        self.children = [None for _ in range(26)]\n        self.isEnd = False\n\n\nclass Trie:\n    def __init__(self) -> None:\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        curr = self.root\n        i = 0\n        n = len(word)\n        while i < n:\n            index = ord(word[i]) - ord('a')\n            if curr.children[index] is not None:\n                curr = curr.children[index]\n            else:\n                curr.children[index] = TrieNode(word[i])\n                curr = curr.children[index]\n            i += 1\n        curr.isEnd = True\n\n    def search(self, target: str) -> bool:\n        i = 0\n        n = len(target)\n        curr = self.root\n        while i < n:\n            index = ord(target[i]) - ord('a')\n            if curr.children[index] is not None:\n                curr = curr.children[index]\n            else:\n                return False\n            i += 1\n        return curr.isEnd\n\n    def helper(self, target: str) -> int:\n        n = len(target)\n        dp = [-1 for _ in range(n)]\n\n        def memo(curr_index: int) -> int:\n            if curr_index >= n:\n                return 0\n            if dp[curr_index] != -1:\n                return dp[curr_index]\n            ans = int(1e9)\n            curr = self.root\n            for j in range(curr_index, n):\n                index = ord(target[j]) - ord('a')\n                if curr.children[index] is None:\n                    break\n                else:\n                    curr = curr.children[index]\n                    t = memo(j + 1)\n                    if t != int(1e9):\n                        ans = min(ans, t + 1)\n            dp[curr_index] = ans\n            return ans\n        res = memo(0)\n        return res if res < int(1e9) else -1\n\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        trie = Trie()\n        for word in words:\n            trie.insert(word)\n        return trie.helper(target)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "https://leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-i/description/",
    "hints": []
  },
  {
    "id": "step_17_-_tries_implement-trie",
    "title": "Implement Trie",
    "file_path": "Step 17 - Tries/IMPLEMENT-TRIE.py",
    "category": "Step 17 - Tries",
    "step": "Step 17 - Tries",
    "difficulty": "Easy",
    "patterns": [
      "Trie",
      "String"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional\n\n\nclass TrieNode:\n    def __init__(self, data: str = '#'):\n        self.data = data\n        self.isTerminal = False\n        self.children = [Optional[TrieNode] for _ in range(26)]\n        for i in range(26):  # initially every child is NULL\n            self.children[i] = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        n = len(word)\n        curr = self.root\n        i = 0\n        while i < n:\n            index = ord(word[i]) - ord('a')\n            if curr.children[index]:\n                curr = curr.children[index]\n            else:\n                curr.children[index] = TrieNode(word[i])\n                curr = curr.children[index]\n            i += 1\n        curr.isTerminal = True\n\n    def search(self, word: str) -> bool:\n        n = len(word)\n        curr = self.root\n        i = 0\n        while i < n:\n            index = ord(word[i]) - ord('a')\n            if curr.children[index]:\n                curr = curr.children[index]\n            else:\n                return False\n            i += 1\n        return curr.isTerminal\n\n    def startsWith(self, prefix: str) -> bool:\n        n = len(prefix)\n        curr = self.root\n        i = 0\n        while i < n:\n            index = ord(prefix[i]) - ord('a')\n            if curr.children[index]:\n                curr = curr.children[index]\n            else:\n                return False\n            i += 1\n        return True\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Your Trie object will be instantiated and called as such: obj = Trie() obj.insert(word) param_2 = obj.search(word) param_3 = obj.startsWith(prefix)",
    "hints": []
  },
  {
    "id": "step_17_-_tries_design-add-search-data-structure",
    "title": "Design Add Search Data Structure",
    "file_path": "Step 17 - Tries/DESIGN-ADD-SEARCH-DATA-STRUCTURE.py",
    "category": "Step 17 - Tries",
    "step": "Step 17 - Tries",
    "difficulty": "Easy",
    "patterns": [
      "Trie",
      "String"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional, List\n\n\nclass TrieNode:\n    def __init__(self, data: str = '#'):\n        self.data = data\n        self.children = [Optional[TrieNode] for _ in range(26)]\n        for i in range(26):\n            self.children[i] = None\n        self.isTerminal = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        n = len(word)\n        curr = self.root\n        i = 0\n        while i < n:\n            index = ord(word[i]) - ord('a')\n            if curr.children[index]:\n                curr = curr.children[index]\n            else:\n                curr.children[index] = TrieNode(word[i])\n                curr = curr.children[index]\n            i += 1\n        curr.isTerminal = True\n\n    def search(self, word: str) -> bool:  # used recursion here!\n        n = len(word)\n\n        def helper(curr: Optional[TrieNode], s: str, i: int) -> bool:\n            if i >= n:\n                return curr.isTerminal\n            if s[i] == '.':  # since '.' can be matched with any word -> we need to explore all possibilities\n                for j in range(26):\n                    if curr.children[j] and helper(curr.children[j], s, i + 1):\n                        return True\n                return False\n            else:\n                index = ord(s[i]) - ord('a')\n                if curr.children[index]:\n                    return helper(curr.children[index], s, i + 1)\n\n        return helper(self.root, word, 0)\n\n# Your WordDictionary object will be instantiated and called as such:\n# obj = WordDictionary()\n# obj.addWord(word)\n# param_2 = obj.search(word)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Your WordDictionary object will be instantiated and called as such: obj = WordDictionary() obj.addWord(word) param_2 = obj.search(word)",
    "hints": []
  },
  {
    "id": "step_05_+_18_-_strings_rabin-karp-repeated-string-match",
    "title": "Rabin Karp Repeated String Match",
    "file_path": "Step 05 + 18 - Strings/RABIN-KARP-REPEATED-STRING-MATCH.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "# For BEST Explanation see -> Abdul Bari YouTube Video\n\n# RABIN KARP ALGORITHM\nclass Solution:\n    def RabinKarp(self, text: str, pattern: str) -> bool:\n        n = len(text)\n        m = len(pattern)\n        if m > n:\n            return False\n        mod = 101\n        base = 256\n        p = t = 0\n        h = pow(base, m - 1) % mod\n        i = 0\n        while i < m:\n            p = (p * base + ord(pattern[i])) % mod\n            t = (t * base + ord(text[i])) % mod\n            i += 1\n        i = 0\n        while i <= n - m:\n            if p == t:\n                if text[i:i + m] == pattern:\n                    return True\n            j = i + m\n            if j < n:\n                t = (((t - ord(text[i]) * h) * base) + ord(text[j])) % mod\n                if t < 0:\n                    t = mod\n            i += 1\n        return False\n\n    def repeatedStringMatch(self, a: str, b: str) -> int:\n        n = len(a)\n        m = len(b)\n        max_attempt = m // n + 2\n        s = \"\"\n        # if not possible in max_attempts then it is certainly not possible!\n        for attempt in range(max_attempt):\n            s += a\n            if self.RabinKarp(s, b):\n                return attempt + 1\n        return -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "For BEST Explanation see -> Abdul Bari YouTube Video RABIN KARP ALGORITHM if not possible in max_attempts then it is certainly not possible!",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_longest-happy-prefix",
    "title": "Longest Happy Prefix",
    "file_path": "Step 05 + 18 - Strings/LONGEST-HAPPY-PREFIX.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "# Hint: Using LPS Table used in KMP Algorithm!\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = len(s)\n        i = 1\n        j = 0\n        lps = [0 for _ in range(n)]\n        while i < n:\n            if s[i] == s[j]:\n                j += 1\n                lps[i] = j\n                i += 1\n            else:\n                if j == 0:\n                    i += 1\n                else:\n                    j = lps[j - 1]\n        return s[-lps[n-1]:] if lps[-1] else \"\"",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Hint: Using LPS Table used in KMP Algorithm!",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_longest-common-prefix",
    "title": "Longest Common Prefix",
    "file_path": "Step 05 + 18 - Strings/LONGEST-COMMON-PREFIX.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        strs.sort()\n        n = len(strs)\n        i = 0\n        while i < min(len(strs[0]), len(strs[n - 1])) and strs[0][i] == strs[n - 1][i]:\n            i += 1\n        return strs[0][:i]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_sort-chars-by-freq",
    "title": "Sort Chars By Freq",
    "file_path": "Step 05 + 18 - Strings/SORT-CHARS-BY-FREQ.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Queue",
      "Collections"
    ],
    "solution_code": "from collections import defaultdict, Counter\nfrom queue import PriorityQueue\n\n\n# Approach 1\nclass Solution1:\n    def frequencySort(self, s: str) -> str:\n        # mp = defaultdict(int, {key: s.count(key) for key in set(s)})\n        mp = defaultdict(int, Counter(s))\n        pq = PriorityQueue()\n        for key, value in mp.items():\n            pq.put((-value, key))\n        ans = \"\"\n        while not pq.empty():\n            k, v = pq.get()\n            ans += v * (-k)\n        return ans\n\n\n# Approach 2\nclass Solution2:\n    def frequencySort(self, s: str) -> str:\n        mp = defaultdict(int, Counter(s))\n        temp = [(k, v) for k, v in mp.items()]\n        temp.sort(reverse=True, key=lambda x: x[1])\n        ans = \"\"\n        for c, f in temp:\n            ans += str(c) * f\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Approach 1 mp = defaultdict(int, {key: s.count(key) for key in set(s)}) Approach 2",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?",
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_roman-to-int",
    "title": "Roman To Int",
    "file_path": "Step 05 + 18 - Strings/ROMAN-TO-INT.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        mp = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000,\n            'z': 0\n        }\n        ans = 0\n        s = [c for c in s]\n        for i in range(1, len(s)):\n            if mp[s[i - 1]] < mp[s[i]] and mp[s[i - 1]] != 0:\n                ans += mp[s[i]] - mp[s[i - 1]]\n                s[i] = 'z'\n            else:\n                ans += mp[s[i - 1]]\n        ans += mp[s[-1]]\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_implement-atoi",
    "title": "Implement Atoi",
    "file_path": "Step 05 + 18 - Strings/IMPLEMENT-ATOI.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def __init__(self):\n        self.maxi = 2 ** 31 - 1\n        self.mini = -(2 ** 31)\n\n    def myAtoi(self, s: str) -> int:\n        s = s.lstrip()\n        sign = 1\n        if len(s):\n            if s[0] in ['+', '-']:\n                if s[0] == '-':\n                    sign = -1\n                s = s[1:]\n            ans = 0\n            for item in s:\n                if item.isdigit():\n                    ans = ans * 10 + int(item)\n                else:\n                    break\n            ans = ans * sign\n            return max(self.mini, min(self.maxi, ans))\n        else:\n            return 0\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_find-index-of-first-occurence",
    "title": "Find Index Of First Occurence",
    "file_path": "Step 05 + 18 - Strings/FIND-INDEX-OF-FIRST-OCCURENCE.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution1:\n    def strStr(self, s: str, t: str) -> int:\n        n = len(s)\n        m = len(t)\n        if m > n:\n            return -1\n        for i in range(n):\n            if s[i] == t[0]:\n                if i + m > n:\n                    continue\n                else:\n                    temp = s[i:i + m]\n                    if temp == t:\n                        return i\n        return -1\n\n\n# Just Python being Python!\nclass Solution2:\n    def strStr(self, s, t):\n        return s.find(t)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Just Python being Python!",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_count-palindromic-subseq",
    "title": "Count Palindromic Subseq",
    "file_path": "Step 05 + 18 - Strings/COUNT-PALINDROMIC-SUBSEQ.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "# Will do it using DP!\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Will do it using DP!",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_valid-anagrams",
    "title": "Valid Anagrams",
    "file_path": "Step 05 + 18 - Strings/VALID-ANAGRAMS.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "def validAnagram(s1: str, s2: str) -> bool:\n    return sorted(s1) == sorted(s2)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_check-rotation",
    "title": "Check Rotation",
    "file_path": "Step 05 + 18 - Strings/CHECK-ROTATION.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def areRotations(self, s1: str, s2: str):\n        if len(s1) != len(s2):\n            return False\n        s1 += s1\n        return s2 in s1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_longest-palindromic-substr",
    "title": "Longest Palindromic Substr",
    "file_path": "Step 05 + 18 - Strings/LONGEST-PALINDROMIC-SUBSTR.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n = len(s)\n        ans = \"\"\n\n        def helper(l: int, r: int):\n            nonlocal ans\n            while l >= 0 and r < n and s[l] == s[r]:\n                size = r - l + 1\n                if size > len(ans):\n                    ans = s[l:r + 1]\n                l -= 1\n                r += 1\n            return ans\n\n        for i in range(n):\n            left = right = i\n            ans = helper(left, right)\n            left = i\n            right = i + 1\n            ans = helper(left, right)\n\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_remove-outer-paranth",
    "title": "Remove Outer Paranth",
    "file_path": "Step 05 + 18 - Strings/REMOVE-OUTER-PARANTH.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def removeOuterParentheses(self, s: str) -> str:\n        cnt = 0\n        ans = \"\"\n        for c in s:\n            if c == \"(\":\n                if cnt:\n                    ans += c\n                else:\n                    ans += \"\"\n                cnt += 1\n            else:\n                if cnt > 1:\n                    ans += c\n                else:\n                    ans += \"\"\n                cnt -= 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_kmp-pattern-matching",
    "title": "Kmp Pattern Matching",
    "file_path": "Step 05 + 18 - Strings/KMP-PATTERN-MATCHING.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def strStr(self, text: str, pattern: str) -> int:\n        kmp = KMP()\n        return kmp.search(text, pattern)\n\n\nclass KMP:\n    def __init__(self):\n        pass\n\n    def lps(self, target: str):\n        m = len(target)\n        lps = [0] * m\n        i = 1\n        j = 0\n        while i < m:\n            if target[i] == target[j]:\n                j += 1\n                lps[i] = j\n                i += 1\n            else:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return lps\n\n    def search(self, text: str, pattern: str):\n        n = len(text)\n        m = len(pattern)\n        i = j = 0\n        lps = self.lps(pattern)\n        while i < n:\n            if text[i] == pattern[j]:\n                i += 1\n                j += 1\n\n            if j == m:\n                return i - j\n\n            elif i < n and text[i] != pattern[j]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_max-score-from-removing-substr",
    "title": "Max Score From Removing Substr",
    "file_path": "Step 05 + 18 - Strings/MAX-SCORE-FROM-REMOVING-SUBSTR.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def maximumGain(self, s: str, x: int, y: int) -> int:\n        ans = 0\n        if x >= y:\n            while True:\n                arr = s.split(\"ab\")\n                if len(arr) > 1:\n                    t = \"\".join(arr)\n                    n = len(s) - len(t)\n                    ans += (n // 2) * x\n                    s = t\n                else:\n                    break\n            while True:\n                arr = s.split(\"ba\")\n                if len(arr) > 1:\n                    t = \"\".join(arr)\n                    n = len(s) - len(t)\n                    ans += (n // 2) * y\n                    s = t\n                else:\n                    break\n        else:\n            while True:\n                arr = s.split(\"ba\")\n                if len(arr) > 1:\n                    t = \"\".join(arr)\n                    n = len(s) - len(t)\n                    ans += (n // 2) * y\n                    s = t\n                else:\n                    break\n            while True:\n                arr = s.split(\"ab\")\n                if len(arr) > 1:\n                    t = \"\".join(arr)\n                    n = len(s) - len(t)\n                    ans += (n // 2) * x\n                    s = t\n                else:\n                    break\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_sum-of-beauty-of-all-substr",
    "title": "Sum Of Beauty Of All Substr",
    "file_path": "Step 05 + 18 - Strings/SUM-OF-BEAUTY-OF-ALL-SUBSTR.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Hard",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from collections import defaultdict\n\n\n# Time Complexity: O(n^2*26)\nclass Solution1:\n    def beautySum(self, s: str) -> int:\n        cnt = 0\n        n = len(s)\n        for i in range(n):\n            mp = defaultdict(int)\n            for j in range(i, n):\n                mp[s[j]] += 1\n                maxi = 0\n                mini = 501\n                for k, v in mp.items():\n                    maxi = max(maxi, v)\n                    mini = min(mini, v)\n                cnt += (maxi - mini)\n        return cnt\n",
    "time_complexity": "O(n^2*26)",
    "space_complexity": null,
    "description": "Time Complexity: O(n^2*26)",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_largest-odd-num-in-string",
    "title": "Largest Odd Num In String",
    "file_path": "Step 05 + 18 - Strings/LARGEST-ODD-NUM-IN-STRING.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "import sys\n\nsys.set_int_max_str_digits(0)  # removing the limit on str to int conversion\n\n\nclass Solution:\n    def largestOddNumber(self, num: str) -> str:\n        num = int(num)\n        while num and not (num % 2):\n            num = num // 10\n        return str(num) if num > 0 else \"\"\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_min-add-to-make-parantheses",
    "title": "Min Add To Make Parantheses",
    "file_path": "Step 05 + 18 - Strings/MIN-ADD-TO-MAKE-PARANTHESES.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "# USING SC: O(N)\nclass Solution1:\n    def minAddToMakeValid(self, s: str) -> int:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append('(')\n            else:\n                if len(stack) and stack[-1] == '(':\n                    stack.pop()\n                else:\n                    stack.append(')')\n        return len(stack)\n\n\n# MOST OPTIMISED\nclass Solution2:\n    def minAddToMakeValid(self, s: str) -> int:\n        cnt1 = cnt2 = 0\n        for item in s:\n            if item == '(':\n                cnt1 += 1\n            else:\n                if cnt1 > 0:\n                    cnt1 -= 1\n                else:\n                    cnt2 += 1\n        return cnt1 + cnt2\n",
    "time_complexity": null,
    "space_complexity": "O(N)",
    "description": "USING SC: O(N) MOST OPTIMISED",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_rev-words",
    "title": "Rev Words",
    "file_path": "Step 05 + 18 - Strings/REV-WORDS.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        s = \" \".join((reversed(list(filter(lambda x: len(x) > 0, s.split(\" \"))))))\n        return s\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_shortest-palindrome",
    "title": "Shortest Palindrome",
    "file_path": "Step 05 + 18 - Strings/SHORTEST-PALINDROME.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class BruteForce:\n    def checkPalindrome(self, s: str) -> bool:\n        i = 0\n        n = len(s)\n        while i < n // 2:\n            if s[i] != s[n - 1 - i]:\n                return False\n            i += 1\n        return True\n\n    def shortestPalindrome(self, s: str) -> str:\n        i = 0\n        n = len(s)\n        rev = s[::-1]\n        while i < n:\n            temp = rev[:i] + s[:]\n            if self.checkPalindrome(temp):\n                return temp\n            i += 1\n        return rev + s\n\n\n# Python internally uses KMP Algorithm!\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        t = s[::-1]\n        n = len(s)\n        for i in range(n):\n            if s.startswith(t[i:]):\n                return t[:i] + s\n        return t + s\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Python internally uses KMP Algorithm!",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?",
      "Palindromes read the same forwards and backwards"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_count-say",
    "title": "Count Say",
    "file_path": "Step 05 + 18 - Strings/COUNT-SAY.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Iteration:\n    def countAndSay(self, n: int) -> str:\n        curr = '1'\n        for i in range(1, n):\n            cnt = 1\n            prev = curr[0]\n            i = 1\n            temp = \"\"\n            while i < len(curr):\n                if curr[i] == prev:\n                    cnt += 1\n                else:\n                    temp += str(cnt) + prev\n                    cnt = 1\n                    prev = curr[i]\n                i += 1\n            temp += str(cnt) + prev\n            curr = temp\n        return curr\n\n\nclass Recursive:\n    def helper(self, index: int, n: int, s: str):\n        if index == n:\n            return s\n        cnt = 1\n        prev = s[0]\n        i = 1\n        temp = \"\"\n        while i < len(s):\n            if s[i] == prev:\n                cnt += 1\n            else:\n                temp += str(cnt) + prev\n                cnt = 1\n                prev = s[i]\n            i += 1\n        temp += str(cnt) + prev\n        return self.helper(index + 1, n, temp)\n\n    def countAndSay(self, n: int) -> str:\n        return self.helper(1, n, \"1\")\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_05_+_18_-_strings_count-substrs",
    "title": "Count Substrs",
    "file_path": "Step 05 + 18 - Strings/COUNT-SUBSTRS.py",
    "category": "Step 05 + 18 - Strings",
    "step": "Step 05 + 18 - Strings",
    "difficulty": "Easy",
    "patterns": [
      "String",
      "Two Pointers",
      "Sliding Window"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from collections import defaultdict\n\n\n# Hint: Count Sub-arrays with K different integers (Sliding Window Problem)\n\n\nclass Solution1:\n    def substrCount(self, s: str, k: int) -> int:\n        # BRUTE FORCE\n        n = len(s)\n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                st = set(s[i:j + 1])\n                if len(st) == k:\n                    ans += 1\n        return ans\n\n\nclass Solution:\n    def substrCount(self, s: str, k: int) -> int:\n        return self.helper(s, k) - self.helper(s, k - 1)\n\n    def helper(self, s: str, k: int) -> int:\n        ans = i = j = 0\n        n = len(s)\n        mp = defaultdict(int)\n        while j < n:\n            mp[s[j]] += 1\n            while len(mp) > k:\n                mp[s[i]] -= 1\n                if not mp[s[i]]:\n                    mp.pop(s[i])\n                i += 1\n            ans += j - i + 1\n            j += 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Hint: Count Sub-arrays with K different integers (Sliding Window Problem) BRUTE FORCE",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_07_-_recursion_rat-in-a-maze",
    "title": "Rat In A Maze",
    "file_path": "Step 07 - Recursion/RAT-IN-A-MAZE.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def findPath(self, grid: List[List[int]]) -> List[str]:\n        n = len(grid)\n\n        if n == 1:\n            return []\n\n        ans = []\n\n        def helper(i: int, j: int, path: str):\n            if i == n - 1 and j == n - 1 and grid[i][j] == 1:\n                ans.append(path)\n                return\n            if 0 <= i < n and 0 <= j < n and grid[i][j] == 1:\n                row = [-1, 0, 1, 0]\n                col = [0, 1, 0, -1]\n                dir = ['U', 'R', 'D', 'L']\n                grid[i][j] = 0\n                for k in range(4):\n                    helper(i + row[k], j + col[k], path + dir[k])\n                grid[i][j] = 1\n            else:\n                return\n\n        helper(0, 0, \"\")\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_combination-sum-2",
    "title": "Combination Sum 2",
    "file_path": "Step 07 - Recursion/COMBINATION-SUM-2.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Hard",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        ans = []\n\n        def helper(arr: List[int], ind: int, n: int, temp: List[int], aim: int):\n            if aim == 0:\n                print(temp)\n                ans.append(temp)\n                return\n\n            for i in range(ind, n):\n                if i > ind and arr[i] == arr[i - 1]:\n                    continue\n                if arr[i] <= aim:\n                    temp2 = temp.copy()\n                    temp2.append(arr[i])\n                    helper(arr, i + 1, n, temp2, aim - arr[i])\n                else:\n                    break\n            return\n\n        helper(candidates, 0, len(candidates), [], target)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_subsets",
    "title": "Subsets",
    "file_path": "Step 07 - Recursion/SUBSETS.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        ans = []\n        n = len(nums)\n\n        def helper(ind: int, curr: List[int]):\n            if ind == n:\n                ans.append(curr)\n                return\n            # not-pick\n            helper(ind + 1, curr)\n            # pick\n            temp = curr.copy()\n            temp.append(nums[ind])\n            helper(ind+1, temp)  # method 1\n            # helper(ind + 1, curr+[nums[ind]]) -> method2\n\n        helper(0, [])\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "not-pick pick helper(ind + 1, curr+[nums[ind]]) -> method2",
    "hints": []
  },
  {
    "id": "step_07_-_recursion_combination-sum-3",
    "title": "Combination Sum 3",
    "file_path": "Step 07 - Recursion/COMBINATION-SUM-3.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Hard",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def combinationSum3(self, k: int, target: int) -> List[List[int]]:\n        arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        n = 9\n        ans = []\n\n        def helper(ind: int, aim: int, temp: List[int]) -> None:\n            if aim == 0 and len(temp) == k:\n                ans.append(temp)\n                return\n            if ind == n:\n                return\n            helper(ind + 1, aim, temp)\n            if arr[ind] <= aim:\n                temp2 = temp.copy()\n                temp2.append(arr[ind])\n                helper(ind + 1, aim - arr[ind], temp2)\n\n        helper(0, target, [])\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_generate-all-bin-strings",
    "title": "Generate All Bin Strings",
    "file_path": "Step 07 - Recursion/GENERATE-ALL-BIN-STRINGS.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def generateBinaryStrings(self, n):\n        ans = []\n\n        def helper(ind: int, s: str, prev=False) -> None:\n            if ind == n:\n                ans.append(s)\n                return\n            helper(ind + 1, s + \"0\", False)\n            if not prev:\n                helper(ind + 1, s + \"1\", True)\n\n        helper(0, \"\", False)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_word-break",
    "title": "Word Break",
    "file_path": "Step 07 - Recursion/WORD-BREAK.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict, Counter\n\n\n# Recursion Based\nclass Solution1:\n    def wordBreak(self, s: str, dic: List[str]) -> bool:\n        mp = defaultdict(int, Counter(dic))\n        n = len(s)\n\n        def helper(ind: int, words: List[str]):\n            if ind == n:\n                for word in words:\n                    if word not in mp:\n                        return False\n                return True\n            for i in range(ind + 1, n + 1):\n                text = s[ind:i]\n                words.append(text)\n                if helper(i, words):\n                    return True\n                words.pop()\n            return False\n\n        return helper(0, [])\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Recursion Based",
    "hints": []
  },
  {
    "id": "step_07_-_recursion_better-string",
    "title": "Better String",
    "file_path": "Step 07 - Recursion/BETTER-STRING.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import Dict\n\n\nclass Solution1:\n    def betterString(self, str1: str, str2: str):\n        set1 = set()\n        set2 = set()\n\n        def helper(ind: int, n: int, s: str, temp: str, st: set):\n            if ind == n:\n                st.add(temp)\n                return\n            helper(ind + 1, n, s, temp + s[ind], st)\n            helper(ind + 1, n, s, temp, st)\n\n        helper(0, len(str1), str1, \"\", set1)\n        helper(0, len(str2), str2, \"\", set2)\n\n        cnt1 = len(set1)\n        cnt2 = len(set2)\n        return str1 if cnt1 >= cnt2 else str2\n\n\nclass Solution:\n    def betterString(self, s1: str, s2: str):\n        set1 = {}\n        set2 = {}\n\n        def memo(ind: int, n: int, s: str, temp: str, st: Dict):\n            if ind == n:\n                return 1\n            if (ind, temp) in st:\n                return st[(ind, temp)]\n            include = memo(ind + 1, n, s, temp + s[ind], st)\n            exclude = memo(ind + 1, n, s, temp, st)\n            st[(ind, temp)] = include + exclude\n            return st[(ind, temp)]\n\n        cnt1 = memo(0, len(s1), s1, \"\", set1)\n        cnt2 = memo(0, len(s2), s2, \"\", set2)\n        return s1 if cnt1 >= cnt2 else s2\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_n-queen",
    "title": "N Queen",
    "file_path": "Step 07 - Recursion/N-QUEEN.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        mat = [\".\" * n for _ in range(n)]\n        ans = []\n\n        def isValid(i: int, j: int, board: List[str]):\n            if 'Q' in board[i][:j]:\n                return False\n            ci, cj = i - 1, j - 1\n            while ci >= 0 and cj >= 0:\n                if board[ci][cj] == 'Q':\n                    return False\n                ci -= 1\n                cj -= 1\n            ci, cj = i + 1, j - 1\n            while ci < n and cj >= 0:\n                if board[ci][cj] == 'Q':\n                    return False\n                ci += 1\n                cj -= 1\n            return True\n\n        def helper(ind: int, board: List[str]):\n            if ind == n:\n                ans.append(board)\n                return\n            for i in range(n):\n                if isValid(i, ind, board):\n                    temp = board.copy()\n                    temp[i] = temp[i][:ind] + 'Q' + temp[i][ind + 1:]\n                    helper(ind + 1, temp)\n\n        helper(0, mat)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_subset-sum-1",
    "title": "Subset Sum 1",
    "file_path": "Step 07 - Recursion/SUBSET-SUM-1.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def subsetSums(self, arr: List[int], n: int):\n        arr.sort()\n        ans = []\n\n        def helper(ind: int, curr: int) -> None:\n            if ind == n:\n                ans.append(curr)\n                return\n            helper(ind + 1, curr)\n            helper(ind + 1, curr + arr[ind])\n\n        helper(0, 0)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_subset-sum-2",
    "title": "Subset Sum 2",
    "file_path": "Step 07 - Recursion/SUBSET-SUM-2.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans = []\n        n = len(nums)\n        nums.sort()\n\n        def helper(ind: int, temp: List[int]) -> None:\n            ans.append(temp)\n            for i in range(ind, n):\n                if i > ind and nums[i] == nums[i - 1]:\n                    continue\n                # pick and not pick at index\n                # helper(i + 1, temp)\n                temp2 = temp.copy()\n                temp2.append(nums[i])\n                helper(i + 1, temp2)\n\n        helper(0, [])\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "pick and not pick at index helper(i + 1, temp)",
    "hints": []
  },
  {
    "id": "step_07_-_recursion_reverse-stack",
    "title": "Reverse Stack",
    "file_path": "Step 07 - Recursion/REVERSE-STACK.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def insert_at_bottom(self, stack: List[int], item: int):\n        if not len(stack):\n            stack.append(item)\n        else:\n            a = stack.pop()\n            self.insert_at_bottom(stack, item)\n            stack.append(a)\n\n    def helper(self, stack: List[int]):\n        if not len(stack):\n            return\n        a = stack.pop()\n        self.helper(stack)\n        self.insert_at_bottom(stack, a)\n\n    def reverse(self, stack: List[int]):\n        self.helper(stack)\n        return stack\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_word-search",
    "title": "Word Search",
    "file_path": "Step 07 - Recursion/WORD-SEARCH.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        n = len(board)\n        m = len(board[0])\n        size = len(word)\n\n        def isValid(ni: int, nj: int):\n            return 0 <= ni < n and 0 <= nj < m\n\n        def helper(ind: int, i: int, j: int) -> bool:\n            if ind == size:  # base condition\n                return True\n            if not isValid(i, j) or board[i][j] != word[ind]:\n                return False\n            row = [-1, 0, 1, 0]\n            col = [0, 1, 0, -1]\n            temp = board[i][j]\n            board[i][j] = '#'\n            for k in range(4):\n                ni, nj = i + row[k], j + col[k]\n                if helper(ind + 1, ni, nj):\n                    return True\n            board[i][j] = temp\n            return False\n\n        for i in range(n):\n            for j in range(m):\n                if helper(0, i, j):\n                    return True\n        return False\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_phone-number",
    "title": "Phone Number",
    "file_path": "Step 07 - Recursion/PHONE-NUMBER.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        keypad = {\n            1: \"\",\n            2: \"abc\",\n            3: \"def\",\n            4: \"ghi\",\n            5: \"jkl\",\n            6: \"mno\",\n            7: \"pqrs\",\n            8: \"tuv\",\n            9: \"wxyz\"\n        }\n        n = len(digits)\n        if n:\n            ans = []\n\n            def helper(ind: int, curr: str) -> None:\n                if ind == n:\n                    ans.append(curr)\n                    return\n                key = int(digits[ind])\n                val = keypad[key]\n                for i in range(len(val)):\n                    helper(ind + 1, curr + val[i])\n\n            helper(0, \"\")\n            return ans\n        else:\n            return []\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_m-coloring-problem",
    "title": "M Coloring Problem",
    "file_path": "Step 07 - Recursion/M-COLORING-PROBLEM.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\ndef graphColoring(edges: List[List[int]], m: int, n: int):\n    color = [0 for _ in range(n)]\n\n    def isValid(col: int, node: int) -> bool:\n        for i in range(n):\n            if edges[node][i] and color[i] == col:\n                return False\n        return True\n\n    def helper(node: int) -> bool:\n        if node == n:\n            return True\n        for i in range(1, m + 1):\n            if isValid(i, node):\n                color[node] = i\n                if helper(node + 1):\n                    return True\n                color[node] = 0\n        return False\n\n    return helper(0)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_combination-sum-1",
    "title": "Combination Sum 1",
    "file_path": "Step 07 - Recursion/COMBINATION-SUM-1.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Hard",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        ans = set()\n\n        def helper(arr: List[int], ind: int, n: int, temp: List[int], aim: int):\n            if ind == n:\n                if not aim:\n                    ans.add(tuple(temp))\n                return\n            if arr[ind] <= aim:\n                temp2 = temp[:]\n                temp2.append(arr[ind])\n                helper(arr, ind, n, temp2, aim - arr[ind])\n            helper(arr, ind + 1, n, temp, aim)\n            return\n\n        helper(candidates, 0, len(candidates), [], target)\n        return list(map(lambda x: list(x), ans))\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_07_-_recursion_palindrome-partitioning",
    "title": "Palindrome Partitioning",
    "file_path": "Step 07 - Recursion/PALINDROME-PARTITIONING.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n        n = len(s)\n\n        def isPalindrome(t: str) -> bool:\n            m = len(t)\n            if m <= 1:\n                return True\n            for i in range(m // 2):\n                if t[i] != t[m - 1 - i]:\n                    return False\n            return True\n\n        def helper(ind: int, text: str, curr: List[str]):\n            if ind == n:  # base condition\n                for item in curr:\n                    if not isPalindrome(item):\n                        return\n                ans.append(curr)\n                return\n\n            for i in range(ind + 1, n + 1):\n                temp = curr.copy()\n                temp.append(text[ind:i])\n                helper(i, text, temp)\n\n        helper(0, s, [])\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Palindromes read the same forwards and backwards"
    ]
  },
  {
    "id": "step_07_-_recursion_sudoku-solver",
    "title": "Sudoku Solver",
    "file_path": "Step 07 - Recursion/SUDOKU-SOLVER.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        n = 9\n\n        def isValid(sud: List[List[str]], row: int, col: int, c: str) -> bool:\n            # check same row\n            for j in range(n):\n                if sud[row][j] == c:\n                    return False\n            # check same col\n            for i in range(n):\n                if sud[i][col] == c:\n                    return False\n            for i in range(n):\n                if sud[3 * (row // 3) + (i // 3)][3 * (col // 3) + (i % 3)] == c:\n                    return False\n            return True\n\n        def helper(sud: List[List[str]]) -> bool:\n            for i in range(n):\n                for j in range(n):\n                    if sud[i][j] == '.':\n                        for k in range(1, 10):\n                            c = str(k)\n                            if isValid(sud, i, j, c):\n                                sud[i][j] = c\n                                if helper(sud):\n                                    return True\n                                sud[i][j] = '.'\n                        return False\n            return True\n\n        helper(board)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "check same row check same col",
    "hints": []
  },
  {
    "id": "step_07_-_recursion_generate-parantheses",
    "title": "Generate Parantheses",
    "file_path": "Step 07 - Recursion/GENERATE-PARANTHESES.py",
    "category": "Step 07 - Recursion",
    "step": "Step 07 - Recursion",
    "difficulty": "Easy",
    "patterns": [
      "Recursion",
      "Backtracking"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        ans = []\n\n        def helper(ind: int, a: int, b: int, s: str) -> None:\n            if ind == n:\n                ans.append(s)\n                return\n            if a < n:\n                helper(ind + 1, a + 1, b, s + '(')\n            if a > 0 and b < a:\n                helper(ind + 1, a, b + 1, s + ')')\n\n        helper(0, 0, 0, \"\")\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_10_-_sliding_window_substring-containing-all-three-chars",
    "title": "Substring Containing All Three Chars",
    "file_path": "Step 10 - Sliding Window/SUBSTRING-CONTAINING-ALL-THREE-CHARS.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Easy",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from collections import defaultdict\n\n\nclass Solution1:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        count = 0\n        for i in range(n - 2):\n            mp = defaultdict(int)\n            for j in range(i, n):\n                mp[s[j]] += 1\n                if len(mp) >= 3:\n                    count += 1\n        return count\n\n\nclass Solution2:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        count = 0\n        for i in range(n - 2):\n            mp = defaultdict(int)\n            for j in range(i, n):\n                mp[s[j]] += 1\n                if len(mp) >= 3:\n                    count += (n - j)\n                    break\n        return count\n\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        ans = i = j = 0\n        mp = defaultdict(int)\n        while j < n:\n            mp[s[j]] += 1\n            while len(mp) >= 3:\n                ans += (n - j)\n                mp[s[i]] -= 1\n                if mp[s[i]] == 0:\n                    mp.pop(s[i])\n                i += 1\n            j += 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_10_-_sliding_window_longest-substr-rep-chars",
    "title": "Longest Substr Rep Chars",
    "file_path": "Step 10 - Sliding Window/LONGEST-SUBSTR-REP-CHARS.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Easy",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from collections import defaultdict\n\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        n = len(s)\n        if n <= 1:\n            return n\n        ans = i = 0\n        count = defaultdict(int)\n        for j in range(n):\n            count[s[j]] += 1\n            while i < j and count[s[j]] > 1:\n                count[s[i]] -= 1\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_10_-_sliding_window_count-k-uniq-elem-subarray",
    "title": "Count K Uniq Elem Subarray",
    "file_path": "Step 10 - Sliding Window/COUNT-K-UNIQ-ELEM-SUBARRAY.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Easy",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from collections import defaultdict\nfrom typing import List\n\n\nclass Solution:\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        def helper(count: int) -> int:\n            i = j = ans = 0\n            mp = defaultdict(int)\n            while j < n:\n                mp[nums[j]] += 1\n                while len(mp) > count:\n                    mp[nums[i]] -= 1\n                    if mp[nums[i]] == 0:\n                        mp.pop(nums[i])\n                    i += 1\n                ans += j - i + 1\n                j += 1\n            return ans\n\n        return helper(k) - helper(k - 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_10_-_sliding_window_min-window-substring",
    "title": "Min Window Substring",
    "file_path": "Step 10 - Sliding Window/MIN-WINDOW-SUBSTRING.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Easy",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from collections import defaultdict, Counter\nimport sys\n\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        n, m = len(s), len(t)\n        if m > n:\n            return \"\"\n        mp = defaultdict(int, Counter(t))\n        count = m\n        size = sys.maxsize\n        start = i = j = 0\n        while j < n:\n            if s[j] in mp and mp[s[j]] > 0:\n                count -= 1\n            mp[s[j]] -= 1\n            while count == 0:\n                if j - i + 1 < size:\n                    size = j - i + 1\n                    start = i\n                mp[s[i]] += 1\n                if mp[s[i]] > 0:\n                    count += 1\n                i += 1\n            j += 1\n        if size != sys.maxsize:\n            return s[start:start+size]\n        else:\n            return \"\"\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_10_-_sliding_window_fruits-baskets",
    "title": "Fruits Baskets",
    "file_path": "Step 10 - Sliding Window/FRUITS-BASKETS.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Easy",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\n# SIMILAR TO MAX CONSECUTIVE ONES\n\n\nclass Solution:\n    def sumSubarrayMins(self, n: int, fruits: List[int]):\n        k = 2  # baskets\n        ans = i = j = 0\n        n = len(fruits)\n        mp = defaultdict(int)\n        while j < n:\n            mp[fruits[j]] += 1\n            if len(mp) > k:\n                ans = max(ans, j - i)\n                while i < j and len(mp) > k:\n                    mp[fruits[i]] -= 1\n                    if mp[fruits[i]] == 0:\n                        mp.pop(fruits[i])\n                    i += 1\n            j += 1\n        ans = max(ans, j-i)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "SIMILAR TO MAX CONSECUTIVE ONES",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_10_-_sliding_window_max-consec-ones",
    "title": "Max Consec Ones",
    "file_path": "Step 10 - Sliding Window/MAX-CONSEC-ONES.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Easy",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def longestOnes(self, nums: List[int], k: int) -> int:\n        count = i = j = ans = 0\n        n = len(nums)\n        while j < n:\n            if nums[j] == 0:\n                count += 1\n            if count > k:\n                ans = max(ans, j - i)\n                while i <= j and count > k:\n                    if nums[i] == 0:\n                        count -= 1\n                    i += 1\n            j += 1\n        ans = max(ans, j - i)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_10_-_sliding_window_longest-k-uniq-chars-substring",
    "title": "Longest K Uniq Chars Substring",
    "file_path": "Step 10 - Sliding Window/LONGEST-K-UNIQ-CHARS-SUBSTRING.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Easy",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from collections import defaultdict\n\n\nclass Solution:\n    def longestKSubstr(self, s: str, k: int):\n        ans, n = -1, len(s)\n        # print(n)\n        i = j = 0\n        mp = defaultdict(int)\n        while j < n:\n            mp[s[j]] += 1\n            while len(mp) > k:\n                ans = max(ans, j - i)\n                mp[s[i]] -= 1\n                if mp[s[i]] == 0:\n                    mp.pop(s[i])\n                i += 1\n            j += 1\n            if len(mp) == k:  # handles the edge case when the last subarray (when j becomes n) is also valid for us\n                ans = max(ans, j-i)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "print(n)",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_10_-_sliding_window_longest-rep-chars-replace",
    "title": "Longest Rep Chars Replace",
    "file_path": "Step 10 - Sliding Window/LONGEST-REP-CHARS-REPLACE.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Easy",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from collections import defaultdict\n\n\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        mp = defaultdict(int)\n        values = mp.values()\n        i = j = ans = 0\n        n = len(s)\n        mp[s[j]] += 1\n        while j < n:\n            curr = j - i + 1\n            max_freq = max(values)\n            if curr - max_freq <= k:\n                print(i, j)\n                ans = max(ans, curr)\n                j += 1\n                if j < n:\n                    mp[s[j]] += 1\n            else:\n                mp[s[i]] -= 1\n                i += 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_10_-_sliding_window_binary-subarr-with-goal",
    "title": "Binary Subarr With Goal",
    "file_path": "Step 10 - Sliding Window/BINARY-SUBARR-WITH-GOAL.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Medium",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\n\n# USING TECHNIQUE USED IN PROBLEM 'Count number of sub-arrays with given sum'\nclass Solution1:\n    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:\n        ans = pref = 0\n        mp = defaultdict(int)\n        mp[0] += 1\n        for item in nums:\n            pref += item\n            x = pref - goal\n            ans += mp[x]\n            mp[pref] += 1\n        return ans\n\n\n# USING SLIDING WINDOW\nclass Solution:\n    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:\n        def helper(target):\n            ans = temp = i = j = 0\n            n = len(nums)\n            while j < n:\n                temp += nums[j]\n                while i <= j and temp > target:\n                    temp -= nums[i]\n                    i += 1\n                ans += (j - i + 1)\n                j += 1\n            return ans\n        return helper(goal) - helper(goal-1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "USING TECHNIQUE USED IN PROBLEM 'Count number of sub-arrays with given sum' USING SLIDING WINDOW",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_10_-_sliding_window_nice-subarray",
    "title": "Nice Subarray",
    "file_path": "Step 10 - Sliding Window/NICE-SUBARRAY.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Easy",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        nums = list(map(lambda x: x % 2, nums))\n        n = len(nums)\n\n        def helper(target):\n            ans = temp = i = j = 0\n            while j < n:\n                temp += nums[j]\n                while temp > target:\n                    temp -= nums[i]\n                    i += 1\n                ans += (j - i + 1)\n                j += 1\n            return ans\n\n        return helper(k) - helper(k - 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_10_-_sliding_window_max-points-obtained-from-cards",
    "title": "Max Points Obtained From Cards",
    "file_path": "Step 10 - Sliding Window/MAX-POINTS-OBTAINED-FROM-CARDS.py",
    "category": "Step 10 - Sliding Window",
    "step": "Step 10 - Sliding Window",
    "difficulty": "Easy",
    "patterns": [
      "Sliding Window",
      "Two Pointers"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\n# USING DYNAMIC PROGRAMMING\nclass Solution1:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        dp = [[-1 for _ in range(n)] for _ in range(n)]\n\n        def pussy(i, j, count):\n            if count == 0:\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            op1 = cardPoints[i] + pussy(i + 1, j, count - 1)\n            op2 = cardPoints[j] + pussy(i, j - 1, count - 1)\n            dp[i][j] = max(op1, op2)\n            return dp[i][j]\n\n        return pussy(0, n - 1, k)\n\n\n# USING SLIDING WINDOW\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        if k == n:\n            return sum(cardPoints)\n        window = n - k\n        curr = mini = sum(cardPoints[:window])\n        for i in range(window, n):\n            print(mini, curr)\n            curr = curr + cardPoints[i] - cardPoints[i - window]\n            mini = min(mini, curr)\n        return sum(cardPoints) - mini\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "USING DYNAMIC PROGRAMMING USING SLIDING WINDOW",
    "hints": [
      "Consider using two pointers technique",
      "Can you solve this with a sliding window approach?"
    ]
  },
  {
    "id": "step_01_-_basics_check-palindrome",
    "title": "Check Palindrome",
    "file_path": "Step 01 - Basics/CHECK-PALINDROME.py",
    "category": "Step 01 - Basics",
    "step": "Step 01 - Basics",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    @staticmethod\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        s = str(x)\n        t = s[::-1]\n        return s == t\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Palindromes read the same forwards and backwards"
    ]
  },
  {
    "id": "step_01_-_basics_lcm-gcd",
    "title": "Lcm Gcd",
    "file_path": "Step 01 - Basics/LCM-GCD.py",
    "category": "Step 01 - Basics",
    "step": "Step 01 - Basics",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def lcmAndGcd(self, A, B):\n        # Using Euclidean Maths\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        gcd = gcd(A, B)\n        lcm = (A * B) // gcd\n        return [lcm, gcd]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Using Euclidean Maths",
    "hints": []
  },
  {
    "id": "step_01_-_basics_armstrong-number",
    "title": "Armstrong Number",
    "file_path": "Step 01 - Basics/ARMSTRONG-NUMBER.py",
    "category": "Step 01 - Basics",
    "step": "Step 01 - Basics",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def armstrongNumber (self, n):\n        n = str(n)\n        temp = 0\n        for i in n:\n            temp += int(i)**3\n        return str(temp == int(n)).lower()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_01_-_basics_count-primes",
    "title": "Count Primes",
    "file_path": "Step 01 - Basics/COUNT-PRIMES.py",
    "category": "Step 01 - Basics",
    "step": "Step 01 - Basics",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def isPrime(self, n):\n        \"\"\"\n        SIEVE OF ERATOSTHENES\n        \"\"\"\n        arr = [True for _ in range(n)]\n        p = 2\n        while p * p <= n:\n            if arr[p]:\n                for i in range(p * p, n, p):\n                    arr[i] = False\n            p += 1\n        return arr\n\n    def countPrimes(self, n: int) -> int:\n        arr = self.isPrime(n)\n        count = sum(1 for i in arr[2:] if i)\n        return count\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "SIEVE OF ERATOSTHENES",
    "hints": []
  },
  {
    "id": "step_01_-_basics_all-divisors",
    "title": "All Divisors",
    "file_path": "Step 01 - Basics/ALL-DIVISORS.py",
    "category": "Step 01 - Basics",
    "step": "Step 01 - Basics",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def sumOfDivisors(self, N):\n        \"\"\"\n        hint: calculate how many times the number 'i' fits into N\n        \"\"\"\n        ans = 0\n        for i in range(1, N+1):\n            k = N // i\n            ans += (i * k)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "hint: calculate how many times the number 'i' fits into N",
    "hints": []
  },
  {
    "id": "step_01_-_basics_reverse-number",
    "title": "Reverse Number",
    "file_path": "Step 01 - Basics/REVERSE-NUMBER.py",
    "category": "Step 01 - Basics",
    "step": "Step 01 - Basics",
    "difficulty": "Easy",
    "patterns": [
      "General"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    @staticmethod\n    def reverse(x: int) -> int:\n        s = str(x)\n        res, low, high = 0, -(2**31), (2**31)\n        if s[0] == '-':\n            s = s[1:]\n            s = s[::-1]\n            res = -1 * int(s)\n        else:\n            s = s[::-1]\n            res = int(s)\n        return 0 if res not in range(low, high) else res\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_11_-_heaps_divide-arr-in-sets-of-k-consec-numbers",
    "title": "Divide Arr In Sets Of K Consec Numbers",
    "file_path": "Step 11 - Heaps/DIVIDE-ARR-IN-SETS-OF-K-CONSEC-NUMBERS.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Easy",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Heap",
      "Collections"
    ],
    "solution_code": "import heapq\nfrom typing import List\nfrom collections import defaultdict, Counter\nfrom sortedcontainers import SortedDict\n\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        counts = Counter(nums)\n        heapq.heapify(nums)\n        mp = defaultdict(int, counts)\n        print(mp)\n        while len(nums):\n            curr = heapq.heappop(nums)\n            print(curr)\n            if curr in mp:\n                for i in range(curr, curr + k):\n                    if i in mp:\n                        mp[i] -= 1\n                        if mp[i] == 0:\n                            mp.pop(i)\n                    else:\n                        return False\n        return True\n\n\n# BRUTE FORCE -> USING SortedDict (Hashtable)\nclass Solution1:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n % k:\n            return False\n        mp = SortedDict(Counter(nums))\n        while len(mp):\n            for key, value in mp.items():\n                curr = key\n                for i in range(curr, curr + k):\n                    if i in mp:\n                        mp[i] -= 1\n                        if mp[i] == 0:\n                            mp.pop(i)\n                    else:\n                        return False\n                break\n        return True\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "BRUTE FORCE -> USING SortedDict (Hashtable)",
    "hints": []
  },
  {
    "id": "step_11_-_heaps_replace-with-rank",
    "title": "Replace With Rank",
    "file_path": "Step 11 - Heaps/REPLACE-WITH-RANK.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Easy",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from collections import defaultdict\nfrom typing import List\n\n# Not a Heap Problem\n\nclass Solution:\n    def replaceWithRank(self, n: int, arr: List[int]):\n        temp = sorted(arr)\n        mp = defaultdict(int)\n        k = 1\n        for i in range(n):\n            if temp[i] not in mp:\n                mp[temp[i]] = k\n                k += 1\n        arr = [mp[item] for item in arr]\n        return arr\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Not a Heap Problem",
    "hints": []
  },
  {
    "id": "step_11_-_heaps_median-data-stream",
    "title": "Median Data Stream",
    "file_path": "Step 11 - Heaps/MEDIAN-DATA-STREAM.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Hard",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Heap"
    ],
    "solution_code": "import heapq\n\n'''\nHint: We do not need whole array but only that two element which make up the median. Divide & Conquer!\nProblem is not hard, but is having a lot edge cases!\nnums: [5, 15, 1, 3] -> [5, 10, 5, 4] : median\n'''\n\nclass MedianFinder:\n    def __init__(self):\n        self.maxheap = []\n        self.minheap = []\n\n    def addNum(self, num: int) -> None:\n        if not (len(self.maxheap) + len(self.minheap)):\n            heapq.heappush(self.maxheap, -num)\n        elif len(self.maxheap) == len(self.minheap):\n            if num < self.minheap[0]:\n                heapq.heappush(self.maxheap, -num)\n            else:\n                heapq.heappush(self.maxheap, -heapq.heappop(self.minheap))\n                heapq.heappush(self.minheap, num)\n        else:\n            if len(self.minheap) == 0:\n                if num > -self.maxheap[0]:\n                    heapq.heappush(self.minheap, num)\n                else:\n                    heapq.heappush(self.minheap, -heapq.heappop(self.maxheap))\n                    heapq.heappush(self.maxheap, -num)\n            elif num >= self.minheap[0]:\n                heapq.heappush(self.minheap, num)\n            else:\n                if num < -self.maxheap[0]:\n                    heapq.heappush(self.minheap, -heapq.heappop(self.maxheap))\n                    heapq.heappush(self.maxheap, -num)\n                else:\n                    heapq.heappush(self.minheap, num)\n\n    def findMedian(self) -> float:\n        if len(self.maxheap) > len(self.minheap):\n            return -self.maxheap[0]\n        else:\n            return (-self.maxheap[0] + self.minheap[0]) / 2\n\n# Your MedianFinder object will be instantiated and called as such:\n# obj = MedianFinder()\n# obj.addNum(num)\n# param_2 = obj.findMedian()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Hint: We do not need whole array but only that two element which make up the median. Divide & Conquer! Problem is not hard, but is having a lot edge cases! nums: [5, 15, 1, 3] -> [5, 10, 5, 4] : median",
    "hints": []
  },
  {
    "id": "step_11_-_heaps_max-combination-sum",
    "title": "Max Combination Sum",
    "file_path": "Step 11 - Heaps/MAX-COMBINATION-SUM.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Hard",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List\nfrom queue import PriorityQueue\n\n\nclass Solution:\n    def maxCombinations(self, n: int, k: int, a: List[int], b: List[int]):\n        a.sort()\n        b.sort()\n        st = set()\n        pq = PriorityQueue()\n        pq.put((-(a[n - 1] + b[n - 1]), n - 1, n - 1))\n        st.add((n - 1, n - 1))\n        ans = []\n        while not pq.empty() and len(ans) < k:\n            curr, ci, cj = pq.get()\n            ans.append(-curr)\n            if len(ans) == k:\n                return ans\n            ti, tj = ci - 1, cj - 1\n            if ti >= 0 and (ti, cj) not in st:\n                pq.put((-(a[ti] + b[cj]), ti, cj))\n                st.add((ti, cj))\n            if tj >= 0 and (ci, tj) not in st:\n                pq.put((-(a[ci] + b[tj]), ci, tj))\n                st.add((ci, tj))\n\n        return [-1] if not (len(ans)) else ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_11_-_heaps_task-scheduler",
    "title": "Task Scheduler",
    "file_path": "Step 11 - Heaps/TASK-SCHEDULER.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Easy",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Heap",
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import deque, Counter\nimport heapq\n\n\nclass Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        tasks = [-count for count in Counter(tasks).values()]\n        print(tasks)\n        heapq.heapify(tasks)\n        time = 1\n        q = deque()\n        while len(tasks) or len(q):\n            if len(tasks):\n                count = heapq.heappop(tasks)\n                count += 1\n                if count:\n                    q.append((time + n, count))\n            if len(q):\n                if time == q[0][0]:\n                    heapq.heappush(tasks, q.popleft()[1])\n            time += 1\n        return time - 1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_11_-_heaps_merge-k-sorted-arr",
    "title": "Merge K Sorted Arr",
    "file_path": "Step 11 - Heaps/MERGE-K-SORTED-ARR.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Easy",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Queue",
      "Heap"
    ],
    "solution_code": "from typing import List\nimport heapq\nfrom queue import PriorityQueue\n\n'''\nheapq and PriorityQueue both are methods that can be used to implement Heaps in Python.\nheapq have functions like heapq.heapify(_iterable), heapq.heappop(_iterable), heapq.heappush(_iterable)\nPriorityQueue has functions like .put(_item), .get()\nNOTE: Both implement min-heap!   \n'''\n\n\nclass Solution:\n    def mergeKArrays(self, arr: List[List[int]], k: int):\n        pq = PriorityQueue()\n        for i in range(k):\n            pq.put((arr[i][0], i, 0))\n        ans = []\n        while not pq.empty():\n            item, row, col = pq.get()\n            ans.append(item)\n            if col+1 < k:\n                pq.put((arr[row][col+1], row, col+1))\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "heapq and PriorityQueue both are methods that can be used to implement Heaps in Python. heapq have functions like heapq.heapify(_iterable), heapq.heappop(_iterable), heapq.heappush(_iterable) PriorityQueue has functions like .put(_item), .get() NOTE: Both implement min-heap!",
    "hints": [
      "Think about different sorting algorithms and their properties",
      "Consider the merge operation in merge sort"
    ]
  },
  {
    "id": "step_11_-_heaps_heap-sort",
    "title": "Heap Sort",
    "file_path": "Step 11 - Heaps/HEAP-SORT.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Medium",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "class Solution:\n    # Max Heap\n    def heapify(self, arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            self.heapify(arr, n, largest)\n\n    def buildHeap(self, arr, n):\n        pass\n\n    def HeapSort(self, arr, n):\n        for i in range(n // 2, -1, -1):\n            self.heapify(arr, n, i)\n        size = n\n        while size > 0:\n            arr[0], arr[size - 1] = arr[size - 1], arr[0]\n            size -= 1\n            self.heapify(arr, size, 0)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Max Heap",
    "hints": [
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_11_-_heaps_kth-largest-in-stream",
    "title": "Kth Largest In Stream",
    "file_path": "Step 11 - Heaps/KTH-LARGEST-IN-STREAM.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Easy",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Heap"
    ],
    "solution_code": "from typing import List\nimport heapq\n\n'''\nHint: kth largest element in a k-sized array would be the smallest element in that array! -> use min-heap\n'''\n\nclass KthLargest:\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.nums = nums\n        heapq.heapify(self.nums)\n        while len(nums) > k:\n            heapq.heappop(self.nums)\n\n    def add(self, val: int) -> int:\n        heapq.heappush(self.nums, val)\n        while len(self.nums) > self.k:\n            heapq.heappop(self.nums)\n        return self.nums[0]\n\n# Your KthLargest object will be instantiated and called as such:\n# obj = KthLargest(k, nums)\n# param_1 = obj.add(val)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Hint: kth largest element in a k-sized array would be the smallest element in that array! -> use min-heap",
    "hints": []
  },
  {
    "id": "step_11_-_heaps_design-twitter",
    "title": "Design Twitter",
    "file_path": "Step 11 - Heaps/DESIGN-TWITTER.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Hard",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Queue",
      "Heap",
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\nimport heapq\nfrom queue import Queue\n\n'''\nThis problem has multiple implementations!\nIt can be done using 1: heapq and map or 2: only map.s\nTime Complexity in both would be the same approx.!\n'''\n\n\nclass Twitter:\n    def __init__(self):\n        self.following = defaultdict(set)\n        self.time = 1\n        self.timeline = []\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        heapq.heappush(self.timeline, (-self.time, tweetId, userId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        feed = []\n        q = Queue()\n        while len(feed) < 10 and len(self.timeline):\n            t, t_id, u_id = heapq.heappop(self.timeline)\n            q.put((t, t_id, u_id))\n            if u_id in self.following[userId] or u_id == userId:\n                feed.append(t_id)\n        while not q.empty():\n            heapq.heappush(self.timeline, q.get())\n        return feed\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followeeId in self.following[followerId]:\n            self.following[followerId].remove(followeeId)\n\n# Your Twitter object will be instantiated and called as such:\n# obj = Twitter()\n# obj.postTweet(userId,tweetId)\n# param_2 = obj.getNewsFeed(userId)\n# obj.follow(followerId,followeeId)\n# obj.unfollow(followerId,followeeId)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "This problem has multiple implementations! It can be done using 1: heapq and map or 2: only map.s Time Complexity in both would be the same approx.!",
    "hints": []
  },
  {
    "id": "step_11_-_heaps_intro-implement",
    "title": "Intro Implement",
    "file_path": "Step 11 - Heaps/INTRO-IMPLEMENT.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Easy",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List\n\n\n# MIN-HEAP\nclass Heap:\n    def __init__(self, arr: List[int]):\n        self.heap = arr\n        self.heapify()\n\n    def insert(self, val: int):\n        self.heap.append(val)\n        self.heapify()\n\n    def helper(self, arr: List[int], index: int):\n        smallest = index\n        left = 2 * index + 1\n        right = 2 * index + 2\n        n = len(arr)\n        if left < n and arr[left] < arr[smallest]:\n            smallest = left\n        if right < n and arr[right] < arr[smallest]:\n            smallest = right\n        if smallest != index:\n            arr[smallest], arr[index] = arr[index], arr[smallest]\n            self.helper(arr, smallest)\n\n    def heapify(self):\n        arr = self.heap\n        n = len(arr)\n        for i in range(n // 2, -1, -1):\n            self.helper(arr, i)\n\n    def print(self):\n        print(self.heap)\n\n    def pop(self):\n        self.heap.pop(0)\n        self.heapify()\n\n\nnums = [21, 12, 31, 12, 10, 19]\nheap = Heap(nums)\n\nheap.print()\nheap.insert(1)\nheap.print()\nheap.pop()\nheap.pop()\nheap.print()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "MIN-HEAP",
    "hints": []
  },
  {
    "id": "step_11_-_heaps_merge-k-linkedlists",
    "title": "Merge K Linkedlists",
    "file_path": "Step 11 - Heaps/MERGE-K-LINKEDLISTS.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Easy",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Queue"
    ],
    "solution_code": "from typing import List, Optional\nfrom queue import PriorityQueue\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        pq = PriorityQueue()\n        ans = curr = ListNode(-1)\n        i = 0\n        '''\n        \"i\" is used to act as second comparator for PriorityQueue in case when node.val gets equal for two nodes. Since\n        head (a pointer or object instance) cant be used to compare.\n        '''\n        for heads in lists:\n            if heads:\n                pq.put((heads.val, i, heads))\n            i += 1\n        while not pq.empty():\n            val, _, node = pq.get()\n            curr.next = ListNode(val)\n            curr = curr.next\n            if node.next:\n                pq.put((node.next.val, i, node.next))\n            i += 1\n        return ans.next\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "\"i\" is used to act as second comparator for PriorityQueue in case when node.val gets equal for two nodes. Since head (a pointer or object instance) cant be used to compare.",
    "hints": [
      "Consider the merge operation in merge sort"
    ]
  },
  {
    "id": "step_11_-_heaps_min-cost-of-rope",
    "title": "Min Cost Of Rope",
    "file_path": "Step 11 - Heaps/MIN-COST-OF-ROPE.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Easy",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Heap"
    ],
    "solution_code": "from typing import List\nimport heapq\n\n'''\nHint: Min Cost when we merge two smallest ropes!\n'''\n\nclass Solution:\n    def minCost(self, arr: List[int], n: int):\n        heapq.heapify(arr)\n        cost = 0\n        while len(arr) > 1:\n            a = heapq.heappop(arr)\n            b = heapq.heappop(arr)\n            cost += a + b\n            heapq.heappush(arr, a+b)\n        return cost\n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Hint: Min Cost when we merge two smallest ropes!",
    "hints": []
  },
  {
    "id": "step_11_-_heaps_k-most-frequent",
    "title": "K Most Frequent",
    "file_path": "Step 11 - Heaps/K-MOST-FREQUENT.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Easy",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Heap",
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import Counter, defaultdict\nimport heapq\n\n\n# Using purely Hashtable (Better)\nclass Solution1:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        nums = [(key, value) for key, value in Counter(nums).items()]\n        nums.sort(reverse=True, key=lambda x: x[1])\n        return [nums[i][0] for i in range(k)]\n\n\n# Using Heap with Hashtable\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        mp = defaultdict(int, Counter(nums))\n        arr = []\n        for key, value in mp.items():\n            arr.append((-value, key))\n        heapq.heapify(arr)\n        ans = []\n        while k:\n            _, item = heapq.heappop(arr)\n            ans.append(item)\n            k -= 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Using purely Hashtable (Better) Using Heap with Hashtable",
    "hints": []
  },
  {
    "id": "step_11_-_heaps_kth-largest",
    "title": "Kth Largest",
    "file_path": "Step 11 - Heaps/KTH-LARGEST.py",
    "category": "Step 11 - Heaps",
    "step": "Step 11 - Heaps",
    "difficulty": "Easy",
    "patterns": [
      "Heap",
      "Priority Queue"
    ],
    "concepts": [
      "Heap"
    ],
    "solution_code": "from typing import List\nimport heapq\n\n\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        nums = list(map(lambda x: -x, nums))\n        heapq.heapify(nums)\n        ans = None\n        while k > 0:\n            ans = heapq.heappop(nums)\n            k -= 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_03_-_arrays_max-product-subarr",
    "title": "Max Product Subarr",
    "file_path": "Step 03 - Arrays/MAX-PRODUCT-SUBARR.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\nfrom sys import maxsize\n\n\n# METHOD 1 : BRUTE FORCE\nclass Solution1:\n    def maxProduct(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = -maxsize\n        for i in range(n):\n            prod = 1\n            for j in range(i, n):\n                prod *= nums[j]\n                ans = max(ans, prod)\n        return ans\n\n\n# BETTER APPROACH\nclass Solution2:\n    def maxProduct(self, nums: List[int]) -> int:\n        pref = suff = 1\n        ans, n = -maxsize, len(nums)\n        for i in range(n):\n            pref *= nums[i]\n            suff *= nums[n-1-i]\n            ans = max(ans, pref, suff)\n            if not pref:\n                pref = 1\n            if not suff:\n                suff = 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "METHOD 1 : BRUTE FORCE BETTER APPROACH",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_longest-subarr-with-sum-k",
    "title": "Longest Subarr With Sum K",
    "file_path": "Step 03 - Arrays/LONGEST-SUBARR-WITH-SUM-K.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\n\n# METHOD 1 : FOR +ve only elements\nclass Solution1:\n    def lenOfLongSubarr1(self, arr: List[int], n, k):\n        n, ans, cum = len(arr), 0, 0\n        i = j = 0\n        while j < n:\n            cum += arr[j]\n            while i <= j and cum > k:\n                ans -= arr[i]\n                i += 1\n            if cum == k:\n                ans = max(ans, j - i + 1)\n            j += 1\n        return ans\n\n\n# METHOD 2 : FOR +ve and -ve elements\nclass Solution:\n    def lenOfLongSubarr(self, arr, n, k):\n        mp = defaultdict()\n        x, ans = 0, 0\n        for i in range(n):\n            x += arr[i]\n            if x == k:\n                ans = max(ans, i+1)\n            req = x - k\n            if req in mp:\n                ans = max(ans, i - mp[req])\n            if x not in mp:\n                mp[x] = i\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "METHOD 1 : FOR +ve only elements METHOD 2 : FOR +ve and -ve elements",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_set-matrix-zero",
    "title": "Set Matrix Zero",
    "file_path": "Step 03 - Arrays/SET-MATRIX-ZERO.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\n\nclass Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        n, m = len(matrix), len(matrix[0])\n        i = j = col0 = 0\n        for i in range(n):\n            for j in range(m):\n                if not matrix[i][j]:\n                    if i != 0:\n                        matrix[0][j] = matrix[i][0] = 0\n                    else:\n                        col0 = 1\n        for i in range(1, n):\n            for j in range(1, m):\n                if not matrix[0][j] or not matrix[i][0]:\n                    matrix[i][j] = 0\n        if matrix[0][0] == 0:\n            for i in range(n):\n                matrix[i][0] = 0\n        if col0:\n            for j in range(m):\n                matrix[0][j] = 0\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_rotate-image",
    "title": "Rotate Image",
    "file_path": "Step 03 - Arrays/ROTATE-IMAGE.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution1:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n, m = len(matrix), len(matrix[0])\n        dummy = [[0 for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                ni, nj = j, n - 1 - i\n                dummy[ni][nj] = matrix[i][j]\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] = dummy[i][j]\n\n# OPTIMISED SOLUTION\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n, m = len(matrix), len(matrix[0])\n        for i in range(n):\n            for j in range(i, m):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(n):\n            matrix[i].reverse()\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "OPTIMISED SOLUTION",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_subarr-sum-eq-k",
    "title": "Subarr Sum Eq K",
    "file_path": "Step 03 - Arrays/SUBARR-SUM-EQ-K.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\n\nclass Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        mp = defaultdict(int)\n        pref, count = 0, 0\n        mp[0] = 1\n        for item in nums:\n            pref += item\n            if (pref - k) in mp:\n                count += mp[pref-k]\n            mp[pref] += 1\n        return count\n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_merge-sorted-arr",
    "title": "Merge Sorted Arr",
    "file_path": "Step 03 - Arrays/MERGE-SORTED-ARR.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        i, j, k = m-1, n-1, (m+n-1)\n        while j >= 0:\n            if i >= 0 and nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Do not return anything, modify nums1 in-place instead.",
    "hints": [
      "Consider using two pointers technique",
      "Think about different sorting algorithms and their properties",
      "Consider the merge operation in merge sort"
    ]
  },
  {
    "id": "step_03_-_arrays_3-sum",
    "title": "3 Sum",
    "file_path": "Step 03 - Arrays/3-SUM.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\n\nclass Solution1:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        n, ans = len(nums), set()\n        for i in range(n):\n            st = set()\n            for j in range(i + 1, n):\n                target = -(nums[i] + nums[j])\n                if target in st:\n                    p, q, r = nums[i], nums[j], target\n                    ans.add(sorted((p, q, r)))\n                st.add(nums[j])\n        return list(ans)\n\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        nums.sort()\n        ans = []\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue  # skip duplicates\n            j, k = i + 1, n - 1\n            while j < k:\n                res = nums[i] + nums[j] + nums[k]\n                if res == 0:\n                    ans.append([nums[i], nums[j], nums[k]])\n                    j += 1\n                    k -= 1\n                elif res > 0:\n                    k -= 1\n                else:\n                    j += 1\n                while j < k and nums[j] == nums[j + 1]:\n                    j += 1\n                while j < k and nums[k] == nums[k - 1]:\n                    k -= 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_2-sum",
    "title": "2 Sum",
    "file_path": "Step 03 - Arrays/2-SUM.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\n# USING SORTING AND TWO POINTERS\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        nums = sorted(list(enumerate(nums)), key=lambda x: x[1])\n        n = len(nums)\n        i, j = 0, n - 1\n        while i < j:\n            if nums[i][1] + nums[j][1] == target:\n                return [nums[i][0], nums[j][0]]\n            elif nums[i][1] + nums[j][1] < target:\n                i += 1\n            else:\n                j -= 1\n        return []\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "USING SORTING AND TWO POINTERS",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_missing-repeating",
    "title": "Missing Repeating",
    "file_path": "Step 03 - Arrays/MISSING-REPEATING.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\nfrom functools import reduce\n\n\n# USING EXTRA SPACE\nclass Solution1:\n    def findTwoElement(self, arr: List[int], n: int):\n        mp = defaultdict(int, {key: arr.count(key) for key in set(arr)})\n        a = b = None\n        for i in range(1, n + 1):\n            if mp[i] == 2:\n                a = i\n            if i not in mp or not mp[i]:\n                b = i\n        return [a, b]\n\n\n# T.C: O(nlogn + n)\nclass Solution2:\n    def findTwoElement(self, arr, n):\n        arr.sort()\n        temp, rep, mis = sum(arr), None, None\n        for i in range(1, n):\n            if arr[i] == arr[i - 1]:\n                rep = arr[i]\n                break\n        temp -= rep\n        mis = (n * (n + 1) // 2) - temp\n        return [rep, mis]\n\n\n# METHOD 3 : USING MATHS\nclass Solution3:\n    def findTwoElement(self, arr, n):\n        s = sum(arr)\n        sn = (n * (n + 1)) // 2\n        sn2 = (n * (n + 1) * (2 * n + 1)) // 6\n        s2 = sum(list(map(lambda x: x * x, arr)))\n        v1 = s - sn\n        v2 = (s2 - sn2) // v1\n        return [(v1 + v2) // 2, ((v1 + v2) // 2 - v1)]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "USING EXTRA SPACE T.C: O(nlogn + n) METHOD 3 : USING MATHS",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_grumpy-bookstore-owner",
    "title": "Grumpy Bookstore Owner",
    "file_path": "Step 03 - Arrays/GRUMPY-BOOKSTORE-OWNER.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\n        n = len(grumpy)\n        ans = 0\n        for i in range(n):\n            if not grumpy[i]:\n                ans += customers[i]\n                customers[i] = 0\n        pref = maxi = 0\n        pref_arr = [0]\n        for i in range(n):\n            pref += customers[i]\n            pref_arr.append(pref)\n            if i >= minutes-1:\n                maxi = max(maxi, pref_arr[i+1] - pref_arr[i+1-minutes])\n        return ans + maxi\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_rotate-array-d-places",
    "title": "Rotate Array D Places",
    "file_path": "Step 03 - Arrays/ROTATE-ARRAY-D-PLACES.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        n = len(nums)\n        k = k % n\n\n        # method 1 : due to some reason not working on leetcode\n        # nums = nums[::-1]\n        # nums[:k] = nums[:k][::-1]\n        # nums[k:] = nums[k:][::-1]\n        # print(nums)\n\n        # method 2 :\n        nums[:] = nums[n - k:] + nums[:n - k]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "method 1 : due to some reason not working on leetcode nums = nums[::-1] nums[:k] = nums[:k][::-1] nums[k:] = nums[k:][::-1] print(nums) method 2 :",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_contiguous-array",
    "title": "Contiguous Array",
    "file_path": "Step 03 - Arrays/CONTIGUOUS-ARRAY.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from collections import defaultdict\nfrom typing import List\n\n\nclass Solution:\n    def findMaxLength(self, nums: List[int]) -> int:\n        ans = x = 0\n        n, mp = len(nums), defaultdict()\n        for i in range(n):\n            x = x + 1 if nums[i] else x - 1\n            if x == 0:\n                ans = max(ans, i+1)\n            req = x - 0  # i.e., if x already exists in the mp -> then the subarray b/w mp[x] and i would be having\n            # sum = 0 hence equal no. of 0s and 1s\n            if req in mp:\n                ans = max(ans, i - mp[req])\n            if x not in mp:\n                mp[x] = i\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "sum = 0 hence equal no. of 0s and 1s",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_rev-pairs",
    "title": "Rev Pairs",
    "file_path": "Step 03 - Arrays/REV-PAIRS.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n# PRE-REQ: COUNT INVERSIONS PROBLEM\n\nclass Solution:\n    def reversePairs(self, arr: List[int]) -> int:\n        n = len(arr)\n        return self.mergeSort(arr, 0, n - 1)\n\n    def mergeSort(self, arr: List[int], low: int, high: int) -> int:\n        if low >= high:\n            return 0\n        mid = low + ((high - low) // 2)\n        ans = self.mergeSort(arr, low, mid) + self.mergeSort(arr, mid + 1, high) + self.merge(arr, low, mid, high)\n        return ans\n\n    def merge(self, arr: List[int], low: int, mid: int, high: int) -> int:\n        temp, ans = [], 0\n        i, j = low, mid + 1\n        ######################################\n        # SLIGHT MODIFICATION FROM PROBLEM 'Count Inversions'\n        while i <= mid and j <= high:\n            if arr[i] > 2 * arr[j]:\n                ans += (mid + 1 - i)\n                j += 1\n            else:\n                i += 1\n        ######################################\n        i, j = low, mid + 1\n        while i <= mid and j <= high:\n            if arr[i] < arr[j]:\n                temp.append(arr[i])\n                i += 1\n            else:\n                temp.append(arr[j])\n                j += 1\n        while i <= mid:\n            temp.append(arr[i])\n            i += 1\n        while j <= high:\n            temp.append(arr[j])\n            j += 1\n        arr[low:high + 1] = temp[:]\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "PRE-REQ: COUNT INVERSIONS PROBLEM ##################################### SLIGHT MODIFICATION FROM PROBLEM 'Count Inversions' #####################################",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_count-inversions",
    "title": "Count Inversions",
    "file_path": "Step 03 - Arrays/COUNT-INVERSIONS.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def inversionCount(self, arr: List[int], n: int) -> int:\n        n = len(arr)\n        return self.mergeSort(arr, 0, n-1)\n\n    def mergeSort(self, arr: List[int], low: int, high: int) -> int:\n        if low >= high:\n            return 0\n        mid = low + ((high - low) // 2)\n        left = self.mergeSort(arr, low, mid)\n        right = self.mergeSort(arr, mid + 1, high)\n        ans = self.merge(arr, low, mid, high)\n        ans += left + right\n        return ans\n\n    def merge(self, arr: List[int], low: int, mid: int, high: int) -> int:\n        temp, ans = [], 0\n        i, j = low, mid + 1\n        while i <= mid and j <= high:\n            if arr[i] <= arr[j]:\n                temp.append(arr[i])\n                i += 1\n            else:\n                ans += (mid + 1 - i)\n                temp.append(arr[j])\n                j += 1\n        while i <= mid:\n            temp.append(arr[i])\n            i += 1\n        while j <= high:\n            temp.append(arr[j])\n            j += 1\n        arr[low:high+1] = temp[:]\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_print-max-sum-subarr",
    "title": "Print Max Sum Subarr",
    "file_path": "Step 03 - Arrays/PRINT-MAX-SUM-SUBARR.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\nfrom sys import maxsize\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        ans, temp, i, j, ai, aj, n = -maxsize-1, 0, 0, 0, 0, 0, len(nums)\n        for k in range(n):\n            temp += nums[k]\n            if temp >= ans:\n                j = k\n                if temp > ans:\n                    ai, aj = i, j\n                    ans = temp\n                else:\n                    if j-i > aj-ai:\n                        ai, aj = i, j\n            if temp < 0:\n                temp = 0\n                i = k\n        print(nums[ai:aj+1])\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_spiral-matrix",
    "title": "Spiral Matrix",
    "file_path": "Step 03 - Arrays/SPIRAL-MATRIX.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def spiralOrder(self, grid: List[List[int]]) -> List[int]:\n        n, m = len(grid), len(grid[0])\n        top, bot, left, right = 0, n - 1, 0, m - 1\n        count, total = 0, n * m\n        ans = []\n        while count < total:\n            # top row\n            for j in range(left, right + 1):\n                ans.append(grid[top][j])\n                count += 1\n            if count == total:\n                break\n            top += 1\n            # right col\n            for i in range(top, bot + 1):\n                ans.append(grid[i][right])\n                count += 1\n            if count == total:\n                break\n            right -= 1\n            # bottom row\n            for j in range(right, left - 1, -1):\n                ans.append(grid[bot][j])\n                count += 1\n            if count == total:\n                break\n            bot -= 1\n            # left col\n            for i in range(bot, top-1, -1):\n                ans.append(grid[i][left])\n                count += 1\n            if count == total:\n                break\n            left += 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "top row right col bottom row left col",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_3-sum-closest",
    "title": "3 Sum Closest",
    "file_path": "Step 03 - Arrays/3-SUM-CLOSEST.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\nfrom sys import maxsize\n\n\nclass Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        ans, dev = None, maxsize\n        for i in range(n-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            j, k = i+1, n-1\n            while j < k:\n                res = nums[i] + nums[j] + nums[k]\n                print(nums[i], nums[j], nums[k])\n                if res == target:\n                    return target\n                elif res < target:\n                    d = abs(target - res)\n                    if d < dev:\n                        ans, dev = res, d\n                    j += 1\n                else:\n                    d = abs(target - res)\n                    if d < dev:\n                        ans, dev = res, d\n                    k -= 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_kth-element",
    "title": "Kth Element",
    "file_path": "Step 03 - Arrays/KTH-ELEMENT.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def kthElement(self, arr1: List[int], arr2: List[int], n: int, m: int, k: int):\n        i = j = 0\n        if k > n + m:\n            return -1\n        while i < n and j < m:\n            k -= 1\n            if k == 0:\n                return min(arr1[i], arr2[j])\n            if arr1[i] <= arr2[j]:\n                i += 1\n            else:\n                j += 1\n        while i < n:\n            k -= 1\n            if k == 0:\n                return arr1[i]\n            i += 1\n        while j < m:\n            k -= 1\n            if k == 0:\n                return arr2[j]\n            j += 1\n        return -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_array-leaders",
    "title": "Array Leaders",
    "file_path": "Step 03 - Arrays/ARRAY-LEADERS.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def leaders(self, n, arr):\n        maxi, n = -1, len(arr)\n        ans = []\n        for i in range(n-1, -1, -1):\n            if arr[i] >= maxi:\n                ans.append(arr[i])\n                maxi = arr[i]\n        return reversed(arr)\n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_move-zeros-to-end",
    "title": "Move Zeros To End",
    "file_path": "Step 03 - Arrays/MOVE-ZEROS-TO-END.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        i = j = 0\n        n = len(nums)\n        while j < n:\n            while j < n and nums[j] == 0:\n                j += 1\n            nums[i] = nums[j]\n            i += 1\n            j += 1\n        if i < n:\n            nums[i:] = [0] * (n - i)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_longest-consecutive-subseq",
    "title": "Longest Consecutive Subseq",
    "file_path": "Step 03 - Arrays/LONGEST-CONSECUTIVE-SUBSEQ.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def findLongestConseqSubseq(self, arr: List[int], n: int):\n        arr.sort()\n        count = ans = 1\n        n, last, curr = len(arr), 0, 1\n        while curr < n:\n            while curr < n and arr[curr] == arr[curr - 1]:\n                curr += 1\n                if curr >= n:\n                    break\n            if arr[curr] == arr[last] + 1:\n                count += 1\n                ans = max(ans, count)\n            else:\n                count = 1\n            last, curr = curr, curr + 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_pascal-triang",
    "title": "Pascal Triang",
    "file_path": "Step 03 - Arrays/PASCAL-TRIANG.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\nfrom math import comb as ncr\n\n\nclass Solution:\n    def generate(self, n: int) -> List[List[int]]:\n        ans = []\n        for i in range(n):\n            curr = [-1 for _ in range(i+1)]\n            for j in range(i//2 + 1):\n                curr[j] = curr[i-j] = ncr(i, j)\n            ans.append(curr)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_merge-intervals",
    "title": "Merge Intervals",
    "file_path": "Step 03 - Arrays/MERGE-INTERVALS.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n        # first sort for intervals[i][0] and if equal then sort wrt intervals[i][1]\n        ans, n = [], len(intervals)\n        start, end = intervals[0][0], intervals[0][1]\n        if n <= 1:  # Edge Case: [[]] or [[1, 4]]\n            return intervals\n        for i in range(1, n):\n            s, e = intervals[i]\n            if s <= end:\n                end = max(end, e)  # Edge Case: [[1, 4], [2, 3]]\n            else:\n                ans.append([start, end])\n                start, end = s, e\n            if i == n-1:\n                ans.append([start, end])\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "first sort for intervals[i][0] and if equal then sort wrt intervals[i][1]",
    "hints": [
      "Consider using two pointers technique",
      "Consider the merge operation in merge sort"
    ]
  },
  {
    "id": "step_03_-_arrays_spiral-matrix-iv",
    "title": "Spiral Matrix Iv",
    "file_path": "Step 03 - Arrays/SPIRAL-MATRIX-IV.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List, Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        grid = [[-1 for _ in range(n)] for _ in range(m)]\n        top = 0\n        bottom = m-1\n        left = 0\n        right = n-1\n        while head:\n            # filling the top row\n            j = left\n            while head and j <= right:\n                grid[top][j] = head.val\n                head = head.next\n                j += 1\n            top += 1\n            i = top\n            while head and i <= bottom:\n                grid[i][right] = head.val\n                head = head.next\n                i += 1\n            right -= 1\n            j = right\n            while head and j >= left:\n                grid[bottom][j] = head.val\n                head = head.next\n                j -= 1\n            bottom -= 1\n            i = bottom\n            while head and i >= top:\n                grid[i][left] = head.val\n                head = head.next\n                i -= 1\n            left += 1\n        return grid\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "filling the top row",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_sort-0s-1s-2s",
    "title": "Sort 0S 1S 2S",
    "file_path": "Step 03 - Arrays/SORT-0S-1S-2S.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        n = len(nums)\n        i, j, k = 0, n-1, 0\n        while k <= j:\n            if nums[k] == 0:\n                nums[i], nums[k] = nums[k], nums[i]\n                i += 1\n                k += 1\n            elif nums[k] == 1:\n                k += 1\n            else:\n                nums[k], nums[j] = nums[j], nums[k]\n                j -= 1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_03_-_arrays_max-sum-subarray",
    "title": "Max Sum Subarray",
    "file_path": "Step 03 - Arrays/MAX-SUM-SUBARRAY.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\nfrom sys import maxsize\n# KADANE'S ALGORITHM\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        ans, temp = -maxsize - 1, 0\n        for item in nums:\n            temp += item\n            ans = max(ans, temp)\n            if temp < 0:\n                temp = 0\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "KADANE'S ALGORITHM",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_remove-duplicates-sorted-arr",
    "title": "Remove Duplicates Sorted Arr",
    "file_path": "Step 03 - Arrays/REMOVE-DUPLICATES-SORTED-ARR.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def removeDuplicates(self, arr: List[int]) -> int:\n        i = j = 0\n        n = len(arr)\n        while i < n and j < n:\n            while j < (n-1) and arr[j] == arr[j+1]:\n                j += 1\n            arr[i] = arr[j]\n            i, j = i+1, j+1\n        return i\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique",
      "Think about different sorting algorithms and their properties"
    ]
  },
  {
    "id": "step_03_-_arrays_majority-element",
    "title": "Majority Element",
    "file_path": "Step 03 - Arrays/MAJORITY-ELEMENT.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n# assume that majority element always exist!\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        ans, vote = nums[0], 1\n        for item in nums[1:]:\n            if item == ans:\n                vote += 1\n            else:\n                vote -= 1\n                if vote == 0:\n                    ans, vote = item, 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "assume that majority element always exist!",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_best-time-to-buy-sell-stock",
    "title": "Best Time To Buy Sell Stock",
    "file_path": "Step 03 - Arrays/BEST-TIME-TO-BUY-SELL-STOCK.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        profit = 0\n        buy = prices[0]\n        for price in prices[1:]:\n            if price > buy:\n                profit = max(profit, price - buy)\n            else:\n                buy = price\n        return profit\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_next-permutation",
    "title": "Next Permutation",
    "file_path": "Step 03 - Arrays/NEXT-PERMUTATION.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Hard",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\nfrom sys import maxsize\n\n\n# GENERATING ALL POSSIBLE PERMUTATIONS\nclass Solution1:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n, ans = len(nums), []\n\n        def recursion(arr: List[int], index: int):\n            if index == n:\n                ans.append(arr[:])\n                return\n            for i in range(index, n):\n                arr[i], arr[index] = arr[index], arr[i]\n                recursion(arr, index + 1)\n                arr[i], arr[index] = arr[index], arr[i]\n\n        recursion(nums, 0)\n        print(ans)\n\n\narr = [1, 2, 3]\nobj = Solution1()\nobj.nextPermutation(arr)\n\n\n# OPTIMISED SOLUTION\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        i = n - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i < 0:\n            nums.sort()\n        else:\n            k = i + 1\n            for j in range(i+2, n):\n                if nums[i] < nums[j] <= nums[k]:\n                    k = j\n            nums[i], nums[k] = nums[k], nums[i]\n            nums[i+1:] = reversed(nums[i+1:])\n\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "GENERATING ALL POSSIBLE PERMUTATIONS Do not return anything, modify nums in-place instead.",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_largest-subarr-with-zero-sum",
    "title": "Largest Subarr With Zero Sum",
    "file_path": "Step 03 - Arrays/LARGEST-SUBARR-WITH-ZERO-SUM.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\n\nclass Solution:\n    def maxLen(self, n, arr):\n        temp, mp = 0, defaultdict(int)\n        ans = 0\n        for i in range(len(arr)):\n            temp += arr[i]\n            if temp == 0:\n                ans = i+1\n            elif temp in mp:\n                ans = max(ans, i - mp[temp])\n            if temp not in mp:\n                mp[temp] = i\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_4-sum",
    "title": "4 Sum",
    "file_path": "Step 03 - Arrays/4-SUM.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        n = len(nums)\n        ans = []\n        for i in range(n-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, n-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, n-1\n                while l < r:\n                    res = sum([nums[i], nums[j], nums[l], nums[r]])\n                    if res == target:\n                        ans.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif res < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_majority-element-2",
    "title": "Majority Element 2",
    "file_path": "Step 03 - Arrays/MAJORITY-ELEMENT-2.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        ans1, ans2, vote1, vote2, n = -1, -1, 0, 0, len(nums)\n        for item in nums:\n            if item == ans1:\n                vote1 += 1\n            elif item == ans2:\n                vote2 += 1\n            elif vote1 == 0:\n                ans1, vote1 = item, 1\n            elif vote2 == 0:\n                ans2, vote2 = item, 1\n            else:\n                vote1 -= 1\n                vote2 -= 1\n        vote1 = vote2 = 0\n        for item in nums:\n            if item == ans1:\n                vote1 += 1\n            elif item == ans2:\n                vote2 += 1\n        return [x[0] for x in [[ans1, vote1], [ans2, vote2]] if x[1] > n // 3]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_subarr-with-xor-x",
    "title": "Subarr With Xor X",
    "file_path": "Step 03 - Arrays/SUBARR-WITH-XOR-X.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict as hashmap\n\n\nclass Solution:\n    # @param A : list of integers\n    # @param B : integer\n    # @return an integer\n    def solve(self, A: List[int], B: int):\n        xor, n, ans = 0, len(A), 0\n        mp = hashmap(int)\n        for i in range(n):\n            xor ^= A[i]\n            if xor == B:\n                ans += 1\n            target = xor ^ B\n            ans += mp[target]\n            mp[xor] += 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "@param A : list of integers @param B : integer @return an integer",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_03_-_arrays_union-find",
    "title": "Union Find",
    "file_path": "Step 03 - Arrays/UNION-FIND.py",
    "category": "Step 03 - Arrays",
    "step": "Step 03 - Arrays",
    "difficulty": "Easy",
    "patterns": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n\n    # Function to return a list containing the union of the two arrays.\n    def findUnion(self, arr1, arr2, n, m):\n        \"\"\"\n        :param arr1: given sorted array a\n        :param n: size of sorted array a\n        :param arr2: given sorted array b\n        :param m: size of sorted array b\n        :return:  The union of both arrays as a list\n        \"\"\"\n        i = j = 0\n        ans = []\n        while i < n and j < m:\n            while i+1 < n and arr1[i] == arr1[i+1]:\n                i += 1\n            while j+1 < m and arr2[j] == arr2[j+1]:\n                j += 1\n            if arr1[i] < arr2[j]:\n                ans.append(arr1[i])\n                i += 1\n            elif arr2[j] < arr1[i]:\n                ans.append(arr2[j])\n                j += 1\n            else:\n                ans.append(arr1[i])\n                i += 1\n                j += 1\n        while i < n:\n            while i+1 < n and arr1[i] == arr1[i+1]:\n                i += 1\n            ans.append(arr1[i])\n            i += 1\n        while j < m:\n            while j+1 < m and arr2[j] == arr2[j+1]:\n                j += 1\n            ans.append(arr2[j])\n            j += 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Function to return a list containing the union of the two arrays. :param arr1: given sorted array a :param n: size of sorted array a :param arr2: given sorted array b :param m: size of sorted array b :return:  The union of both arrays as a list",
    "hints": [
      "Consider using two pointers technique"
    ]
  },
  {
    "id": "step_08_-_bit_manipulation_set-unset-rightmost-unset",
    "title": "Set Unset Rightmost Unset",
    "file_path": "Step 08 - Bit Manipulation/SET-UNSET-RIGHTMOST-UNSET.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def setBit(self, n):\n        mask = n ^ (n + 1)\n        return n | mask\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_08_-_bit_manipulation_sieve",
    "title": "Sieve",
    "file_path": "Step 08 - Bit Manipulation/SIEVE.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def countPrimes(self, n: int) -> int:\n        if n <= 1:\n            return 0\n        isPrime = [True for _ in range(n+1)]\n        for i in range(2, n+1):\n            if isPrime[i]:\n                for k in range(i*i, n+1, i):\n                    isPrime[k] = False\n        return isPrime[2:n].count(True)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_08_-_bit_manipulation_count-set-bits",
    "title": "Count Set Bits",
    "file_path": "Step 08 - Bit Manipulation/COUNT-SET-BITS.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def countSetBits(self, n):\n        return bin(n).count('1')\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_08_-_bit_manipulation_xor-l-to-r",
    "title": "Xor L To R",
    "file_path": "Step 08 - Bit Manipulation/XOR-L-TO-R.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from functools import reduce\n\n\nclass BruteForce:\n    def findXOR(self, l: int, r: int):\n        arr = [i for i in range(l, r + 1)]\n        return reduce(lambda x, y: x ^ y, arr)\n\n\nclass Solution:\n    def helper(self, n: int):\n        mod = n % 4\n        if mod == 0:\n            return n\n        elif mod == 1:\n            return 1\n        elif mod == 2:\n            return n + 1\n        else:\n            return 0\n\n    def findXOR(self, l: int, r: int):\n        xor1 = self.helper(r)  # 1 ^ 2 ^ 3 ^ 4 ^ ...... ^ r\n        xor2 = self.helper(l - 1)  # 1 ^ 2 ^ 3 ^ 4 ^ ... ^ l-1\n        return xor1 ^ xor2\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_08_-_bit_manipulation_prime-factorisation",
    "title": "Prime Factorisation",
    "file_path": "Step 08 - Bit Manipulation/PRIME-FACTORISATION.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def sieve(self, n: int) -> List[int]:\n        isPrime = [True for _ in range(n + 1)]\n        for i in range(2, n + 1):\n            if isPrime[i]:\n                for p in range(i * i, n + 1, i):\n                    isPrime[p] = False\n        return isPrime\n\n    def findPrimeFactors(self, n: int) -> List[int]:\n        isPrime = self.sieve(n)\n        ans = []\n        for i in range(2, n + 1):\n            if isPrime[i]:\n                while n % i == 0:\n                    ans.append(i)\n                    n /= i\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_08_-_bit_manipulation_all-div-of-a-num",
    "title": "All Div Of A Num",
    "file_path": "Step 08 - Bit Manipulation/ALL-DIV-OF-A-NUM.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from math import sqrt\n\n\nclass Solution:\n    def print_divisors(self, n: int):\n        ans = []\n        for i in range(1, int(sqrt(n)+1)):\n            if not (n % i):\n                ans.append(i)\n                if i != n // i:\n                    ans.append(n // i)\n        return sorted(ans)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_08_-_bit_manipulation_count-bits-to-flip-a-to-b",
    "title": "Count Bits To Flip A To B",
    "file_path": "Step 08 - Bit Manipulation/COUNT-BITS-TO-FLIP-A-TO-B.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        return bin(start ^ goal).count('1')\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_08_-_bit_manipulation_check-ith-bit",
    "title": "Check Ith Bit",
    "file_path": "Step 08 - Bit Manipulation/CHECK-ITH-BIT.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class BruteForce:\n    def checkKthBit(self, n: int, k: int) -> bool:\n        binary = bin(n)[1:]\n        return k < len(binary) and binary[-k - 1] == '1'\n\n\nclass Solution:\n    def checkKthBit(self, n: int, k: int) -> bool:\n        return (n >> k & 1)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_08_-_bit_manipulation_two-numbers-with-odd-occurence",
    "title": "Two Numbers With Odd Occurence",
    "file_path": "Step 08 - Bit Manipulation/TWO-NUMBERS-WITH-ODD-OCCURENCE.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\nfrom functools import reduce\n\n\nclass Solution:\n    def singleNumber(self, arr: List[int]):\n        xor = reduce(lambda x, y: x ^ y, arr)\n        rightmost = (xor & xor - 1) ^ xor\n        num1 = num2 = 0\n        for item in arr:\n            if item & rightmost:\n                num1 = num1 ^ item\n            else:\n                num2 = num2 ^ item\n        return [num1, num2]\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_08_-_bit_manipulation_divide-two-int",
    "title": "Divide Two Int",
    "file_path": "Step 08 - Bit Manipulation/DIVIDE-TWO-INT.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        negative = (dividend < 0) ^ (divisor < 0)\n        d = abs(divisor)  # denominator\n        n = abs(dividend)  # numerator\n        ans = 0\n        while n >= d:\n            i = 0\n            while n >= (d << i + 1):\n                i += 1\n            ans += (1 << i)\n            n -= (d << i)\n        ans = -ans if negative else ans\n        return min(2 ** 31 - 1, max(-2 ** 31, ans))\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_08_-_bit_manipulation_power-of-two",
    "title": "Power Of Two",
    "file_path": "Step 08 - Bit Manipulation/POWER-OF-TWO.py",
    "category": "Step 08 - Bit Manipulation",
    "step": "Step 08 - Bit Manipulation",
    "difficulty": "Easy",
    "patterns": [
      "Bit Manipulation"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and n & (n - 1) == 0\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_valid-parantheses-02",
    "title": "Valid Parantheses 02",
    "file_path": "Step 12 - Greedy Algorithm/VALID-PARANTHESES-02.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "class Solution:\n    def recursion(self, s: str, index: int, n: int, count: int) -> bool:\n        # Base Condition\n        if index >= n:\n            return count == 0\n        if count < 0:\n            return False\n        item = s[index]\n        if item == '(':\n            return self.recursion(s, index + 1, n, count + 1)\n        elif item == ')':\n            return self.recursion(s, index + 1, n, count - 1)\n        else:\n            op1 = self.recursion(s, index + 1, n, count + 1)\n            op2 = self.recursion(s, index + 1, n, count)\n            op3 = self.recursion(s, index + 1, n, count - 1)\n            return op1 or op2 or op3\n\n    def checkValidString(self, s: str) -> bool:\n        n = len(s)\n        dp = [[-1 for _ in range(n)] for _ in range(n)]\n\n        def memo(index: int, count: int) -> bool:\n            if index == n:\n                return count == 0\n            if count < 0:\n                return False\n            if dp[index][count] != -1:\n                return dp[index][count]\n            item = s[index]\n            if item == '(':\n                ans = memo(index + 1, count + 1)\n            elif item == ')':\n                ans = memo(index + 1, count - 1)\n            else:\n                op1 = memo(index + 1, count + 1)\n                op2 = memo(index + 1, count - 1)\n                op3 = memo(index + 1, count)\n                ans = op1 or op2 or op3\n            dp[index][count] = ans\n            return ans\n        return memo(0, 0)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Base Condition",
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_shortest-job-first",
    "title": "Shortest Job First",
    "file_path": "Step 12 - Greedy Algorithm/SHORTEST-JOB-FIRST.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n'''\nAll the processes are available at t = 0.\n'''\n\n\nclass Solution:\n    def solve(self, bt: List[int]):\n        time = ans = 0\n        bt.sort()\n        for i in bt:\n            ans += time\n            time += i\n        print(time, ans)\n        return ans // len(bt)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "All the processes are available at t = 0.",
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_assign-cookies",
    "title": "Assign Cookies",
    "file_path": "Step 12 - Greedy Algorithm/ASSIGN-COOKIES.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return i\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_jump-game-02",
    "title": "Jump Game 02",
    "file_path": "Step 12 - Greedy Algorithm/JUMP-GAME-02.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\n\n\n# Dynamic Programming Approach -> T.C O(n^2)\nclass Solution1:\n    def jump(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [-1 for _ in range(n)]\n\n        def memo(index: int) -> int:\n            if index == n - 1:\n                return 0\n            if nums[index] == 0:\n                return int(1e9)\n            if dp[index] != -1:\n                return dp[index]\n            ans = int(1e9)\n            for i in range(1, nums[index] + 1):\n                if index + i < n:\n                    jump = 1 + memo(index + i)\n                    ans = min(ans, jump)\n            dp[index] = ans\n            return ans\n\n        return memo(0)\n\n\n# LINEAR SOLUTION\nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return 0\n        count = i = j = max_reach = 0\n        while i < n-1:\n            max_reach = max(max_reach, i + nums[i])\n            if i == j:\n                count += 1\n                j = max_reach\n                if j >= n-1:\n                    return count\n            i += 1\n        return -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Dynamic Programming Approach -> T.C O(n^2) LINEAR SOLUTION",
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_coin-change",
    "title": "Coin Change",
    "file_path": "Step 12 - Greedy Algorithm/COIN-CHANGE.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Dynamic Programming"
    ],
    "solution_code": "from typing import List\nfrom sys import maxsize\n\n'''\nThis could be done easily using DP but constraints dont allow! -> But theres no solution to this problem without\n/ recursion or DP.\n'''\n\n\nclass Solution:\n    def minCoins(self, coins: List[int], m: int, v: int):\n        dp = [-1 for _ in range(v + 1)]\n\n        def memo(curr: int):\n            if curr == 0:\n                return 0\n            if dp[curr] != -1:\n                return dp[curr]\n            ans = maxsize\n            for i in range(m):\n                if coins[i] <= curr:\n                    temp = 1 + memo(curr - coins[i])\n                    if temp < maxsize and temp < ans:\n                        ans = temp\n            dp[curr] = ans\n            return ans\n\n        ans = memo(v)\n        return ans if ans < maxsize else -1\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "This could be done easily using DP but constraints dont allow! -> But theres no solution to this problem without / recursion or DP.",
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_fractional-knapsack",
    "title": "Fractional Knapsack",
    "file_path": "Step 12 - Greedy Algorithm/FRACTIONAL-KNAPSACK.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional, List\n\n\nclass Item:\n    def __init__(self, val, w):\n        self.value = val\n        self.weight = w\n\n\nclass Solution:\n    def fractionalknapsack(self, w: int, arr: List[Optional[Item]], n: int) -> float:\n        ratio = []\n        for i, item in enumerate(arr):\n            val, weight = item.value, item.weight\n            ratio.append((i, val / weight))\n        ratio.sort(reverse=True, key=lambda x: x[1])\n        ans = 0\n        for i, rate in ratio:\n            if arr[i].weight <= w:\n                w -= arr[i].weight\n                ans += arr[i].value\n            else:\n                ans += rate * w\n                break\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_candy",
    "title": "Candy",
    "file_path": "Step 12 - Greedy Algorithm/CANDY.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Two Pointers"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        count = [1 for _ in range(n)]\n        # left neighbour\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                count[i] = count[i - 1] + 1\n        # right neighbour\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                count[i] = max(count[i], count[i + 1] + 1)\n        return sum(count)\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "left neighbour right neighbour",
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_n-meetings",
    "title": "N Meetings",
    "file_path": "Step 12 - Greedy Algorithm/N-MEETINGS.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def maximumMeetings(self, n: int, start: List[int], end: List[int]) -> int:\n        arr = []\n        for i in range(n):\n            arr.append((start[i], end[i]))\n        last = count = 0\n        arr.sort(key=lambda x: x[1])\n        for s, e in arr:\n            if s > last:\n                count += 1\n                last = e\n        return count\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_jump-game-01",
    "title": "Jump Game 01",
    "file_path": "Step 12 - Greedy Algorithm/JUMP-GAME-01.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        n = len(nums)\n        flag, j = False, None\n        for i in range(n - 2, -1, -1):\n            if not flag and nums[i] == 0:\n                flag = True\n                j = i\n            if flag and nums[i] > j - i:\n                flag = False\n        return not flag\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_page-fault",
    "title": "Page Fault",
    "file_path": "Step 12 - Greedy Algorithm/PAGE-FAULT.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Collections"
    ],
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\n\nclass Solution:\n    def pageFaults(self, n: int, c: int, pages: List[int]):\n        cache, time, count = defaultdict(int), 0, 0\n        for item in pages:\n            if item in cache:\n                cache[item] = time\n            else:\n                count += 1\n                if len(cache) < c:\n                    cache[item] = time\n                else:\n                    lru, t = None, n\n                    for key, value in cache.items():\n                        if value < t:\n                            lru, t = key, value\n                    cache.pop(lru)\n                    cache[item] = time\n            time += 1\n        return count\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_min-number-platforms",
    "title": "Min Number Platforms",
    "file_path": "Step 12 - Greedy Algorithm/MIN-NUMBER-PLATFORMS.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def minimumPlatform(self, n: int, arr: List[int], dep: List[int]):\n        n, nums = len(arr), []\n        nums += [(i, 'a') for i in arr]\n        nums += [(i, 'd') for i in dep]\n        nums.sort()\n        ans = count = 0\n        for _, item in nums:\n            if item == 'a':\n                count += 1\n            else:\n                count -= 1\n            ans = max(ans, count)\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_insert-interval",
    "title": "Insert Interval",
    "file_path": "Step 12 - Greedy Algorithm/INSERT-INTERVAL.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n'''\nSimilar to 'Merge Intervals' Problem\n'''\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        intervals.append(newInterval)\n        intervals.sort()\n        n = len(intervals)\n        i = 0\n        ans = []\n        while i < n:\n            start, end = intervals[i][0], intervals[i][1]\n            j = i + 1\n            while j < n and intervals[j][0] <= end:\n                end = max(end, intervals[j][1])\n                j += 1\n            ans.append([start, end])\n            i = j\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Similar to 'Merge Intervals' Problem",
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_merge-intervals",
    "title": "Merge Intervals",
    "file_path": "Step 12 - Greedy Algorithm/MERGE-INTERVALS.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort()\n        ans, n, i = [], len(intervals), 0\n        while i < n:\n            start, end = intervals[i][0], intervals[i][1]\n            j = i + 1\n            while j < n and intervals[j][0] <= end:\n                end = max(end, intervals[j][1])\n                j += 1\n            ans += [[start, end]]\n            i = j\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": [
      "Consider the merge operation in merge sort"
    ]
  },
  {
    "id": "step_12_-_greedy_algorithm_valid-parantheses-01",
    "title": "Valid Parantheses 01",
    "file_path": "Step 12 - Greedy Algorithm/VALID-PARANTHESES-01.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Stack"
    ],
    "solution_code": "class Solution1:\n    def isValid(self, s: str) -> bool:\n        count = 0\n        for item in s:\n            if item == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        for item in s:\n            if item == '(' or item == '[' or item == '{':\n                stack.append(item)\n            elif item == ')':\n                if len(stack) > 0 and stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n            elif item == ']':\n                if len(stack) > 0 and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n            elif item == '}':\n                if len(stack) > 0 and stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n        return len(stack) == 0\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": null,
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_non-overlapping-intervals",
    "title": "Non Overlapping Intervals",
    "file_path": "Step 12 - Greedy Algorithm/NON-OVERLAPPING-INTERVALS.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import List\n\n'''\nExplanation: https://www.youtube.com/watch?v=nONCGxWoUfM\n'''\n\nclass Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        i = 0\n        n = len(intervals)\n        ans = 0\n        j = 1\n        while i < n - 1 and j < n:\n            s1, e1 = intervals[i]\n            s2, e2 = intervals[j]\n            if s2 < e1:\n                ans += 1\n                if e2 <= e1:\n                    i = j\n            else:\n                i = j\n            j += 1\n        return ans\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "Explanation: https://www.youtube.com/watch?v=nONCGxWoUfM",
    "hints": []
  },
  {
    "id": "step_12_-_greedy_algorithm_job-seq-problem",
    "title": "Job Seq Problem",
    "file_path": "Step 12 - Greedy Algorithm/JOB-SEQ-PROBLEM.py",
    "category": "Step 12 - Greedy Algorithm",
    "step": "Step 12 - Greedy Algorithm",
    "difficulty": "Easy",
    "patterns": [
      "Greedy",
      "Sorting"
    ],
    "concepts": [
      "Implementation"
    ],
    "solution_code": "from typing import Optional, List\n\n\nclass Job:\n    def __init__(self, profit=0, deadline=0):\n        self.profit = profit\n        self.deadline = deadline\n        self.id = 0\n\n\n'''\n1 <= deadline <= N \n'''\n'''The strategy to maximize profit should be to pick up jobs that offer higher profits. Hence we should sort the jobs \nin descending order of profit. Now say if a job has a deadline of 4 we can perform it anytime between day 1-4, \nbut it is preferable to perform the job on its last day. This leaves enough empty slots on the previous days to \nperform other jobs.'''\n\n\nclass Solution:\n    def JobScheduling(self, jobs: List[Optional[Job]], n: int):\n        jobs.sort(key=lambda x: -x.profit)\n        booked = [False for _ in range(n + 1)]\n        count = profit = 0\n        for item in jobs:\n            _, dead, prof = item.id, item.deadline, item.profit\n            if not booked[dead]:\n                booked[dead] = True\n                count += 1\n                profit += prof\n            else:\n                while dead and booked[dead]:\n                    dead -= 1\n                if dead >= 1:\n                    booked[dead] = True\n                    profit += prof\n                    count += 1\n        return count, profit\n",
    "time_complexity": null,
    "space_complexity": null,
    "description": "1 <= deadline <= N",
    "hints": []
  }
]